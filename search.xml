<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin笔记之程序结构]]></title>
    <url>%2F2018%2F02%2F27%2FKotlin%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[常量与变量 常量– val = value, 值类型– 类似Java的final– 不可重复赋值 运行时常量：val x = 5编译期常量：const val x = 5 变量– var = variable var x = “x”x = “y” //再次赋值 类型推导 val s = “hello” //Stringval x = 5 //Intvar z = “z” + 5 //String 函数函数定义：– fun 函数名:[返回值类型]{[函数体]}– fun 函数名=[表达式]匿名函数：fun(参数列表)…123456789101112131415161718192021222324252627282930313233//匿名函数val result = fun(x: Int) = 2 * x//函数fun double1(x: Int): Int &#123; return 2 * x&#125;fun double2(x: Int): Int = 2 * xfun out1(): Unit &#123; println("out")&#125;fun out2() &#123; println("out")&#125;fun inner() &#123; val s = "String" println(s) //局部函数 fun inInner() &#123; println("in inner $s") &#125; inInner()&#125;fun sum(a: Int, b: Int = 2, c: Int = 3): Int &#123; return a + b + c&#125; ###Lambda 表达式Lambda表达式是匿名函数：{[参数列表] -&gt; [函数体， 最后一行是返回值]}12345678910var mul = &#123; arg1: Int, arg2: Int -&gt; println("-------------") arg1 * arg2&#125;newSum(3, 2, &#123; s, y -&gt; (s * y).toLong() &#125;)fun newSum(a: Int, b: Int, body: (Int, Int) -&gt; Long) &#123; println(body(a, b))&#125; Lambda 的类型示例： ()-&gt;Unit 无参 返回Unit (Int)-&gt;Int 传入Int 返回Int (String,(String)-&gt;String)-&gt;Boolean 传入String Lambda表达式 返回BooleanLambda表达式调用：用()调用 等价于 invoke() var mul = { arg1: Int, arg2: Int -&gt; println(“————-“) arg1 * arg2}sum(2,3)sum.invoke(2,3) Lambda 表达式简化：函数参数调用时最后一个Lambda可以移出去函数参数只有一个Lambda，调用时小括号可以省略Lambda 只有一个参数可以认为it入参、返回值与形参一致的函数可以用函数引用的方式作为实参传入 类成员 属性 或者说成员变量，类范围内的变量 方法 或者说成员函数，类范围内的函数 函数和方法的区别： 函数强调功能本身，不考虑从属 方法的称呼通常是从类的角度出发 定义方法： 写法与普通函数完全一致，只是它时写在类里面的 定义属性： 构造方法参数中 val/var 修饰的都是属性 没有修饰的仅是一个参数 类内部也是可以定义属性 属性访问控制：属性可以定义 getter / setter (val 只能定义getter) 属性初始化： 属性的初始化尽量放在构造方法中完成 无法再构造方法中初始化， 尝试降级为局部变量 若无法在工造函数中初始化且无法降级 var 用lateinit 延迟初始化 val 用lazy 可空类型谨慎用 null 初始化，否则使用时需要做 null 处理 12345678910111213141516171819202122232425262728293031323334353637383940class A &#123; //常量 const 修饰则是编译器常量 val FINAL_STRING = "hello world" var filedA = 0 //常量只能有getter val fieldB: Int = 1 get() &#123; return field + 1 &#125; //修改getter setter var fieldC = "sss" get() &#123; return field + ": bye bye" &#125; set(value) &#123; field = "hello" + value &#125; var filedD = 5 get() = 10 //var 延迟初始化 lateinit var filedE: String //val 延迟初始化 val filedF: String by lazy &#123; println("init x") "sssssss" &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val a = A() println(a.FINAL_STRING) println(a.filedA) println(a.fieldB) a.fieldC = "zhang" println(a.fieldC) println(a.filedD) a.filedE = "filedE" println(a.filedE) println(a.filedF)&#125; 基本运算符运算符重载： 任何类可以定义或者重载父类的基本运算符 通过运算符对应的具名函数来定义 对于参数个数作要求，对参数和返回值类型不作要求 不能像Scala一样定义任意运算符123456789101112131415161718192021222324252627class Complex(val x: Double, val y: Double) &#123; operator fun plus(other: Complex): Complex &#123; return Complex(x + other.x, y + other.y) &#125; operator fun plus(other: Int): Complex &#123; return Complex(x + other, y) &#125; operator fun plus(other: Double): Int &#123; return (x + y + other).toInt() &#125; override fun toString(): String &#123; return "$x + $&#123;y&#125;i" &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c1 = Complex(3.0, 4.0) val c2 = Complex(2.0, 7.5) println(c1 + c2) println(c1 + 5 + 4.0) println(c1)&#125; 表达式中缀表达式：只有一个参数 且用infix修饰的函数12345678910111213class Book &#123; infix fun on(any: Any): Boolean &#123; return any is Desk &#125;&#125;class Desk &#123;&#125;fun main(args: Array&lt;String&gt;) &#123; println(Book() on Desk())&#125; if 表达式： if … else 表达式与完备性12345678910111213141516171819202122232425262728const val NAME_ADMIN = "admin"const val PASSWORD_ADMIN = "admin"const val NAME_USER = "user"const val PASSWORD_USER = "user"const val ADMIN_MODE = 0const val USER_MODE = 1fun main(args: Array&lt;String&gt;) &#123; //表达式 val mode = if (args.isNotEmpty() &amp;&amp; args[0] == "0") ADMIN_MODE//最后的表达式作为该块的值 else USER_MODE println("请输入用户名：") val name = readLine() println("请输入用户密码：") val password = readLine() if (mode == ADMIN_MODE &amp;&amp; name == NAME_ADMIN &amp;&amp; password == PASSWORD_ADMIN) println("管理员登录成功！") else if (name == NAME_USER &amp;&amp; password == PASSWORD_USER) println("用户登录成功！") else println("登录失败")&#125; when 表达式： 加强版switch,支持任意类型 支持纯表达式条件分支（类似if） 表达式与完备性123456789101112when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125;//表达式fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125; 循环语句for 循环 while 循环 do…while 循环 跳过当前循环 continue 终止循环 break 多层循环嵌套的终止结合标签使用12345Outter@for(...)&#123; Inner@while(i &lt; 0)&#123; if(...) break@Outter &#125;&#125; 异常捕获 try { // 一些代码}catch (e: SomeException) { // 处理程序}finally { // 可选的 finally 块} 可以有零到多个 catch 块。finally 块可以省略。 但是 catch 和 finally 块至少应该存在一个。try…catch 也是表达式 类似 if…else / when 具名参数给函数的实参附上形参1234fun sum(x: Int, y: Int) = x + y//具名参数 交换参数顺序也可以执行sum(x = 1, y = 2) 变长参数关键字 vararg123456789fun hello (vararg ints: int, string: String)&#123; ...&#125;hello(1,2,3,4,string = "123456")var array = intArrayOf(1,2,3,4)//*展开Array 仅支持array 仅支持边长参数hello(*array,string = "1,2,3,4") 默认参数1234//默认参数如果不是最后一个参数 则它后面参数需要使用具名参数fun hello (vararg ints: int, string: String = "123456")&#123; ...&#125;]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin笔记之数据类型]]></title>
    <url>%2F2018%2F02%2F27%2FKotlin%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Boolean 类型1234val isTrue: Boolean = truevar isFalse: Boolean = falseval isSure = trueval isCancel = false Number 类型 分类 类型 位宽 浮点型 Double 64 浮点型 Float 32 整型 Long 64 整型 Int 32 整型 Short 16 字节型 Byte 8 12345678910111213141516171819202122232425262728293031val anInt: Int = 8val anotherInt: Int = 0xffval moreInt: Int = 0b0011val minInt: Int = Int.MIN_VALUEval maxInt: Int = Int.MAX_VALUEval minLong :Long = Long.MIN_VALUEval maxLong :Long = Long.MAX_VALUEval aFloat : Float = 1.0Fval another : Float = 1e3Fval minFloat : Float = -Float.MAX_VALUEval maxFloat : Float = Float.MAX_VALUEval aDouble : Double = 3.0val minDouble : Double = -Double.MAX_VALUEval maxDouble : Double = Double.MAX_VALUEval minByte : Byte = Byte.MIN_VALUEval maxByte : Byte = Byte.MAX_VALUEval minShort : Short = Short.MIN_VALUEval maxShort : Short = Short.MAX_VALUE//数字字面值中的下划线（自 1.1 起）//你可以使用下划线使数字常量更易读：val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 Char 类型123val aChar: Char = '中'val anotherChar: Char = 'a'val moreChar: Char = '\u000f' 支持这几个转义序列：\t、 \b、\n、\r、\’、\”、\ 和 \$。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’ 数组数组在 Kotlin 中使用 Array 类来表示，它定义了 get 和 set 函数（按照运算符重载约定这会转变为 []）和 size 属性，以及一些其他有用的成员函数12345678910//创建了Array[1,2,3]arrayOf(1, 2, 3)arrayOf(1, 2, 3).iterator().forEach &#123; println(it) &#125;println("-------")println(arrayOfNulls&lt;Int&gt;(10).size)val asc: Array&lt;Int&gt; = Array(5, &#123; i -&gt; i * 2 &#125;)asc[2] = 10asc.iterator().forEach &#123; println("it: $it") &#125; 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 Array&lt; String &gt; 赋值给 Array&lt; Any &gt; Kotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、 ShortArray、IntArray 等等。这些类和 Array 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法 String 类型12345678910111213141516171819val string: String = "hello world"val fromChars: String = String(charArrayOf('h', 'e', 'l', 'l', 'o'))fun main(args: Array&lt;String&gt;) &#123; println(string) println(fromChars) //相当于java equals 比较内容 println(string == fromChars) //相当于java == 比较对象是否相同 println(string === fromChars) val arg1 = 0 val arg2 = 1 println("" + arg1 + " + " + arg2 + " = " + (arg1 + arg2)) //字符串模板 println("$arg1 + $arg2 = $&#123;arg1 + arg2&#125;")&#125; 原生字符串 使用三个引号（”””）分界符括起来，内部没有转义并且可以包含换行和任何其他字符:val text = “”” for (c in “foo”) print(c)“””你可以通过 trimMargin() 函数去除前导空格：val text = “”” |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) “””.trimMargin()默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。 基本类型转换显式转换12val anInt: Int = 5val aLong: Long = anInt.toLong() 由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：// 假想的代码，实际上并不能编译：val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)print(a == b) // 惊！这将输出“false”鉴于 Long 的 equals() 检测其他部分也是 Long所以同一性还有相等性都会在所有地方悄无声息地失去。因此较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误我们可以显式转换来拓宽数字val i: Int = b.toInt() // OK: 显式拓宽每个数字类型支持如下的转换:toByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char缺乏隐式类型转换并不显著，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：val l = 1L + 3 // Long + Int =&gt; Long 类类型123456789101112131415161718192021222324//open 才能被继承 或重写open class People(val name: String, val age: String) &#123; init &#123; println("this is $&#123;this.javaClass.simpleName&#125;, name is $name, age is $age") &#125; //不能重写 相当于加了final fun sayHello() &#123; println("hello, my name is $name, age is $age") &#125;&#125;class Woman(name: String, age: String) : People(name, age)class Man(name: String, age: String) : People(name, age)fun main(args: Array&lt;String&gt;) &#123; val zhang: Man = Man("zhang", "20") zhang.sayHello() val li: Woman = Woman("li", "18") li.sayHello() //相当于Java instanceOf println("li is people: $&#123;li is People&#125;")&#125; 空安全许多编程语言（包括 Java）中最常见的陷阱之一，就是访问空引用的成员会导致空引用异常。在 Java 中，这等同于 NullPointerException 或简称 NPE。 Kotlin 的类型系统旨在从我们的代码中消除 NullPointerException。 非空引用(不能容纳空) 12var s: String = "hello"s = null //报错 s不能为空 可空引用(可容纳空) 12var s: String? = "hello"s = null //ok s可为空 NULL检查： 在条件中检查null，只适用于对象不可变的情况，如下：12345678910//此处s属性 不可变 var为可变val s: String? = "hello"val l = if (s != null) s.length else -1if (s != null &amp;&amp; s.length &gt; 0) &#123; print("String of length $&#123;s.length&#125;")&#125; else &#123; print("Empty string")&#125; val 局部变量——总是可以，局部委托属性除外； val 属性——如果属性是 private 或 internal，或者该检查在声明属性的同一模块中执行。智能转换不适用于 open 的属性或者具有自定义 getter 的属性； var 局部变量——如果变量在检查和使用之间没有修改、没有在会修改它的 lambda 中捕获、并且不是局部委托属性； var 属性——决不可能（因为该变量可以随时被其他代码修改）。 安全调用操作符（?.） 12//s 非空，就返回 s.length，否则返回 null，这个表达式的类型是 Int?s?.length 非空断言运算符（!!） 123//非空断言运算符（!!）将任何值转换为非空类型，若该值为空则抛出异常。//使用这个运算符在你确定对象不为空的时候 否侧将会得到NPEs!!.length Elvis 操作符（?:）：当我们有一个可空的引用 r 时，我们可以说“如果 r 非空，我使用它；否则使用某个非空的值 x”：1val l: Int = if (b != null) b.length else -1 除了完整的 if-表达式，这还可以通过 Elvis 操作符表达，写作 ?:：1val l = b?.length ?: -1 如果 ?: 左侧表达式非空，elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。 安全的类型转换：如果对象不是目标类型，那么常规类型转换可能会导致 ClassCastException。 另一个选择是使用安全的类型转换，如果尝试转换不成功则返回 null：1val aInt: Int? = a as? Int 可空类型的集合：如果你有一个可空类型元素的集合，并且想要过滤非空元素，你可以使用 filterNotNull 来实现：12val nullableList: List&lt;Int?&gt; = listOf(1, 2, null, 4)val intList: List&lt;Int&gt; = nullableList.filterNotNull()]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 打包配置 常用技巧]]></title>
    <url>%2F2018%2F02%2F12%2FGradle-%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前面写了一篇文章关于使用Gradle 多渠道打包 动态修改应用标题 / 应用图标 / 版本名 / 版本号，发现我们经常会在Gradle里面做一些常用的处理。所以有了这篇文章来作为记录使用，方便以后查阅。 一、 构建类型1234567891011121314151617181920212223242526272829303132333435363738android &#123; ...... buildTypes &#123; release &#123; //混淆开关 minifyEnabled true //是否zip对齐 zipAlignEnabled true //是否打开debuggable开关 debuggable false //是否打开jniDebuggable开关 jniDebuggable false //是否移除无用资源 shrinkResources true //签名配置 signingConfig signingConfigs.ks //applicationId后缀 applicationIdSuffix ".release" proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; debug &#123; minifyEnabled false applicationIdSuffix ".debug" proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; jnidebug &#123; // 拷贝指定的构建类型属性 initWith release applicationIdSuffix ".jnidebug" jniDebuggable true &#125; &#125; ......&#125; 二、 多渠道/多环境不同配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556android &#123; ...... // 维度：用于组建多个Flavor，这里指定了2个维度 isPay 、 isFree flavorDimensions "isPay", "isFree" // 多Flavor（渠道）配置 productFlavors &#123; main1 &#123; dimension "isPay" //当前渠道包名 applicationId "com.****.****" //当前渠道版本号 versionCode 1 //当前渠道版本名 versionName "1.0" //当前渠道版本名后缀 versionNameSuffix "-main1" //applicationId后缀 这里的指定的后缀会在构建类型的前面（com.****.****".main1.release） applicationIdSuffix ".main1" //当前渠道资源常量 不能与资源文件已有名字相同 否则会报错 //R.string.app_name resValue "string", "app_name", "app_name" // 当前渠道动态修改常量 //BuildConfig.API_HOST buildConfigField "String", "API_HOST", '"www.main1.com"' //当前渠道 AndroidManifest.xml 占位变量 manifestPlaceholders = [app_name_desktop: "app_name_desktop"] &#125; main2 &#123; dimension "isPay" applicationId "com.****.****" versionCode 2 versionName "2.0" versionNameSuffix "-main2" applicationIdSuffix ".main2" resValue "string", "app_name", "app_name" buildConfigField "String", "API_HOST", '"www.main2.com"' manifestPlaceholders = [app_name_desktop: "app_name_desktop"] &#125; pay &#123; dimension 'isFree' &#125; free &#123; dimension 'isFree' &#125; &#125; ......&#125; productFlavors 支持与 defaultConfig 相同的属性，这是因为 defaultConfig 实际上属于 ProductFlavor 类。这里构建了2个维度、2个Flavor，实际打包时会根据 flavorDimensions 、 productFlavors、buildTypes 生成不同的包，假设这里打relase包，则是生成main1PayRelease、main1FreeRelease。这里需要说明的是 productFlavors 构建出的 Flavor 设置会覆盖 defaultConfig 里面的设置。 对于项目而言，有时候需要配置某些敏感信息。比如API_HOST、appKey等,我们不希望别人看到。而这些信息需要被很多类共同使用，所以必须有一个全局的配置，那么我们可以将这些信息设置在gradle.properties中。 1234//当前渠道资源常量 不能与资源文件已有名字相同 否则会报错resValue "string", "app_key", app_key// 当前渠道动态修改常量buildConfigField "String", "API_HOST", API_HOST gradle.properties文件中进行变量初始化123...... app_key = "1234567890" API_HOST = "http://120.79.189.85:3000" 三、 过滤变体12345678910111213141516android &#123; ...... variantFilter &#123; variant -&gt; def names = variant.flavors*.name // To check for a certain build type, use variant.buildType.name == "&lt;buildType&gt;" if (names.contains("main1 ") &amp;&amp; names.contains("free")) &#123; // Gradle ignores any variants that satisfy the conditions above. setIgnore(true) &#125; &#125; ......&#125; 四、 创建源集与更改默认源集配置 创建原集默认情况下，Android Studio 会创建 main/ 源集和目录，用于存储您要在所有构建变体之间共享的一切资源。然而，您可以创建新的源集来控制 Gradle 要为特定的构建类型、productFlavors （以及使用维度时的 productFlavors 组合）和构建变体编译和打包的确切文件。创建源集方式在Gradle 多渠道打包 动态修改应用标题 / 应用图标 / 版本名 / 版本号第二点已经说明了。注意：Gradle 要求您按照与 main/ 源集类似的特定方式组织源集文件和目录。 更改默认源集配置如果您的源未组织到 Gradle 期望的默认源集文件结构中（如上面的创建源集部分中所述），您可以使用 sourceSets {} 代码块更改 Gradle 希望为源集的每个组件收集文件的位置。您不需要重新定位文件；只需要为 Gradle 提供相对于模块级 build.gradle 文件的路径，Gradle 应当可以在此路径下为每个源集组件找到文件。 12345678910111213141516171819 android &#123; ...... sourceSets &#123; main1 &#123; //main1 Flavor 使用main2 Flavor 的res 这里只是举例 据实际情况编写 res.srcDir('src/main2/res') &#125; main2 &#123; //main2 Flavor 使用main1 Flavor 的res res.srcDir('src/main1/res') &#125; &#125; ......&#125; 五、批量打包重命名有时候发给测试或者产品的包需要根据一些指定规则来命名，每次都手动修改显得很麻烦，打一个包也还好，但是一次打release、debug都要改就更麻烦了。12345678910111213141516171819202122232425262728 android &#123; ...... applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; def flavors = variant.productFlavors[0] def fileName if(variant.buildType.name == 'release')&#123; //将release版本的包名重命名 fileName = "$&#123;flavors.applicationId&#125;_V$&#123;flavors.versionName&#125;_$&#123;releaseTime()&#125;.apk" &#125;else&#123; //将debug版本的包名重命名 fileName = "$&#123;flavors.applicationId&#125;_V$&#123;flavors.versionName&#125;_debug_$&#123;releaseTime()&#125;.apk" &#125; output.outputFile = new File(outputFile.parent, fileName) &#125; ......&#125;static def releaseTime() &#123; return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC"))&#125; 六、 移除lint检测的error12345678910111213141516 android &#123; ...... lintOptions &#123; //lint 遇到 error 时继续 构建 abortOnError false //build release 版本 时 开启lint 检测 checkReleaseBuilds false // 防止在发布的时候出现因MissingTranslation导致Build Failed! disable 'MissingTranslation' &#125; ......&#125; 七、签名设置除非您为发布构建显式定义签名配置，否则，Gradle 不会签名发布构建的APK。 要使用 Gradle 构建配置为您的发布构建类型手动配置签署配置： 创建密钥库。密钥库是一个二进制文件，它包含一组私钥。您必须将密钥库存放在安全可靠的地方。 创建私钥。私钥代表将通过应用识别的实体，如某个人或某家公司。 将签署配置添加到模块级 build.gradle 文件中：1234567891011121314151617181920212223 android &#123; ...... defaultConfig &#123;...&#125; signingConfigs &#123; release &#123; storeFile file("myreleasekey.jks") storePassword "password" keyAlias "MyReleaseKey" keyPassword "password" &#125; &#125; buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125; &#125; ......&#125; 注：将发布密钥和密钥库的密码放在构建文件中并不安全。作为替代方案，您可以将此构建文件配置在local.properties。 使用 local.properties 存放私密配置：在项目跟目录下，有个 local.properties 文件，我们可以使用它来存放一些私密的属性，然后在 gradle 中读取，而 local.properties 文件不需要上传。 local.properties 文件里设置如下：12345#对应自己实际的证书路径和名字，这里签名文件是放在app目录下，没有写绝对路径。keystroe_storeFile = myreleasekey.jkskeystroe_storePassword = passwordkeystroe_keyAlias = MyReleaseKeykeystroe_keyPassword = password 在 build.gradle 读取 local.properties 字段信息1234567891011121314151617181920212223//获取local.properties的内容Properties properties = new Properties()properties.load(project.rootProject.file('local.properties').newDataInputStream()) android &#123; ...... //第二种：为了保护签名文件，把它放在local.properties中并在版本库中排除 // ，不把这些信息写入到版本库中（注意，此种方式签名文件中不能有中文） signingConfigs &#123; config &#123; storeFile file(properties.getProperty("keystroe_storeFile")) storePassword properties.getProperty("keystroe_storePassword") keyAlias properties.getProperty("keystroe_keyAlias") keyPassword properties.getProperty("keystroe_keyPassword") &#125; &#125; ......&#125; 这样就可以将自己想要隐藏的一些数据隐藏起来。 八、 dependencies 依赖配置不同 buildTypes 和 productFlavors 依赖不同的jar的配置情况12345678 dependencies &#123; debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5' main1Compile files("libs****.jar") main1Compile files("libs/****.jar") main2Compile files("libs/****.jar") main2Compile files("libs/****.jar")&#125; 感谢阅读！有错之处还望指正……]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 多渠道打包 动态修改应用标题 / 应用图标 / 版本名 / 版本号]]></title>
    <url>%2F2018%2F02%2F10%2FGradle-%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%BA%94%E7%94%A8%E6%A0%87%E9%A2%98-%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87-%E7%89%88%E6%9C%AC%E5%90%8D-%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[最近有个需求需要一次打4个包，且它们具有不同的标题、不同的图标、不同的版本号、版本名。虽然之前项目也需要打release和debug包，但是一次也只打包一个，仅仅更改下API_HOST，且没有更换图标这些需求。恰逢这次，需求方一直要求我打包，一次4个每次都要去改标题、包名、版本号、版本名，好不容易打包完。然后告诉我错了要修改……一万只草泥马奔腾啊！根据之前的了解，Gradle 是可以解决这个问题的。所以就决定配置下 Gradle 实现需求。 一、使用productFlavors构建Flavor12345678910111213141516171819202122232425262728293031323334productFlavors &#123; main1 &#123; applicationId "com.****.****" versionCode 5 versionName "1.0.4" resValue "string", "app_name", "app_name" manifestPlaceholders = [app_name_desktop: "app_name_desktop"] &#125; main2 &#123; applicationId "com.****.****" versionCode 43 versionName "1.3.7" resValue "string", "app_name", "app_name" manifestPlaceholders = [app_name_desktop: "app_name_desktop"] &#125; main3 &#123; applicationId "com.****.****" versionCode 2017053026 versionName "6.8.2" resValue "string", "app_name", "app_name" manifestPlaceholders = [app_name_desktop: "app_name_desktop"] &#125; main4 &#123; applicationId "com.****.****" versionCode 100006 versionName "2.0.6" resValue "string", "app_name", "app_name" manifestPlaceholders = [app_name_desktop: "app_name_desktop"] &#125;&#125; 如上我分别设置了4个包的applicationId、versionCode 、versionName ，且设置了resValue、manifestPlaceholders 。这里主要是需求方要求每个应用里面显示名字和桌面显示名字不一样，所以我增加了app_name_desktop用于桌面显示的应用名，而app_name就作为应用中显示使用。 这样就做到了4个包的的包名、版本号、版本名以及应用名的配置，这里需要说明的是 productFlavors 构建出的 Flavor 设置会覆盖 defaultConfig 里面的设置。 二、为对应Flavor创建文件夹接下来需要根据上面 productFlavors 中的 Flavor 创建文件夹，创建位置如下： 这里创建的 Flavor 文件夹中的子文件夹需要和main目录层级中结构一致，内容根据自己的需求酌情增加或删除。例如我这个项目中只保存了drawable-xhdpi、drawable-xxhdpi、values三个文件夹，里面的内容也是一样的。可以看到drawable-xhdpi、drawable-xxhdpi只有ic_launcher.png，而values中的strings.xml中内容如下图。 我这里注释掉了，是因为我后来把他定义在了 productFlavors 中，所以这里面不需要了。打包时Flavor中的文件会替换掉main中的，比如main1中的ic_launcher.png会替换main中的ic_launcher.png。如果strings.xml中的app_name没有注释掉，它也会替换掉main中的app_name。 这就完成了应用图标和应用里面app_name的替换。 三、manifest修改应用名 这里额外说下： applicantion的label ：安装和卸载应用时显示的名称 。 launcher activity的label：App标题和桌面上App的显示名称。 修改应用图标也可以使用resValue、manifestPlaceholders方式如下： resValue:1234567891011//Flavor添加resValue "drawable", "app_icon", "@drawable/ic_launcher"&lt;application android:name=".app.RedApp" android:allowBackup="true" android:icon="@drawable/app_icon" android:label="$&#123;app_name_desktop&#125;" android:theme="@style/Theme.AppCompat.AppTheme"&gt; .....&lt;/application&gt; manifestPlaceholders:1234567891011//Flavor添加manifestPlaceholders = [app_icon : "@drawable/icon_prod"]&lt;application android:name=".app.RedApp" android:allowBackup="true" android:icon="$&#123;app_name_desktop&#125;" android:label="$&#123;app_name_desktop&#125;" android:theme="@style/Theme.AppCompat.AppTheme"&gt; .....&lt;/application&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 轮播图之BannerPager]]></title>
    <url>%2F2018%2F02%2F06%2FAndroid-%E8%BD%AE%E6%92%AD%E5%9B%BE%E4%B9%8BBannerPager%2F</url>
    <content type="text"><![CDATA[BannerPager简介BannerPager是一个Android Banner库，它支持无限轮播、预显示前后页、指示器位置、颜色、大小修改、点击/选中监听、滚动速度控制、设置自动翻页和时间、手指触碰暂停翻页，离开自动翻页、默认提供缩放/卡片/手风琴/立方体翻页效果 ,支持recyclerview列表嵌套 自动控制轮播 BannerPager效果图 BannerPager使用流程1. 布局使用BannerPager123456&lt;com.joker.pager.BannerPager android:id="@+id/banner_pager0" android:layout_width="match_parent" android:layout_height="180dp" android:layout_marginBottom="20dp" android:layout_marginTop="20dp" /&gt; 2. 代码配置BannerPager12345678910111213141516171819202122232425262728bannerPager0 = findViewById(R.id.banner_pager0);final List&lt;String&gt; data = new ArrayList&lt;&gt;();data.add("http://7xi8d6.com1.z0.glb.clouddn.com/20180109085038_4A7atU_rakukoo_9_1_2018_8_50_25_276.jpeg");data.add("http://7xi8d6.com1.z0.glb.clouddn.com/20180102083655_3t4ytm_Screenshot.jpeg");data.add("http://7xi8d6.com1.z0.glb.clouddn.com/20171228085004_5yEHju_Screenshot.jpeg");//设置PagerOptionsfinal PagerOptions pagerOptions0 = new PagerOptions.Builder(this) .setTurnDuration(2000) .setIndicatorSize(20) .setIndicatorVisibility(View.GONE) .setLoopEnable(false) .setPageTransformer(new ScaleTransformer()) .setIndicatorMarginBottom(40) .build();//设置BannerPagerbannerPager0 .setPagerOptions(pagerOptions0) .setPages(data, new ViewHolderCreator&lt;BannerPagerHolder&gt;() &#123; @Override public BannerPagerHolder createViewHolder() &#123; final View view = LayoutInflater.from(ScaleBannerActivity.this).inflate(R.layout.item_image_banner, null); return new BannerPagerHolder(view); &#125; &#125;); 3. 适合地方开启停止/轮播1234567891011@Overrideprotected void onResume() &#123; super.onResume(); bannerPager0.startTurning();&#125;@Overrideprotected void onStop() &#123; super.onStop(); bannerPager0.stopTurning();&#125; BannerPager 常用API BannerPager startTurning 开始轮播 stopTurning() 停止轮播 setPages(java.util.List data, ViewHolderCreator creator) 设置 page data setPagerOptions(PagerOptions options) 设置 PagerOptions setOnPageChangeListener(OnPageChangeListener listener) 设置 page 改变监听 setOnItemClickListener(OnItemClickListener listener) 设置 Item点击监听 PagerOptions.Builder openDebug(boolean debug) 开启 debug setIndicatorAlign(int align) 设置指示器位置 setIndicatorColor(int unSelected, int selected) 设置指示器 setIndicatorDrawable(int unSelected, int selected) 设置指示器 setIndicatorDistance(int distance) 设置指示器间距 setIndicatorMarginBottom(int marginBottom) 设置指示器距离底部间距 setIndicatorSize(int size) 设置指示器 setIndicatorVisibility(int visibility) 设置Indicator 是否可见 setLoopEnable(boolean loop) 设置可否循环 setPagePadding(int px) 设置每个 page 之间间隔 setPageTransformer(PageTransformer transformer) 设置轮播切换效果 setPrePagerWidth(int px) 左右两侧预显示宽度 setScrollDuration(int duration) 设置ViewPager的滚动速度 setTurnDuration(int duration) 设置切换时间 BannerPager 切换效果 AccordionTransformer 手风琴效果 CubeOutTransformer 立方体效果 DepthCardTransformer 卡片效果 ScaleTransformer 缩放效果]]></content>
      <categories>
        <category>Android</category>
        <category>Banner</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Banner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Android 注解]]></title>
    <url>%2F2018%2F01%2F06%2FJava-Android-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一 注解说明注解(Annotation)，也叫元数据。从 JDK 1.5 开始，java 开始支持注解。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。文档 JSR-269 将它规范化，在 JDK 1.6 写入编译器 javac 中。 二 注解分类【内置注解】1. 作用在代码的注解123@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。@SuppressWarnings - 指示编译器去忽略注解中声明的警告。 2. 作用在其他注解的注解(或者说 元注解)1234@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。@Documented - 标记这些注解是否包含在用户文档中。@Target - 标记这个注解应该是哪种 Java 成员。@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 3. 从 Java 7 开始，额外添加了 3 个注解123@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 【自定义注解】三 注解作用域1. 通过元注解@Retention标识注解生命周期：123源码时注解（RetentionPolicy.SOURCE） //源代码注解 仅在源码有效编译时注解（RetentionPolicy.CLASS） //编译是注解 class文件有效运行时注解（RetentionPolicy.RUNTIME） //运行时注解 运行时有效 可以反射访问 2. 通过元注解@Target 标识注解作用范围：12345678PACKAGE:用于包TYPE:用于类、接口(包括注解类型) 或enum声明FIELD:用于属性CONSTRUCTOR:用于构造器METHOD:用于方法PARAMETER:用于参数LOCAL_VARIABLE:用于局部变量ANNOTATION_TYPE：用于注解类型 四 自定义注解上面主要描述了关于注解的一些说明，接下来通过一个示例尝试自定义一个注解：1.自定义注解格式1public @interface 注解名 &#123; 定义体 &#125; 2.注解参数数据类型 所有基本数据类型（int,float,boolean,byte,double,char,long,short) String类型 Class类型 enum类型 Annotation类型 以及以上所有类型的数组 3.android应用示例123456789101112131415161718192021222324252627282930313233343536373839404142//注解类@Retention(RetentionPolicy.RUNTIME) //运行时注解@Target(ElementType.FIELD) //作用于属性public @interface BindView &#123; @IdRes int value() default -1;&#125;//注解解析类public class Bind &#123; public static void inject(Activity activity) &#123; Class&lt;?&gt; target = activity.getClass(); Field[] fields = target.getDeclaredFields(); try &#123; for (Field field : fields) &#123; if (field.isAnnotationPresent(BindView.class)) &#123; BindView bind = field.getAnnotation(BindView.class); if (bind.value() != -1) &#123; field.setAccessible(true); //field设置 field.set(activity, activity.getWindow().getDecorView().findViewById(bind.value())); &#125; &#125; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125;//测试Activity 布局就一个TextView就不给出了（默认android:text = "cs"）public class BindActivity extends AppCompatActivity &#123; @BindView(R.id.test) TextView test; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_bind); test.setText("测试"); &#125;&#125; 4.示例运行效果]]></content>
      <categories>
        <category>Java</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2018%2F01%2F06%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[匹配中文:[\u4e00-\u9fa5] 英文字母:[a-zA-Z] 数字:[0-9] 匹配空格：[ ]匹配连续空格：[ ]+ 匹配空白字符：\s匹配连续空白字符：\s+ 匹配中文，英文字母和数字及_:^[\u4e00-\u9fa5_a-zA-Z0-9]+$ 同时判断输入长度：[\u4e00-\u9fa5a-zA-Z0-9]{4,10} ^[\w\u4E00-\u9FA5\uF900-\uFA2D]$1、一个正则表达式，只含有汉字、数字、字母、下划线不能以下划线开头和结尾：^(?!_)(?!.?$)[a-zA-Z0-9\u4e00-\u9fa5]+$ 其中：^ 与字符串开始的地方匹配(?!) 不能以开头(?!.*?$) 不能以结尾[a-zA-Z0-9_\u4e00-\u9fa5]+ 至少一个汉字、数字、字母、下划线$ 与字符串结束的地方匹配 放在程序里前面加@，否则需要\进行转义 @”^(?!)(?!.*?$)[a-zA-Z0-9\u4e00-\u9fa5]+$”（或者：@”^(?!)\w*(?&lt;!)$” 或者 @” ^[\u4E00-\u9FA50-9a-zA-Z]+$ “ ) 2、只含有汉字、数字、字母、下划线，下划线位置不限：^[a-zA-Z0-9_\u4e00-\u9fa5]+$ 3、由数字、26个英文字母或者下划线组成的字符串^\w+$ 4、2~4个汉字@”^[\u4E00-\u9FA5]{2,4}$”; 5、^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$ 用：(Abc)+ 来分析： XYZAbcAbcAbcXYZAbcAb XYZAbcAbcAbcXYZAbcAb6、[^\u4E00-\u9FA50-9a-zA-Z_]34555#5’ –&gt;34555#5’ [\u4E00-\u9FA50-9a-zA-Z_] eiieng89 —&gt; eiieng89_’;’eiieng88&amp;*9 –&gt; _’;’eiieng88&amp;*9_’;’eiieng88&amp;9 –&gt; ‘;’eiieng88&amp;9_ public bool RegexName(string str){bool flag=Regex.IsMatch(str,@”^[a-zA-Z0-9_\u4e00-\u9fa5]+$”);return flag;} Regex reg=new Regex(“^[a-zA-Z_0-9]+$”);if(reg.IsMatch(s)){\符合规则}else{\存在非法字符} 最长不得超过7个汉字，或14个字节(数字，字母和下划线)正则表达式^[\u4e00-\u9fa5]{1,7}$|^[\dA-Za-z_]{1,14}$ 常用正则表达式大全！（例如：匹配中文、匹配html） 匹配中文字符的正则表达式： [u4e00-u9fa5]评注：匹配中文还真是个头疼的事，有了这个表达式就好办了匹配双字节字符(包括汉字在内)：[^x00-xff]评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）匹配空白行的正则表达式：nsr评注：可以用来删除空白行匹配HTML标记的正则表达式：&lt;(S?)[^&gt;]&gt;.?|&lt;.? /&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力匹配首尾空白字符的正则表达式：^s|s$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式匹配Email地址的正则表达式：w+([-+.]w+)@w+([-.]w+).w+([-.]w+)评注：表单验证时很实用匹配网址URL的正则表达式：[a-zA-z]+://[^s]评注：网上流传的版本功能很有限，上面这个基本可以满足需求匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$评注：表单验证时很实用匹配国内电话号码：d{3}-d{8}|d{4}-d{7}评注：匹配形式如 0511-4405222 或 021-87888822匹配腾讯QQ号：[1-9][0-9]{4,}评注：腾讯QQ号从10000开始匹配中国邮政编码：[1-9]d{5}(?!d)评注：中国邮政编码为6位数字匹配身份证：d{15}|d{18}评注：中国的身份证为15位或18位匹配ip地址：d+.d+.d+.d+评注：提取ip地址时有用匹配特定数字：^[1-9]d$ //匹配正整数^-[1-9]d$ //匹配负整数^-?[1-9]d$ //匹配整数^[1-9]d|0$ //匹配非负整数（正整数 + 0）^-[1-9]d|0$ //匹配非正整数（负整数 + 0）^[1-9]d.d|0.d[1-9]d$ //匹配正浮点数^-([1-9]d.d|0.d[1-9]d)$ //匹配负浮点数^-?([1-9]d.d|0.d[1-9]d|0?.0+|0)$ //匹配浮点数^[1-9]d.d|0.d[1-9]d|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0）^(-([1-9]d.d|0.d[1-9]d))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正匹配特定字符串：^[A-Za-z]+$ //匹配由26个英文字母组成的字符串^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串^[a-z]+$ //匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下:只能输入数字：“^[0-9]$”只能输入n位的数字：“^d{n}$”只能输入至少n位数字：“^d{n,}$”只能输入m-n位的数字：“^d{m,n}$”只能输入零和非零开头的数字：“^(0|[1-9][0-9])$”只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$”只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$”只能输入非零的正整数：“^+?[1-9][0-9]$”只能输入非零的负整数：“^-[1-9][0-9]$”只能输入长度为3的字符：“^.{3}$”只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$”只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$”只能输入由26个小写英文字母组成的字符串：“^[a-z]+$”只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$”只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$”（1）过滤出字母的正则表达式 [^(A-Za-z)] （2）过滤出数字的正则表达式 [^(0-9)] （3）过滤出中文的正则表达式 [^(\u4e00-\u9fa5)] （4）过滤出字母、数字和中文的正则表达式 [^(a-zA-Z0-9\u4e00-\u9fa5)] 验证用户密码:“^[a-zA-Z]w{6,16}$”正确格式为：以字母开头，长度在6-16之间， ^[A-Za-z\d]{6,16}$ 正确格式为：可以是数字和字母格式 也可以只是数字 和 字母 不能有特殊字符 ^[A-Za-z\d-.]{6,16}$ 正确格式为：包含-. 其他同上 ^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,16}$ 正确格式为：必须是字母和数字一起 ^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z-.]{6,16}$ 正确格式为：包含-. 其他同上只能包含字符、数字和下划线。验证是否含有^%&amp;’,;=?$”等字符：“[^%&amp;’,;=?$x22]+”只能输入汉字：“^[u4e00-u9fa5],{0,}$”验证Email地址：“^w+[-+.]w+)@w+([-.]w+).w+([-.]w+)$”验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=])?$” 验证手机号：”^1(3|4|5|7|8)\d{9}$” 使用过 验证手机和座机号：”((\d{3,4})|\d{3,4}-|\s)?\d{7,14}” 使用过正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。验证身份证号（15位或18位数字）：“^d{15}|d{}18$”验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12”验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为：“01”“09”和“1”“31”。匹配中文字符的正则表达式： [u4e00-u9fa5]匹配双字节字符(包括汉字在内)：[^x00-xff]匹配空行的正则表达式：n[s| ]r匹配HTML标记的正则表达式：/&lt;(.)&gt;.|&lt;(.) /&gt;/匹配首尾空格的正则表达式：(^s)|(s$)匹配Email地址的正则表达式：w+([-+.]w+)@w+([-.]w+).w+([-.]w+)匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=])?(1)应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function(){return this.replace([^x00-xff]/g,”aa”).length;}(2)应用：JavaScript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现String.prototype.trim = function(){return this.replace(/(^s)|(s$)/g, “”);}(3)应用：利用正则表达式分解和转换IP地址function IP2V(ip) //IP地址转换成对应数值{re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式if(re.test(ip)){return RegExp.$1Math.pow(255,3))+RegExp.$2Math.pow(255,2))+RegExp.$3255+RegExp.$41}else{throw new Error(“Not a valid IP address!”)}}(4)应用：从URL地址中提取文件名的javascript程序s=”http://www.9499.net/page1.htm“;s=s.replace(/(./){0,}([^.]+)./ig,”$2”) ;//Page1.htm(5)应用：利用正则表达式限制网页表单里的文本框输入内容用正则表达式限制只能输入中文：onkeyup=”value=value.replace(/[^u4E00-u9FA5]/g,’) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^u4E00-u9FA5]/g,’))”用正则表达式限制只能输入全角字符： onkeyup=”value=value.replace(/[^uFF00-uFFFF]/g,’) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^uFF00-uFFFF]/g,’))”用正则表达式限制只能输入数字：onkeyup=”value=value.replace(/[^d]/g,’) “onbeforepaste= “clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^d]/g,’))”用正则表达式限制只能输入数字和英文：onkeyup=”value=value.replace(/[W]/g,’) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^d]/g,’]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PorterDuffXferMode实战之WaveProgressBar 圆形水波纹进度]]></title>
    <url>%2F2018%2F01%2F05%2FPorterDuffXferMode%E5%AE%9E%E6%88%98%E4%B9%8BWaveProgressBar%20%E5%9C%86%E5%BD%A2%E6%B0%B4%E6%B3%A2%E7%BA%B9%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一 写在前面的话前几天写了一篇Android 绘图之PorterDuffXferMode实例讲解与源码解析，没看过的可以先进去看看。今天我们就来使用PorterDuffXferMode的DST_IN模式，本来想写个圆形头像来看看效果就行了，但是恰巧群里有朋友问到水波纹的进度效果。于是乎去看了下实现方式正好也可以用到PorterDuffXferMode，立马决定还是做个个效果更炫。先看看下面效果图，就这么一张动图，懒癌犯了懒得做中间效果动图。 二 效果分析看了上面效果图，闲来分析下怎么做出这个效果。 静态波浪效果（通过Canvas的drawPath方法画二阶贝塞尔曲线实现） 动态波浪效果（改变波浪高度和X方向绘制位置后定时invalidate） 圆形效果（通过PorterDuffXferMode的DST_IN和动态波浪效果组合） 进度文字（最终效果上绘制出文字） 三 波浪效果 静态波浪效果实现首先我们通过Canvas的drawPath方法画二阶贝塞尔曲线的方法，来绘制静态波浪效果。我们先看效果，然后看代码。代码一般都注视得比较详细。避免单独再解释代码。来上静态波浪效果图： 先上一段xml，然后是代码。原则上不改xml，就不再上了： 123456&lt;com.joker.widget.test.WaveProgressBar android:id="@+id/wave" android:layout_width="match_parent" android:layout_height="200dp" android:layout_gravity="center_horizontal" android:padding="10dp"/&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//静态波浪效果1public class WaveProgressBar extends View &#123; private Paint mWavePaint = new Paint(); //水波画笔 private Path mPath = new Path(); //路径 private int mWidth; //控件宽 private int mHeight; //控件高 private int mWaveWidth = 200; //水波宽 private int mWaveHeight = 100; //水波高 int currentY = 200; //当前Y值 public WaveProgressBar(Context context) &#123; this(context, null); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mWavePaint.setAntiAlias(true); mWavePaint.setColor(Color.GREEN); &#125; //获取控件的宽和高 @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (w &gt; 0) &#123; mWidth = w; &#125; if (h &gt; 0) &#123; mHeight = h; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mWidth &lt;= 0 || mHeight &lt;= 0) &#123; return; &#125; //绘制一个灰色背景 方便看效果 canvas.drawColor(Color.GRAY); mPath.reset(); //路径起点 mPath.moveTo(0, 200); //i+2: 一上一下2个半波为一组 count+2: 保证波浪占满控件 for (int i = 0, count = mWidth / mWaveWidth + 2; i &lt; count; i += 2) &#123; //上半波 mPath.quadTo(mWaveWidth * (i + 0.5f), currentY - mWaveHeight, mWaveWidth * (i + 1), currentY); //下半波 mPath.quadTo(mWaveWidth * (i + 1.5f), currentY + mWaveHeight, mWaveWidth * (i + 2), currentY); &#125; //绘制路径 canvas.drawPath(mPath, mWavePaint); &#125;&#125; 接下来我们让波浪封闭起来，并且让它水位升高，有总水杯里的水的感觉。还是和前面一样，看图看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//封闭起来的静态波浪效果public class WaveProgressBar extends View &#123; private Paint mWavePaint = new Paint(); private Path mPath = new Path(); private int mWidth; private int mHeight; private int mWaveWidth = 200; //水波宽 private int mWaveHeight = 100; //水波高 int currentY = 200; //当前Y值 public WaveProgressBar(Context context) &#123; this(context, null); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mWavePaint.setAntiAlias(true); mWavePaint.setColor(Color.GREEN); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (w &gt; 0) &#123; mWidth = w; &#125; if (h &gt; 0) &#123; mHeight = h; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mWidth &lt;= 0 || mHeight &lt;= 0) &#123; return; &#125; canvas.drawColor(Color.GRAY); mPath.reset(); //路径起点 mPath.moveTo(0, 200); //i+2: 一上一下2个半波为一组 count+2: 保证波浪占满控件 for (int i = 0, count = mWidth / mWaveWidth + 2; i &lt; count; i += 2) &#123; //上半波 mPath.quadTo(mWaveWidth * (i + 0.5f), currentY - mWaveHeight, mWaveWidth * (i + 1), currentY); //下半波 mPath.quadTo(mWaveWidth * (i + 1.5f), currentY + mWaveHeight, mWaveWidth * (i + 2), currentY); &#125; //一下两句代码就完成了水波的封闭效果 mPath.lineTo(mWidth, mHeight); mPath.lineTo(0, mHeight); mPath.close(); canvas.drawPath(mPath, mWavePaint); &#125;&#125; 还是不得不啰嗦一下，我们这里添加了2行代码实现了水波的封闭：12mPath.lineTo(mWidth, mHeight);mPath.lineTo(0, mHeight); 接下来就是水位的上升了，但是这个地方就上代码就有点故意拉长篇幅的嫌疑了。其实很简单我们只需要改变currentY的值，就可以实现水位的上升了。这里关于Canvas路径绘制，或者是坐标系搞不明白的可以看我的：Android 绘图之Canvas相关API使用一文，在里面有比较详细的说明。 动态波浪效果实现上面我们已经实现了静态的波浪效果了，代码还是比较简单的，接下来我们让波浪动次打次动次打次动起来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 //动态波浪效果 public class WaveProgressBar extends View &#123; private Paint mWavePaint = new Paint(); private Path mPath = new Path(); private int mWidth; private int mHeight; private int mWaveWidth = 200; //水波宽 private int mWaveHeight = 100; //水波高 int currentY = 200; //当前Y值 private double mRate = 0.1; //流速 private int distance; //距离 private Handler mHandler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; distance += mWaveWidth * mRate; //计算流动总距离 distance = distance % (mWaveWidth &lt;&lt; 1); //根据总距离算出当前移动距离 invalidate(); //刷新重绘 mHandler.sendEmptyMessageDelayed(0, 20); //20ms发送一个消息 return false; &#125; &#125;); public WaveProgressBar(Context context) &#123; this(context, null); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mWavePaint.setAntiAlias(true); mWavePaint.setColor(Color.GREEN); //20ms发送一个消息 mHandler.sendEmptyMessageDelayed(0, 20); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (w &gt; 0) &#123; mWidth = w; &#125; if (h &gt; 0) &#123; mHeight = h; &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mWidth &lt;= 0 || mHeight &lt;= 0) &#123; return; &#125; canvas.drawColor(Color.GRAY); mPath.reset(); //路径起点 mPath.moveTo(0, 200); //i+2: 一上一下2个半波为一组 count+2: 保证波浪占满控件 for (int i = 0, count = mWidth / mWaveWidth + 2; i &lt; count; i += 2) &#123; //上半波 减去distance 造成左移效果 mPath.quadTo(mWaveWidth * (i + 0.5f) - distance, currentY - mWaveHeight, mWaveWidth * (i + 1) - distance, currentY); //下半波 mPath.quadTo(mWaveWidth * (i + 1.5f) - distance, currentY + mWaveHeight, mWaveWidth * (i + 2) - distance, currentY); &#125; mPath.lineTo(mWidth, mHeight); mPath.lineTo(0, mHeight); mPath.close(); canvas.drawPath(mPath, mWavePaint); &#125;&#125; 看效果图的水流还是很急的，减小速率就可以让它流慢点，我们先不关心这个，说说实现思路。主要是利用Handler定时发送消息通知重绘的方式，每20ms计算出移动距离并刷新重绘一次。在绘制的时候减去移动距离就有了左移效果，其他的说明在代码中注释很详尽了。 四 圆形效果水波效果我们就做到这里，接下来就是利用PorterDuffXferMode的DST_IN模式来实现圆形效果，我们先绘制的水波后绘制的圆，所以我们需要使用DST_IN。其实绘制圆形头像效果原理也是一样的，至于用什么模式就跟你绘制的先后顺序，还有需求有关。不了解PorterDuffXferMode可以去看看我之前的文章，本文后我会给出相关链接地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 //圆形波浪效果 public class WaveProgressBar extends View &#123; private Paint mWavePaint = new Paint(); private Path mPath = new Path(); private int mWidth; private int mHeight; private int mWaveWidth = 200; //水波宽 private int mWaveHeight = 100; //水波高 int currentY = 200; //当前Y值 private double mRate = 0.01; //流速 private int distance; //距离 private PorterDuffXfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.DST_IN); private Bitmap mCircleBitmap; //圆形bitmap private RectF mBorderRectF; //边框矩形 private int mBorderRadius; //边框半径 private Handler mHandler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; distance += mWaveWidth * mRate; //计算流动总距离 distance = distance % (mWaveWidth &lt;&lt; 1); invalidate(); mHandler.sendEmptyMessageDelayed(0, 20); return false; &#125; &#125;); public WaveProgressBar(Context context) &#123; this(context, null); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mWavePaint.setAntiAlias(true); mWavePaint.setColor(Color.GREEN); mHandler.sendEmptyMessageDelayed(0, 20); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (w &gt; 0) &#123; mWidth = w; &#125; if (h &gt; 0) &#123; mHeight = h; &#125; mWidth = mHeight = Math.min(mWidth, mHeight); //创建边框矩形 mBorderRectF = new RectF(0, 0, mWidth, mHeight); //边框半径 mBorderRadius = (mWidth &gt;&gt; 1); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mWidth &lt;= 0 || mHeight &lt;= 0) &#123; return; &#125; canvas.drawBitmap(createWaveBitmap(), 0, 0, mWavePaint); &#125; //创建水波bitmap private Bitmap createWaveBitmap() &#123; Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawColor(Color.GRAY); mPath.reset(); //路径起点 mPath.moveTo(0, 200); //i+2: 一上一下2个半波为一组 count+2: 保证波浪占满控件 for (int i = 0, count = mWidth / mWaveWidth + 2; i &lt; count; i += 2) &#123; //上半波 减去distance 造成左移效果 mPath.quadTo(mWaveWidth * (i + 0.5f) - distance, currentY - mWaveHeight, mWaveWidth * (i + 1) - distance, currentY); //下半波 mPath.quadTo(mWaveWidth * (i + 1.5f) - distance, currentY + mWaveHeight, mWaveWidth * (i + 2) - distance, currentY); &#125; mPath.lineTo(mWidth, mHeight); mPath.lineTo(0, mHeight); mPath.close(); canvas.drawPath(mPath, mWavePaint); if (mCircleBitmap == null) &#123; //创建圆形的bitmap mCircleBitmap = createShapeBitmap(); &#125; //设置mXfermode模式 mWavePaint.setXfermode(mXfermode); canvas.drawBitmap(mCircleBitmap, 0, 0, mWavePaint); mWavePaint.setXfermode(null); return bitmap; &#125; //创建形状的bitmap private Bitmap createShapeBitmap() &#123; Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawCircle(mBorderRectF.centerX(), mBorderRectF.centerY(), mBorderRadius, mWavePaint); return bitmap; &#125;&#125; 这里把onDraw里面的代码抽取出来了，把onDraw的背景绘制放在了createWaveBitmap中便于观看效果，利用PorterDuffXferMode的DST_IN模式来实现圆形效果。 五 绘制文字我们已经完成了圆形的水波纹效果，接下来就是将文字绘制在圆形的水波里面。绘制文字就比较简单了，调用Canvas的drawText方法在圆形水波纹上将文字绘制出来就O啦。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class WaveProgressBar extends View &#123; private Paint mWavePaint = new Paint(); private Paint mTextPaint = new Paint(); private Path mPath = new Path(); private int mWidth; private int mHeight; private int mWaveWidth = 200; //水波宽 private int mWaveHeight = 100; //水波高 int currentY = 200; //当前Y值 private double mRate = 0.1; //流速 private int distance; //距离 private PorterDuffXfermode mXfermode = new PorterDuffXfermode(PorterDuff.Mode.DST_IN); private Bitmap mCircleBitmap; //圆形bitmap private RectF mBorderRectF; //边框矩形 private int mBorderRadius; //边框半径 private Handler mHandler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; distance += mWaveWidth * mRate; //计算流动总距离 distance = distance % (mWaveWidth &lt;&lt; 1); invalidate(); mHandler.sendEmptyMessageDelayed(0, 20); return false; &#125; &#125;); public WaveProgressBar(Context context) &#123; this(context, null); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public WaveProgressBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mWavePaint.setAntiAlias(true); mWavePaint.setColor(Color.GREEN); mTextPaint.setAntiAlias(true); mTextPaint.setColor(Color.WHITE); mTextPaint.setTextSize(32); mHandler.sendEmptyMessageDelayed(0, 20); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (w &gt; 0) &#123; mWidth = w; &#125; if (h &gt; 0) &#123; mHeight = h; &#125; mWidth = mHeight = Math.min(mWidth, mHeight); //创建边框矩形 mBorderRectF = new RectF(0, 0, mWidth, mHeight); //边框半径 mBorderRadius = (mWidth &gt;&gt; 1); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mWidth &lt;= 0 || mHeight &lt;= 0) &#123; return; &#125; canvas.drawBitmap(createWaveBitmap(), 0, 0, mWavePaint); canvas.drawText("80%", mBorderRectF.centerX(), mBorderRectF.centerY(), mTextPaint); &#125; //创建水波bitmap private Bitmap createWaveBitmap() &#123; Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawColor(Color.GRAY); mPath.reset(); //路径起点 mPath.moveTo(0, 200); //i+2: 一上一下2个半波为一组 count+2: 保证波浪占满控件 for (int i = 0, count = mWidth / mWaveWidth + 2; i &lt; count; i += 2) &#123; //上半波 减去distance 造成左移效果 mPath.quadTo(mWaveWidth * (i + 0.5f) - distance, currentY - mWaveHeight, mWaveWidth * (i + 1) - distance, currentY); //下半波 mPath.quadTo(mWaveWidth * (i + 1.5f) - distance, currentY + mWaveHeight, mWaveWidth * (i + 2) - distance, currentY); &#125; mPath.lineTo(mWidth, mHeight); mPath.lineTo(0, mHeight); mPath.close(); canvas.drawPath(mPath, mWavePaint); if (mCircleBitmap == null) &#123; //创建圆形的bitmap mCircleBitmap = createShapeBitmap(); &#125; //设置mXfermode模式 mWavePaint.setXfermode(mXfermode); canvas.drawBitmap(mCircleBitmap, 0, 0, mWavePaint); mWavePaint.setXfermode(null); return bitmap; &#125; //创建形状的bitmap private Bitmap createShapeBitmap() &#123; Bitmap bitmap = Bitmap.createBitmap(mWidth, mHeight, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawCircle(mBorderRectF.centerX(), mBorderRectF.centerY(), mBorderRadius, mWavePaint); return bitmap; &#125;&#125; 这一步没什么可说的，新创建了mTextPaint 画笔，设置了字体颜色大小等属性，最后在原本画好的效果上再绘制上文字就成了。可我们文章开头的效果图上，文字是随着水位而上升的，其实这个很简单，改变文本绘制的Y轴位置就能达到上升效果，我们的水波纹效果到这里就完成了它的雏形。 上面的演示代码还是比较杂乱，创建Bitmap都还是在onDraw中，没有考虑控件的测量，也不支持自定义属性等。大家可以根据上面的步骤，自己整理实现定义成自己想要的效果。 最后我将源码整理了下，优化后的源码后续会补上地址，就不在文中给出了。 附：Android 绘图之Canvas相关API使用Android 绘图之PorterDuffXferMode实例讲解与源码解析]]></content>
      <categories>
        <category>Android</category>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 绘图之PorterDuffXferMode实例讲解与源码解析]]></title>
    <url>%2F2018%2F01%2F05%2FAndroid-%E7%BB%98%E5%9B%BE%E4%B9%8BPorterDuffXferMode%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一 PorterDuffXferMode简介PorterDuffXferMode使用PorterDuff.Mode规则将所绘制图形和Canvas上图形混合，最终更新Canvas展示新的图形。PorterDuffXferMode的使用也非常简单，在需要使用的时候paint.setXfermode(PorterDuff.Mode mode)设置混合模式，不需要使用了将其设置为null即可。PorterDuff.Mode共分为16种模式：CLEAR、SRC、DST、SRC_OVER、DST_OVER、SRC_IN、DST_IN、SRC_OUT、DST_OUT、SRC_ATOP、DST_ATOP、XOR、DARKEN、LIGHTEN、MULTIPLY、SCREEN。官方也给出了各自的效果图，也就是网上搜索PorterDuffXferMode出镜率最高的一张图： 二 开胃实例在网上搜了很多文章，帮助不是很大，还是需要感谢下他们，从中学习到了些套路。看完官方的效果图，接下来通过几个实际的示例撸一撸。1.示例一首先自定义一个测试类XfermodeTest，在onDraw中调用实际的绘制方法。接下来的示例，直接给出实际绘制方法，就不再给出整个类。我们不设置PorterDuffXferMode，看看Canvas的绘制效果：12345678910111213141516171819202122232425262728293031public class XfermodeTest extends View &#123; private Paint mPaint = new Paint(); public XfermodeTest(Context context) &#123; this(context, null); &#125; public XfermodeTest(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public XfermodeTest(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onDraw(Canvas canvas) &#123; testNoXfermode(canvas); &#125; private void testNoXfermode(Canvas canvas) &#123; //绘制背景 canvas.drawColor(Color.GRAY); //绘制蓝色矩形 mPaint.setColor(Color.BLUE); canvas.drawRect(200, 200, 600, 600, mPaint); //绘制黄色圆形 mPaint.setColor(Color.YELLOW); canvas.drawCircle(200, 200, 200, mPaint); &#125;&#125; 我们先讲讲Canvas的绘制原理，我们将Canvas当作我们普通的A4纸就行了。首先我们在纸上绘制了灰色的背景，然后我们将矩形所在位置绘制成了蓝色，圆形区域绘制成了黄色，是不是很好理解。 2.示例二我们设置PorterDuffXferMode为SRC_IN试试效果，看看Canvas的绘制效果：123456789101112131415private void testXfermodeSRC_IN(Canvas canvas) &#123; canvas.drawColor(Color.GRAY); mPaint.setColor(Color.BLUE); canvas.drawRect(200, 200, 600, 600, mPaint); //设置为SCR_IN模式 mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR)); mPaint.setColor(Color.YELLOW); canvas.drawCircle(200, 200, 200, mPaint); //清空所设置模式 mPaint.setXfermode(null);&#125; 纳尼！居然不一致，是不是我拿之前的效果来忽悠，换个CLEAR效果试试。圆形变成了一块黑色，您可以亲自动手试一试，也可以换个其他效果看一看效果（这里我就不给出其他模式的效果了）。 这里我们又讲讲设置Xfermode后Canvas的绘制原理，其实还是同示例一所讲原理差不多，只是画笔在绘制的时候会判断有没有设置Xfermode，设置了Xfermode会把绘制的地方按照一定的规则进行混合，然后在绘制出来最终效果。 接下来我们来看看官方实例是怎么做的，为什么能绘制出这样的效果： 三 官方源码解析文章开头看了官方效果图，但是我们实践出来效果却……，接下来我们看看源码（解析的注释都放在源码里了）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class Xfermodes extends GraphicsActivity &#123; // create a bitmap with a circle, used for the "dst" image //创建一个圆形bitmap,用作dst图片 static Bitmap makeDst(int w, int h) &#123; //创建宽为w 高为h的bitmap Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); //绘制圆 注意绘制圆所占面积比所创建出来的bitmap要小 c.drawOval(new RectF(0, 0, w*3/4, h*3/4), p); return bm; &#125; // create a bitmap with a rect, used for the "src" image //创建一个矩形bitmap，用作src图片 static Bitmap makeSrc(int w, int h) &#123; //创建宽为w 高为h的bitmap Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); //绘制矩形 注意绘制矩形所占面积比所创建出来的bitmap要小 c.drawRect(w/3, h/3, w*19/20, h*19/20, p); return bm; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new SampleView(this)); &#125; private static class SampleView extends View &#123; private static final int W = 64; private static final int H = 64; private static final int ROW_MAX = 4; // number of samples per row private Bitmap mSrcB; private Bitmap mDstB; private Shader mBG; // background checker-board pattern private static final Xfermode[] sModes = &#123; new PorterDuffXfermode(PorterDuff.Mode.CLEAR), new PorterDuffXfermode(PorterDuff.Mode.SRC), new PorterDuffXfermode(PorterDuff.Mode.DST), new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER), new PorterDuffXfermode(PorterDuff.Mode.DST_OVER), new PorterDuffXfermode(PorterDuff.Mode.SRC_IN), new PorterDuffXfermode(PorterDuff.Mode.DST_IN), new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT), new PorterDuffXfermode(PorterDuff.Mode.DST_OUT), new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP), new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP), new PorterDuffXfermode(PorterDuff.Mode.XOR), new PorterDuffXfermode(PorterDuff.Mode.DARKEN), new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN), new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY), new PorterDuffXfermode(PorterDuff.Mode.SCREEN) &#125;; private static final String[] sLabels = &#123; "Clear", "Src", "Dst", "SrcOver", "DstOver", "SrcIn", "DstIn", "SrcOut", "DstOut", "SrcATop", "DstATop", "Xor", "Darken", "Lighten", "Multiply", "Screen" &#125;; public SampleView(Context context) &#123; super(context); //创建矩形Src的bitmap mSrcB = makeSrc(W, H); //创建圆形Dst的bitmap mDstB = makeDst(W, H); // make a ckeckerboard pattern //制作棋盘布局 这里使用了BitmapShader的Shader.TileMode.REPEAT模式 Bitmap bm = Bitmap.createBitmap(new int[] &#123; 0xFFFFFFFF, 0xFFCCCCCC, 0xFFCCCCCC, 0xFFFFFFFF &#125;, 2, 2, Bitmap.Config.RGB_565); mBG = new BitmapShader(bm, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT); Matrix m = new Matrix(); //设置缩放 m.setScale(6, 6); mBG.setLocalMatrix(m); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawColor(Color.WHITE); Paint labelP = new Paint(Paint.ANTI_ALIAS_FLAG); labelP.setTextAlign(Paint.Align.CENTER); Paint paint = new Paint(); paint.setFilterBitmap(false); canvas.translate(15, 35); int x = 0; int y = 0; for (int i = 0; i &lt; sModes.length; i++) &#123; // draw the border //绘制边框 paint.setStyle(Paint.Style.STROKE); paint.setShader(null); canvas.drawRect(x - 0.5f, y - 0.5f, x + W + 0.5f, y + H + 0.5f, paint); // draw the checker-board pattern //绘制棋盘图案 paint.setStyle(Paint.Style.FILL); paint.setShader(mBG); //绘制棋盘图案矩形大小 注意这个矩形的宽为W 高为H和Src、Dst的Bitmap大小一致 canvas.drawRect(x, y, x + W, y + H, paint); // draw the src/dst example into our offscreen bitmap //将src / dst示例绘制到我们的屏幕外位图中（其实就是保存了当前Canvas，创建了新的Canvas，这之后的操作在新的Canvas执行） int sc = canvas.saveLayer(x, y, x + W, y + H, null, Canvas.MATRIX_SAVE_FLAG | Canvas.CLIP_SAVE_FLAG | Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG); canvas.translate(x, y); //绘制圆形Dst的bitmap canvas.drawBitmap(mDstB, 0, 0, paint); //设置画笔的Xfermode paint.setXfermode(sModes[i]); //绘制圆形的Src的bitmap canvas.drawBitmap(mSrcB, 0, 0, paint); //清空画笔的Xfermode paint.setXfermode(null); //恢复之前保存的图层，并将新图层和保存图层合并 canvas.restoreToCount(sc); // draw the label //绘制标签 canvas.drawText(sLabels[i], x + W/2, y - labelP.getTextSize()/2, labelP); x += W + 10; // wrap around when we've drawn enough for one row if ((i % ROW_MAX) == ROW_MAX - 1) &#123; x = 0; y += H + 30; &#125; &#125; &#125; &#125; &#125; 在源码中添加了一些中文注释，看起来也好理解多了。首先SampleView 构造器一进来就创建了分别创建了作为Dst、Src和背景的Bitmap，然后在onDraw里面做了绘制操作。我们仔细观察三个矩形的大小发现，Dst和Src背景矩形和作为背景图矩形大小一直，但是绘制圆和矩形实际所占面积要比这个矩形小。（通俗点讲就是，实际绘制的黄色圆和蓝色矩形并不只有我们所看到的那么大，它们实际大小和棋盘背景大小一致，他们分别位于各自bm的左上角和右下角。)还有不明白的可以改变makeSrc里面的Canvas背景颜色看一看。 四 正餐实例我们已经就官方源码做了解析，我们可以看出onDraw里面对Canvas进行了保存和恢复。1.示例三12345678910111213141516171819202122232425private void testXfermodeSRC_IN(Canvas canvas) &#123; canvas.drawColor(Color.GRAY); //保存图层 int id = canvas.saveLayer(0, 0, canvas.getWidth(), canvas.getHeight(), null, Canvas.MATRIX_SAVE_FLAG | Canvas.CLIP_SAVE_FLAG | Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG); mPaint.setColor(Color.BLUE); canvas.drawRect(200, 200, 600, 600, mPaint); //设置为Canvas Xfermode mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); mPaint.setColor(Color.YELLOW); canvas.drawCircle(200, 200, 200, mPaint); //清空所设置模式 mPaint.setXfermode(null); //恢复Canvas canvas.restoreToCount(id); &#125; 似乎跟效果图的SRC_IN还是差一大截呢？源码里面创建了2个和背景大小相等的bitmap，我们修改黄色圆所占矩形大小覆盖着蓝色矩形呢？ 2.示例四12345678910111213141516171819202122232425262728private void testXfermodeSRC_IN(Canvas canvas) &#123; canvas.drawColor(Color.GRAY); //保存图层 int id = canvas.saveLayer(0, 0, canvas.getWidth(), canvas.getHeight(), null, Canvas.MATRIX_SAVE_FLAG | Canvas.CLIP_SAVE_FLAG | Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG); mPaint.setColor(Color.BLUE); canvas.drawRect(200, 200, 600, 600, mPaint); mPaint.setColor(Color.YELLOW); //改变圆形的大小背景矩形大小 Bitmap bitmap = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888); Canvas bmCanvas = new Canvas(bitmap); bmCanvas.drawCircle(200, 200, 200, mPaint); //设置为Canvas Xfermode mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(bitmap, 0, 0, mPaint); //清空所设置模式 mPaint.setXfermode(null); //恢复Canvas canvas.restoreToCount(id);&#125; 看着跟官方效果图差不多了，但是怎么好像跟DST_IN是一致的呢？那我们将Xfermode模式设置为DST_IN呢？只是修改模式，其他部分跟示例四一致：效果跟官方效果图DST_IN一致。真是奇怪了…再仔细看看源码……源码先绘制的圆形，而我们先绘制的矩形，是不是这个原因呢？我们尝试修改绘制顺序：3.示例五12345678910111213141516171819202122232425262728private void testXfermodeSRC_IN(Canvas canvas) &#123; canvas.drawColor(Color.GRAY); //保存图层 int id = canvas.saveLayer(0, 0, canvas.getWidth(), canvas.getHeight(), null, Canvas.MATRIX_SAVE_FLAG | Canvas.CLIP_SAVE_FLAG | Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG); mPaint.setColor(Color.YELLOW); canvas.drawCircle(200, 200, 200, mPaint); mPaint.setColor(Color.BLUE); //改变圆形的大小背景矩形大小 Bitmap bitmap = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888); Canvas bmCanvas = new Canvas(bitmap); bmCanvas.drawRect(200, 200, 600, 600, mPaint); //设置为Canvas Xfermode mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(bitmap, 0, 0, mPaint); //清空所设置模式 mPaint.setXfermode(null); //恢复Canvas canvas.restoreToCount(id);&#125; 五：PorterDuffXfermode总结先写到到这里，我们就可以稍作休息做个总结，以上先介绍了Canvas绘图的基本原理，然后以SRC_IN和DST_IN做对比介绍了PorterDuffXfermode使用，其他的规则大同小异。 总结：a.关于DST和SRC，简单理解先绘制的就是DST，后绘制的就是SRC。 b.需要使用PorterDuffXfermode的地方，开始绘制的时候saveLayer，绘制完成后restoreToCount。 c.需要注意DST和SRC所占矩形的大小，很多人说需要两个大小一致的bitmap，其实是正确的，我们这里只创建了一个bitmap，也无所谓大小一致一说。我这里的示例只需要SRC所占面积大于DST所占面积就OK，所有大家需要根据实际需求来做。 d.不是官方的图才是正确的，其实示例三、示例四、示例五都是正确的。示例三的黄色圆形所占矩形没有覆盖完蓝色矩形，效果图左上角那一点扇形黄色正式SRC_IN的效果。示例四和五则是因为DST是蓝色矩形，而官方的DST是黄色圆形。 e.如果你觉得混合模式没有正确使用，可以让调用setLayerType(View.LAYER_TYPE_SOFTWARE, null)方法切换到软件渲染模式，把我们的View禁用掉GPU硬件加速，这样所有的混合模式都能正常使用 PS:关于文中黄色圆形和蓝色矩形的【所占矩形】或者【所占面积】可能说得不太明白，附上图一张再叙述弥补一下：1234567891011121314private void testXfermode(Canvas canvas) &#123; canvas.drawColor(Color.GRAY); mPaint.setColor(Color.YELLOW); canvas.drawCircle(200, 200, 200, mPaint); mPaint.setColor(Color.BLUE); //改变圆形的大小所占矩形大小 Bitmap bitmap = Bitmap.createBitmap(600, 600, Bitmap.Config.ARGB_8888); Canvas bmCanvas = new Canvas(bitmap); bmCanvas.drawColor(Color.RED); bmCanvas.drawRect(200, 200, 600, 600, mPaint); canvas.drawBitmap(bitmap, 0, 0, mPaint);&#125; 可以看到代码里，我们绘制的顺序是：绘制灰色背景-&gt;绘制黄色圆形-&gt;绘制蓝色矩形，绘制蓝色矩形前，我们改变了蓝色矩形所在canvas的颜色为红色。红色就是蓝色矩形文中所说的所占矩形和所占面积，而我们实际看到的只有蓝色矩形。而红色又是不透明的根据绘制原理，也就覆盖了之前的黄色圆形。因为new Canvas()默认背景是透明的。也就是我在官方文档中所注释的比所创建出来的bitmap要小是一样的： //绘制圆 注意绘制圆所占面积比所创建出来的bitmap要小//绘制矩形 注意绘制矩形所占面积比所创建出来的bitmap要小 关于PorterDuffXfermode的讲解就这么多，如有不对可以指出，共同学习进步。 谢谢阅览！]]></content>
      <categories>
        <category>Android</category>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 绘图之Canvas相关API使用]]></title>
    <url>%2F2018%2F01%2F05%2FAndroid-%E7%BB%98%E5%9B%BE%E4%B9%8BCanvas%E7%9B%B8%E5%85%B3API%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Android 自定义控件或多或少都会用到Canvas，那么我们就需要熟悉它的API。Canvas给我们提供了大量的的DrawXXX方法，通过这些方法我们就可以绘制出我们想要的效果。接下来看看官方是怎么说的： The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap), and a paint (to describe the colors and styles for the drawing). 大致意思就是说：Canvas类持有“draw”调用。 要绘制一些东西，你需要4个基本组件：一个位图来保存像素，一张画布（Canvas）来主持绘图调用（写入位图），一个绘图图元（如Rect，Path，text，Bitmap）和一支画笔（描述绘图的颜色和样式）。 首先介绍下画笔（Paint）的常用API:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void initPaint() &#123; // 设置最基本的属性 // 设置画笔颜色 // 可直接引入Color类，如Color.red等 mPaint.setColor(int color); // 设置画笔模式 mPaint.setStyle(Style style); // Style有3种类型： // 类型1：Paint.Style.FILLANDSTROKE（描边+填充） // 类型2：Paint.Style.FILL（只填充不描边） // 类型3：Paint.Style.STROKE（只描边不填充） //设置画笔的粗细 mPaint.setStrokeWidth(float width); // 如设置画笔宽度为10px mPaint.setStrokeWidth(10f); // 不常设置的属性 // 得到画笔的颜色 mPaint.getColor(); // 设置Shader // 即着色器，定义了图形的着色、外观 mPaint.setShader(Shader shader); //设置画笔的a,r,p,g值 mPaint.setARGB(int a, int r, int g, int b); //设置透明度 mPaint.setAlpha(int a); //得到画笔的Alpha值 mPaint.getAlpha(); // 对字体进行设置（大小、颜色） //设置字体大小 mPaint.setTextSize(float textSize) // 设置对齐方式 mPaint.setTextAlign(Algin algin); // LEFT：左对齐 // CENTER：居中对齐 // RIGHT：右对齐 //设置文本的下划线 mPaint.setUnderlineText(boolean underlineText); //设置文本的删除线 mPaint.setStrikeThruText(boolean strikeThruText); //设置文本粗体 mPaint.setFakeBoldText(boolean fakeBoldText); // 设置斜体 mPaint.setTextSkewX(-0.5f); // 设置文字阴影 mPaint.setShadowLayer(5,5,5,Color.YELLOW);&#125; Paint默认的字体大小为12px，在绘制文本时我们往往要考虑密度density设置合适的字体大小。画笔的默认颜色为黑色，默认的style为FILL，默认的cap为BUTT，默认的线宽为0。 一 坐标系 Canvas坐标系Canvas坐标系即Canvas本身的坐标系。Canvas坐标原点（0,0）在View的左上角，向右为X轴正方向，向下为Y轴正方向。Canvas坐标系唯一且不会改变。 绘图坐标系绘图坐标系区别于Canvas坐标系，以我们绘图起始点为坐标原点（0,0），绘图坐标系默认与Canvas坐标系重合。绘图坐标系原点位置可以更改，Canvas的 translate、rotate、scale 操作都是基于绘图坐标系变化。1234567891011121314151617181920212223242526272829303132333435363738394041//绘制坐标系private void drawAxis(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); int translate = width / 5; //设置画笔宽度 mPaint.setStrokeWidth(10); //设置笔触样式 mPaint.setStrokeCap(Paint.Cap.ROUND); //绘制默认绘图坐标系（此时与Canvas坐标系重合） //绘制红色X轴 mPaint.setColor(Color.RED); canvas.drawLine(0, 0, width, 0, mPaint); //绘制蓝色Y轴 mPaint.setColor(Color.BLUE); canvas.drawLine(0, 0, 0, height, mPaint); //平移 canvas.translate(translate, translate); //绘制平移后绘图坐标系 //绘制红色X轴 mPaint.setColor(Color.RED); canvas.drawLine(0, 0, width, 0, mPaint); //绘制蓝色Y轴 mPaint.setColor(Color.BLUE); canvas.drawLine(0, 0, 0, height, mPaint); //平移 旋转30度 canvas.translate(translate, translate); canvas.rotate(30); //绘制平移旋转后绘图坐标系 //绘制红色X轴 mPaint.setColor(Color.RED); canvas.drawLine(0, 0, width, 0, mPaint); //绘制蓝色Y轴 mPaint.setColor(Color.BLUE); canvas.drawLine(0, 0, 0, height, mPaint);&#125; 二 Canvas绘制颜色单一颜色填充Canvas画布 drawColor drawRGB drawARGB12345//绘制画布颜色private void drawCanvasColor(Canvas canvas) &#123; //drawARGB canvas.drawARGB(255, 47, 140, 150);&#125; 三 绘制点 drawPoint 绘制点 drawPoints 绘制一组点123456789101112131415161718192021222324252627282930313233//绘制点private void drawPoint(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); int translateY = height/5; //设置画笔颜色 mPaint.setColor(Color.RED); //设置画笔宽度 mPaint.setStrokeWidth(200); //设置笔触样式 mPaint.setStrokeCap(Paint.Cap.BUTT); //保存当前画布状态（坐标系） canvas.save(); canvas.drawPoint(width / 3, height / 3, mPaint); //恢复上次画布保存状态（坐标系） canvas.restore(); mPaint.setStrokeCap(Paint.Cap.ROUND); mPaint.setColor(Color.GREEN); canvas.save(); canvas.translate(0, translateY); canvas.drawPoint(width / 3, height / 3, mPaint); canvas.restore(); mPaint.setStrokeCap(Paint.Cap.SQUARE); mPaint.setColor(Color.BLUE); canvas.save(); canvas.translate(translateY, translateY); canvas.drawPoint(width / 3, height / 3, mPaint); canvas.restore();&#125; 四 绘制线 drawLine 绘制线 drawLines 绘制一组线123456789101112131415161718192021222324252627282930313233343536//绘制线private void drawLine(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); int startX = width / 5; int startY = height / 5; //设置画笔颜色 mPaint.setColor(Color.RED); mPaint.setStrokeWidth(20); //设置笔触样式 mPaint.setStrokeCap(Paint.Cap.BUTT); //画笔触为BUTT的线 canvas.drawLine(startX, startY, width - startX, startY, mPaint); //向下平移20 canvas.translate(0, 60); mPaint.setColor(Color.GREEN); mPaint.setStrokeCap(Paint.Cap.ROUND); //画笔触为ROUND的线 canvas.drawLine(startX, startY, width - startX, startY, mPaint); canvas.translate(0, 60); mPaint.setColor(Color.BLUE); mPaint.setStrokeCap(Paint.Cap.SQUARE); //画笔触为SQUARE的线 canvas.drawLine(startX, startY, width - startX, startY, mPaint); canvas.translate(0, 80); mPaint.setColor(Color.BLACK); float[] pts = new float[]&#123;startX, startY, width - startX, startY, startX, startY + 60, width - startX, startY + 60&#125;; canvas.drawLines(pts, mPaint);&#125; 五 绘制矩形 drawRect 绘制矩形 drawRoundRect 绘制圆角矩形12345678910111213141516171819202122232425//绘制矩形private void drawRect(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); //设置画笔颜色 mPaint.setColor(Color.RED); //设置画笔宽度 mPaint.setStrokeWidth(16); //设置画笔样式 mPaint.setStyle(Paint.Style.FILL); canvas.drawRect(20, 20, 400, 200, mPaint); //绘制矩形 API21 //canvas.drawRoundRect(220, 220, 400, 400, 10, 10, mPaint); RectF rect = new RectF(20, 420, 800, 600); canvas.drawRoundRect(rect, 10, 10, mPaint); mPaint.setColor(Color.BLUE); mPaint.setStyle(Paint.Style.STROKE); canvas.drawRect(20, 800, 400, 1000, mPaint); RectF rect1 = new RectF(20, 1200, 800, 1400); canvas.drawRoundRect(rect1, 10, 10, mPaint);&#125; 六 绘制圆 drawCircle 绘制圆12345678910111213141516171819202122232425262728293031//绘制圆形private void drawCircle(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); int halfWidth = width / 2; int d = height / 3; int r = d / 2 - 10; //设置画笔颜色 mPaint.setColor(Color.RED); //设置画笔宽度 mPaint.setStrokeWidth(2); //设置画笔样式 mPaint.setStyle(Paint.Style.FILL); //绘制圆 canvas.drawCircle(halfWidth, (float) (d * 0.5), r, mPaint); //绘制两个圆实现圆环效果 mPaint.setColor(Color.GREEN); canvas.drawCircle(halfWidth, (float) (d * 1.5), r, mPaint); mPaint.setColor(Color.WHITE); canvas.drawCircle(halfWidth, (float) (d * 1.5), r - 40, mPaint); //绘制一个圆实现圆环效果 mPaint.setStrokeWidth(40); mPaint.setColor(Color.BLUE); mPaint.setStyle(Paint.Style.STROKE); //半径减去画笔画笔宽度的一半 圆的大小和前面一致 canvas.drawCircle(halfWidth, (float) (d * 2.5), r - 20, mPaint);&#125; 七 绘制椭圆 drawOval 绘制椭圆跟绘制圆差不多，唯一不同就是绘制圆是指定圆心和半径，绘制椭圆是指定左上右下4个距离。1234567891011121314151617//绘制椭圆 private void drawOval(Canvas canvas) &#123; //设置画笔颜色 mPaint.setColor(Color.RED); //设置画笔宽度 mPaint.setStrokeWidth(2); //设置画笔样式 mPaint.setStyle(Paint.Style.FILL); RectF overRect = new RectF(20, 20, 400, 200); canvas.drawOval(overRect, mPaint); mPaint.setColor(Color.GREEN); mPaint.setStrokeWidth(20); mPaint.setStyle(Paint.Style.STROKE); overRect = new RectF(20, 220, 200, 600); canvas.drawOval(overRect, mPaint);&#125; 八 绘制圆弧 drawArc 绘制弧绘制圆弧，可以绘制弧面和弧线。弧面即用弧围成的填充面，弧线即为弧面的轮廓线。1234567891011121314151617181920212223242526272829303132333435363738394041//绘制弧private void drawAcr(Canvas canvas) &#123; int width = canvas.getWidth(); //设置画笔颜色 mPaint.setColor(Color.RED); //设置画笔宽度 mPaint.setStrokeWidth(2); //设置画笔样式 mPaint.setStyle(Paint.Style.FILL); //和前面绘制椭圆的矩形一致（正方形也可） RectF arcRect = new RectF(20, 20, 400, 200); //根据矩形绘制弧形 开始角度0 扫过角度360 通过中心点首尾连接：true // 和前面绘制的椭圆效果一致 canvas.drawArc(arcRect, 0, 360, true, mPaint); canvas.translate(0, width / 5); canvas.drawArc(arcRect, 0, 90, true, mPaint); canvas.translate(0, width / 5); canvas.drawArc(arcRect, 0, 90, false, mPaint); //正方形 arcRect = new RectF(20, 20, 220, 220); mPaint.setStrokeWidth(4); mPaint.setStyle(Paint.Style.STROKE); canvas.translate(0, width / 5); //根据矩形绘制弧形 角度从0-1800 首尾连接 canvas.drawArc(arcRect, 0, 180, true, mPaint); canvas.translate(0, width / 5); //根据矩形绘制弧形 角度从0-1800 首尾不连接 canvas.drawArc(arcRect, 0, 180, false, mPaint); mPaint.setStrokeWidth(10); canvas.translate(width / 2, width / 5); //drawArc绘制出圆环 canvas.drawArc(arcRect, 0, 270, false, mPaint); mPaint.setColor(Color.GREEN); canvas.drawArc(arcRect, 270, 90, false, mPaint);&#125; 九 绘制文字 drawText 绘制文本 drawPosText 根据位置绘制文本 drawTextOnPath 根据路径绘制文本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//绘制文字private void drawText(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); int textHeight = 32; int halfWidth = width / 2; //设置画笔颜色 mPaint.setColor(Color.GRAY); //设置画笔宽度 mPaint.setStrokeWidth(2); canvas.drawLine(halfWidth, 0, halfWidth, height, mPaint); mPaint.setColor(Color.BLACK); //设置文本大小 mPaint.setTextSize(textHeight); //绘制普通文本 canvas.drawText("绘制普通文本", 0, textHeight, mPaint); mPaint.setColor(Color.RED); mPaint.setTextAlign(Paint.Align.LEFT); //存储画布状态 坐标系 canvas.save(); //平移 canvas.translate(halfWidth, textHeight); //绘制左对齐文本 canvas.drawText("绘制左对齐文本", 0, textHeight, mPaint); //恢复上次存储状态 canvas.restore(); mPaint.setColor(Color.GREEN); mPaint.setTextAlign(Paint.Align.CENTER); //存储画布状态 坐标系 canvas.save(); //平移 canvas.translate(halfWidth, textHeight * 2); //绘制居中对齐文本(对齐是根据绘图坐标系而言) canvas.drawText("绘制居中对齐文本", 0, textHeight, mPaint); //恢复上次存储状态 canvas.restore(); mPaint.setColor(Color.BLUE); mPaint.setTextAlign(Paint.Align.RIGHT); //存储画布状态 坐标系 canvas.save(); //平移 canvas.translate(halfWidth, textHeight * 3); //绘制右对齐文本 canvas.drawText("绘制右对齐文本", 0, textHeight, mPaint); //恢复上次存储状态 canvas.restore(); mPaint.setColor(Color.BLACK); //恢复默认对齐方式 mPaint.setTextAlign(Paint.Align.LEFT); //设置下划线 mPaint.setUnderlineText(true); //设置加粗 mPaint.setFakeBoldText(true); //设置删除线 mPaint.setStrikeThruText(true); //存储画布状态 坐标系 canvas.save(); //平移 canvas.translate(halfWidth, textHeight * 4); //绘制下划线加粗文本 canvas.drawText("绘制下划线加粗文本", 0, textHeight, mPaint); //恢复上次存储状态 canvas.restore(); mPaint.reset(); mPaint.setColor(Color.BLACK); //设置文本大小 mPaint.setTextSize(textHeight); //存储画布状态 坐标系 canvas.save(); canvas.translate(width / 3, height / 3); //旋转 canvas.rotate(45); //绘制倾斜文本 canvas.drawText("绘制倾斜文本", 0, textHeight, mPaint); //恢复上次存储状态 canvas.restore(); float[] pos = new float[]&#123;40, 40, 80, 80, 120, 120, 160, 160, 200, 200, 240, 240&#125;; //存储画布状态 坐标系 canvas.save(); canvas.translate(width / 3, height / 2); canvas.drawPosText("绘制位置文本", pos, mPaint); //恢复上次存储状态 canvas.restore(); Path path = new Path(); path.cubicTo(550, 750, 350, 250, 850, 800); //画路径 mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); canvas.drawPath(path,mPaint); canvas.drawTextOnPath("绘制文本OnPath绘制文本OnPath绘制文本OnPath绘制文本OnPath绘制文本OnPath", path, 50, 0, mPaint);&#125; 十 绘制Path drawPath 绘制路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 //path拐点集合 List&lt;Point&gt; points = new ArrayList&lt;&gt;(); //绘制Path private void drawPath(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); int deltaX = width / 4; int deltaY = (int) (deltaX * 0.75); //设置画笔颜色 mPaint.setColor(Color.GRAY); //设置画笔宽度 mPaint.setStrokeWidth(4); //Fill模式画面 Path path1 = new Path(); RectF arcRect = new RectF(0, 0, deltaX, deltaY); path1.addArc(arcRect, 0, 360); path1.addRect(deltaX, 0, deltaX &lt;&lt; 1, deltaY, Path.Direction.CW); canvas.drawPath(path1, mPaint); //STROKE模式画线 mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.STROKE); canvas.translate(0, deltaY &lt;&lt; 1); canvas.drawPath(path1, mPaint); mPaint.setColor(Color.BLUE);// mPaint.setStyle(Paint.Style.FILL); canvas.translate(0, deltaY &lt;&lt; 1); Path path2 = new Path(); path2.lineTo(100, 0); //画线 points.add(new Point(100, 0)); //终点 X: 100 Y: 0 RectF overRect = new RectF(100, -50, 300, 50); path2.arcTo(overRect, 180, -90); //画椭圆 左下部分 points.add(new Point(200, 50)); //终点 X: 250 Y: 50 overRect = new RectF(200, 0, 400, 100); path2.arcTo(overRect, 180, 90); //画椭圆右上部分 points.add(new Point(300, 0)); //终点 X: 300 Y: 0 path2.lineTo(350, 50); //画线 points.add(new Point(350, 50)); //终点 X: 350 Y: 50 //画二阶贝塞尔曲线 第一个坐标为控制点 最后为终点 path2.quadTo(450, -50, 500, 150); points.add(new Point(500, 150)); //终点 X: 500 Y: 150 //画三阶阶贝塞尔曲线 前两个坐标为控制点 最后为终点 path2.cubicTo(600, 150, 700, 0, 380, -200); points.add(new Point(380, -200)); //终点 X: 480 Y: -200 path2.rLineTo(0, 100); points.add(new Point(380, -200 + 100)); //终点 X: 480 Y: -100 canvas.drawPath(path2, mPaint); mPaint.setStrokeWidth(10); mPaint.setColor(Color.RED); mPaint.setStrokeCap(Paint.Cap.ROUND); for (Point point : points) &#123; canvas.drawPoint(point.x, point.y, mPaint); &#125; &#125; 十一 绘制Bitmap drawBitmap 绘制Bitmap1234567891011121314151617181920212223242526272829//绘制Bitmapprivate void drawBitmap(Canvas canvas) &#123; BitmapDrawable drawable = (BitmapDrawable) getResources().getDrawable(R.mipmap.ic_launcher); Bitmap bitmap = drawable.getBitmap(); //如果bitmap不存在，那么就不执行下面的绘制代码 if (bitmap == null) &#123; return; &#125; //直接完全绘制Bitmap canvas.drawBitmap(bitmap, 0, 0, mPaint); //绘制Bitmap的一部分，并对其拉伸 //srcRect定义了要绘制Bitmap的哪一部分 Rect srcRect = new Rect(); srcRect.left = 0; srcRect.right = bitmap.getWidth(); srcRect.top = 0; srcRect.bottom = (int) (0.33 * bitmap.getHeight()); float radio = (float) (srcRect.bottom - srcRect.top) / bitmap.getWidth(); //dstRecF定义了要将绘制的Bitmap拉伸到哪里 RectF dstRecF = new RectF(); dstRecF.left = 0; dstRecF.right = canvas.getWidth(); dstRecF.top = bitmap.getHeight(); float dstHeight = (dstRecF.right - dstRecF.left) * radio; dstRecF.bottom = dstRecF.top + dstHeight; canvas.drawBitmap(bitmap, srcRect, dstRecF, mPaint);&#125; 以上就是大部分的绘制操作，当然还有一些没介绍到，还有一些需要在API21（5.0）以上才能使用，这个使用到的时候可以弄个小demo看下效果，接下来介绍下针对画布变换和画布裁剪做一些介绍。 十二 画布变换 translate 平移 scale 缩放 rotate 旋转 skew 错切 在学习绘制操作的时候很多地方都使用到了translate 和rotate 这里就不再对它们进行操作 1.画布scale123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//画布缩放private void canvasScale(Canvas canvas) &#123; int width = canvas.getWidth(); int height = canvas.getHeight(); int hWidth = width / 2; int hHeight = height / 2; mPaint.setColor(Color.GRAY); mPaint.setStrokeWidth(2); mPaint.setStyle(Paint.Style.STROKE); //使用path 画布中心的X Y 轴 Path path = new Path(); path.moveTo(hWidth, 0); path.lineTo(hWidth, height); path.moveTo(0, hHeight); path.lineTo(width, hHeight); canvas.drawPath(path, mPaint); //画布平移 canvas.translate(hWidth, hHeight); mPaint.setColor(Color.RED); mPaint.setStrokeWidth(5); RectF rectF = new RectF(0, 0, 200, 100); canvas.drawRect(rectF, mPaint); //默认0,0进行缩放 canvas.scale(1.5f, 1.5f); mPaint.setColor(Color.BLUE); canvas.drawRect(rectF, mPaint); //100,0进行缩放 canvas.scale(1.5f, 1.5f, 100, 0); mPaint.setColor(Color.GREEN); canvas.drawRect(rectF, mPaint); /* 当缩放倍数为负数时，会先进行缩放，然后根据不同情况进行图形翻转： （设缩放倍数为（a,b），旋转中心为（px，py））： a&lt;0，b&gt;0：以px为轴翻转 a&gt;0，b&lt;0：以py为轴翻转 a&lt;0，b&lt;0：以旋转中心翻转 */ //100,0进行缩放 以Y轴翻转 canvas.scale(1f, -1f, 100, 0); mPaint.setColor(Color.BLACK); canvas.drawRect(rectF, mPaint);&#125; 2.画布skew1234567891011121314151617181920212223242526//画布错切private void canvasSkew(Canvas canvas) &#123; mPaint.setColor(Color.RED); mPaint.setStrokeWidth(5); mPaint.setStyle(Paint.Style.STROKE); RectF rectF = new RectF(0, 0, 400, 200); canvas.translate(100,100); canvas.drawRect(rectF, mPaint); canvas.save(); canvas.translate(0,300); //画布X正方向错切45° canvas.skew(1f, 0); canvas.drawRect(rectF, mPaint); canvas.restore(); canvas.save(); canvas.translate(0,600); //画布Y负方向错切45° canvas.skew(0, -1f); canvas.drawRect(rectF, mPaint); canvas.restore(); mPaint.setColor(Color.GREEN); canvas.drawLine(0,400,600,400,mPaint);&#125; 十三 画布裁剪 clipPath clipRect clipRegion(过时) getClipBounds12345678910111213141516171819202122232425//画布裁剪private void canvasClip(Canvas canvas) &#123; canvas.drawColor(Color.RED); canvas.save(); //矩形裁剪 canvas.clipRect(0, 0, 400, 200); canvas.drawColor(Color.BLUE); canvas.restore(); canvas.save(); canvas.translate(20, 400); Path path = new Path(); path.addRect(0, 0, 400, 200, Path.Direction.CCW); canvas.drawPath(path, mPaint); //路径裁剪 canvas.clipPath(path); canvas.drawColor(Color.GREEN); //获得裁剪边界 Rect bounds = canvas.getClipBounds(); mPaint.setColor(Color.BLACK); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeWidth(10); canvas.drawRect(bounds, mPaint); canvas.restore();&#125; 这里针对Canvas的API进行了一些说明，希望对大家有所帮助。没有添加完整工程上来，但是每一个方法都是实际跑过的，只需要在onDraw中调用就可以看到效果了。]]></content>
      <categories>
        <category>Android</category>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 自定义CircleImageView]]></title>
    <url>%2F2018%2F01%2F05%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89CircleImageView%2F</url>
    <content type="text"><![CDATA[android开发中时常用到圆形、圆角的ImageView，网上也有很多现成的轮子，本不应该重复造轮子。但是本着不断学习和进步的决心，今天就来手撸一个圆形、圆角ImageView，且可设置边框颜色、大小。无图无真相，首先我们来看下效果图: 看完效果图，不知道各位看官觉得如何，觉得好那就 just do it ! (就是干！)。 接下来 嗯 嗯 啊 啊 啊…… 嗯 得先来个说明 本文标题说的是自定义CircleImageView，但是我们实际干的却是圆形 还有圆角矩形。所以我们就不叫CircleImageView，且叫它ShapeImageView，虽然只有两种形状。觉得不合适的可随意修改嘛… 然后我们得知道自定义控件的四步曲：1、自定义View的属性2、在View的构造方法中获得我们自定义的属性3、重写onMeasure4、重写onDraw 接下来就正式开干…… 一 自定义属性为了感觉高大上，我们的自定义控件还是配上几个自定义属性才像话嘛！！！总共定义了6个自定义属性，分别是边框宽、边框颜色、边框重叠、填充颜色、圆角半径、形状类型。1234567891011&lt;declare-styleable name="ShapeImageView"&gt; &lt;attr name="siv_border_width" format="dimension"/&gt; &lt;attr name="siv_border_color" format="color"/&gt; &lt;attr name="siv_border_overlay" format="boolean"/&gt; &lt;attr name="siv_fill_color" format="color"/&gt; &lt;attr name="siv_round_radius" format="dimension"/&gt; &lt;attr name="siv_shape_type"&gt; &lt;enum name="circle" value="0"/&gt; &lt;enum name="round" value="1"/&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 二 获取自定义属性这里得分两步，这第一步就得是继承自我们的ImageView，并重写他的构造方法：1234567891011121314//这里我们让一个、两个参数的构造方法都去调用三个参数的构造方法public class ShapeImageView extends ImageView &#123; public ShapeImageView(Context context) &#123; this(context, null); &#125; public ShapeImageView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public ShapeImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 没错，这第二步就是获取自定义属性了，因为我们都统一调用的三个参数的构造方法，所以直接在三个参数的构造方法中获取属性：1234567891011public ShapeImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ShapeImageView, defStyleAttr, 0); mBorderWidth = a.getDimensionPixelSize(R.styleable.ShapeImageView_siv_border_width, DEFAULT_BORDER_WIDTH); mBorderColor = a.getColor(R.styleable.ShapeImageView_siv_border_color, DEFAULT_BORDER_COLOR); mFillColor = a.getColor(R.styleable.ShapeImageView_siv_fill_color, DEFAULT_FILL_COLOR); mBorderOverlay = a.getBoolean(R.styleable.ShapeImageView_siv_border_overlay, DEFAULT_BORDER_OVERLAY); mShapeType = a.getInt(R.styleable.ShapeImageView_siv_shape_type, SHAPE_CIRCLE); mRoundRadius = a.getDimensionPixelSize(R.styleable.ShapeImageView_siv_round_radius, DEFAULT_ROUND_RADIUS); a.recycle();&#125; 这里没什么好说的，就是把我们刚才的6个自定义属性值获取出来了，没有值的都赋上默认值。记得最后调用下recycle()，就行了。 三 ShapeImageView之onMeasure我们这里是继承自ImageView，所以测量的事情就让ImageView去祸祸，这一步我们就这么愉快的完成了。 四 ShapeImageView之onDraw这一步是最关键的一步了，也是我们的最后一步，完成它就可以看到最终的效果图了。接下来我们就需要把这一步细分成几小步来完成： 获取要绘制的Bitmap 12345678910111213141516171819202122232425//从Drawable中取出Bitmap private Bitmap getBitmapFormDrawable() &#123; Drawable drawable = getDrawable(); if (drawable == null) &#123; return null; &#125; //是BitmapDrawable直接取出Bitmap if (drawable instanceof BitmapDrawable) &#123; return ((BitmapDrawable) drawable).getBitmap(); &#125; try &#123; //这里需要对DEFAULT_DRAWABLE_DIMENSION说明：在ColorDrawable中getIntrinsicWidth为-1，所以给了个默认值2 int dWidth = drawable.getIntrinsicWidth() &lt;= 0 ? DEFAULT_DRAWABLE_DIMENSION : drawable.getIntrinsicWidth(); int dHeight = drawable.getIntrinsicHeight() &lt;= 0 ? DEFAULT_DRAWABLE_DIMENSION : drawable.getIntrinsicHeight(); //创建Bitmap画布，并绘制出来 Bitmap bitmap = Bitmap.createBitmap(dWidth, dHeight, BITMAP_CONFIG); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight()); drawable.draw(canvas); return bitmap; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125; 更新设置这里需要简单介绍下BitmapShader: BitmapShader，顾名思义，就是用Bitmap对绘制的图形进行渲染着色，其实就是用图片对图形进行贴图。BitmapShader构造函数如下所示：BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)第一个参数是Bitmap对象，该Bitmap决定了用什么图片对绘制的图形进行贴图。第二个参数和第三个参数都是Shader.TileMode类型的枚举值，有以下三个取值：CLAMP(拉伸) 、REPEAT(重复) 和 MIRROR(镜像)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void updateSetup() &#123; if (mWidth == 0 &amp;&amp; mHeight == 0) &#123; return; &#125; if (mBitmap == null) &#123; super.invalidate(); return; &#125; //设置BitmapShader 使用拉伸模式 BitmapShader bitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); //设置BitmapPaint mBitmapPaint.setAntiAlias(true); mBitmapPaint.setShader(bitmapShader); //设置BorderPaint mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(mBorderColor); mBorderPaint.setStrokeWidth(mBorderWidth); //设置FillPaint mFillPaint.setStyle(Paint.Style.FILL); mFillPaint.setAntiAlias(true); mFillPaint.setColor(mFillColor); //将坐标从src复制到这个mContentRect矩形 mContentRect.set(calculateRect()); if (!mBorderOverlay &amp;&amp; mBorderWidth &gt; 0) &#123; //允许边框重叠操作 mContentRect.inset(mBorderWidth - 0.0f, mBorderWidth - 0.0f); &#125; if (mShapeType == SHAPE_CIRCLE) &#123; //边框半径 mBorderRadius = Math.min((mContentRect.width() - mBorderWidth) / 2.0f, (mContentRect.height() - mBorderWidth) / 2.0f); //内容半径 mContentRadius = Math.min(mContentRect.width() / 2.0f, mContentRect.height() / 2.0f); &#125; else if (mShapeType == SHAPE_ROUND) &#123; // TODO: 2017/8/21 &#125; updateMatrix(bitmapShader);&#125;//计算矩形大小private RectF calculateRect() &#123; int width = mWidth - getPaddingLeft() - getPaddingRight(); int height = mHeight - getPaddingTop() - getPaddingBottom(); int left = getPaddingLeft(); int top = getPaddingTop(); return new RectF(left, top, left + width, top + height);&#125;//更新矩阵（这里使用ImageView CENTER_CROP类似计算 所以我们这个控件也仅支持CENTER_CROP 其他的都不起作用）private void updateMatrix(BitmapShader bitmapShader) &#123; float scale; float dx = 0, dy = 0; final int bHeight = mBitmap.getHeight(); final int bWidth = mBitmap.getWidth(); final float cWidth = mContentRect.width(); final float cHeight = mContentRect.height(); //计算缩放比例 平移距离 if (bWidth * cHeight &gt; cWidth * bHeight) &#123; //宽度比 &gt; 高度比 取高度比缩放 scale = cHeight / (float) bHeight; //计算横向移动距离 dx = (cWidth - bWidth * scale) * 0.5f; &#125; else &#123; scale = cWidth / (float) bWidth; dy = (cHeight - bHeight * scale) * 0.5f; &#125; Matrix mMatrix = new Matrix(); //缩放 平移 mMatrix.setScale(scale, scale); mMatrix.postTranslate(Math.round(dx) + mContentRect.left, Math.round(dy) + mContentRect.left); // 设置变换矩阵 bitmapShader.setLocalMatrix(mMatrix);&#125; 接下来需要在onDraw中进行绘制操作： 123456789101112131415161718192021222324252627282930313233@Overrideprotected void onDraw(Canvas canvas) &#123; if (mBitmap == null) &#123; return; &#125; if (mShapeType == SHAPE_CIRCLE) &#123; drawCircle(canvas); &#125; else if (mShapeType == SHAPE_ROUND) &#123; drawRoundRect(canvas); &#125;&#125;//圆角矩形private void drawRoundRect(Canvas canvas) &#123; if (mFillColor != Color.TRANSPARENT) &#123; canvas.drawRoundRect(mContentRect, mRoundRadius, mRoundRadius, mFillPaint); &#125; canvas.drawRoundRect(mContentRect, mRoundRadius, mRoundRadius, mBitmapPaint); if (mBorderWidth &gt; 0) &#123; canvas.drawRoundRect(mContentRect, mRoundRadius, mRoundRadius, mBorderPaint); &#125;&#125;//圆形private void drawCircle(Canvas canvas) &#123; if (mFillColor != Color.TRANSPARENT) &#123; canvas.drawCircle(mContentRect.centerX(), mContentRect.centerY(), mContentRadius, mFillPaint); &#125; canvas.drawCircle(mContentRect.centerX(), mContentRect.centerY(), mContentRadius, mBitmapPaint); if (mBorderWidth &gt; 0) &#123; canvas.drawCircle(mContentRect.centerX(), mContentRect.centerY(), mBorderRadius, mBorderPaint); &#125;&#125; 到这一步，就是万事具备，只欠东风。我们需要在合适的地方来调用getBitmapFormDrawable和updateSteup方法，到现在还没有调用过这两个方法。不卖关子直接贴出代码： 123456789101112131415161718@Overridepublic void invalidate() &#123; mBitmap = getBitmapFormDrawable(); updateSetup(); super.invalidate();&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (w &gt; 0) &#123; mWidth = w; &#125; if (h &gt; 0) &#123; mHeight = h; &#125; invalidate();&#125; 最开始想在setImageDrawable调用这两个方法，在跟踪源码的是否发现，ImageView的大部分设置图片的最终都调用了setImageDrawable方法，但是setImageURI并没有。 可是它们都调用了invalidate方法，而且当参数改变的时候也会调用这个方法。所以在这里获取getBitmapFormDrawable和updateSteup。 最后我们需要在onSizeChanged获取到mWidth 、mHeight 并invalidate，ShapIamgeView就大功告成了。 五 代码设置自定义属性我们发现6个自定义属性只能在xml配置，但是我们想要通过代码改变怎么办呢？其实也很简单，拿自定义边框宽度属性举个例子：1234567public void setBorderWidth(int borderWidth) &#123; if (mBorderWidth == borderWidth) &#123; return; &#125; mBorderPaint.setColor(mBorderWidth = borderWidth); invalidate(); &#125; 就是这样，我们就可以得到开头效果图一样的运行效果了，上面四部曲注释也很详细了。 最后福利，贴出完整代码(没有通过代码设置自定义属性的方法)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191public class ShapeImageView extends ImageView &#123; public static final int SHAPE_CIRCLE = 0; //圆形 public static final int SHAPE_ROUND = 1; //圆角 private final int DEFAULT_BORDER_WIDTH = 0; private final int DEFAULT_ROUND_RADIUS = 0; private final int DEFAULT_BORDER_COLOR = Color.BLACK; private final int DEFAULT_FILL_COLOR = Color.TRANSPARENT; private final boolean DEFAULT_BORDER_OVERLAY = false; private final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888; private final int DEFAULT_DRAWABLE_DIMENSION = 2; private int mRoundRadius; //圆角 private int mBorderWidth; //边框宽 private int mBorderColor; //边框颜色 private int mFillColor; //填充颜色 private boolean mBorderOverlay; //边框叠加 private int mShapeType; //形状 private RectF mContentRect = new RectF(); private Paint mBorderPaint = new Paint(); private Paint mBitmapPaint = new Paint(); private Paint mFillPaint = new Paint(); private float mContentRadius; private float mBorderRadius; private Bitmap mBitmap; private int mWidth; private int mHeight; public ShapeImageView(Context context) &#123; this(context, null); &#125; public ShapeImageView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public ShapeImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ShapeImageView, defStyleAttr, 0); mBorderWidth = a.getDimensionPixelSize(R.styleable.ShapeImageView_siv_border_width, DEFAULT_BORDER_WIDTH); mBorderColor = a.getColor(R.styleable.ShapeImageView_siv_border_color, DEFAULT_BORDER_COLOR); mFillColor = a.getColor(R.styleable.ShapeImageView_siv_fill_color, DEFAULT_FILL_COLOR); mBorderOverlay = a.getBoolean(R.styleable.ShapeImageView_siv_border_overlay, DEFAULT_BORDER_OVERLAY); mShapeType = a.getInt(R.styleable.ShapeImageView_siv_shape_type, SHAPE_CIRCLE); mRoundRadius = a.getDimensionPixelSize(R.styleable.ShapeImageView_siv_round_radius, DEFAULT_ROUND_RADIUS); a.recycle(); &#125; @Override public void invalidate() &#123; mBitmap = getBitmapFormDrawable(); updateSetup(); super.invalidate(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); if (w &gt; 0) &#123; mWidth = w; &#125; if (h &gt; 0) &#123; mHeight = h; &#125; invalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mBitmap == null) &#123; return; &#125; if (mShapeType == SHAPE_CIRCLE) &#123; drawCircle(canvas); &#125; else if (mShapeType == SHAPE_ROUND) &#123; drawRoundRect(canvas); &#125; &#125; //圆角矩形 private void drawRoundRect(Canvas canvas) &#123; if (mFillColor != Color.TRANSPARENT) &#123; canvas.drawRoundRect(mContentRect, mRoundRadius, mRoundRadius, mFillPaint); &#125; canvas.drawRoundRect(mContentRect, mRoundRadius, mRoundRadius, mBitmapPaint); if (mBorderWidth &gt; 0) &#123; canvas.drawRoundRect(mContentRect, mRoundRadius, mRoundRadius, mBorderPaint); &#125; &#125; //圆形 private void drawCircle(Canvas canvas) &#123; if (mFillColor != Color.TRANSPARENT) &#123; canvas.drawCircle(mContentRect.centerX(), mContentRect.centerY(), mContentRadius, mFillPaint); &#125; canvas.drawCircle(mContentRect.centerX(), mContentRect.centerY(), mContentRadius, mBitmapPaint); if (mBorderWidth &gt; 0) &#123; canvas.drawCircle(mContentRect.centerX(), mContentRect.centerY(), mBorderRadius, mBorderPaint); &#125; &#125; private void updateSetup() &#123; if (mWidth == 0 &amp;&amp; mHeight == 0) &#123; return; &#125; if (mBitmap == null) &#123; super.invalidate(); return; &#125; BitmapShader bitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); mBitmapPaint.setAntiAlias(true); mBitmapPaint.setShader(bitmapShader); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(mBorderColor); mBorderPaint.setStrokeWidth(mBorderWidth); mFillPaint.setStyle(Paint.Style.FILL); mFillPaint.setAntiAlias(true); mFillPaint.setColor(mFillColor); //边框 mContentRect.set(calculateRect()); if (!mBorderOverlay &amp;&amp; mBorderWidth &gt; 0) &#123; mContentRect.inset(mBorderWidth - 0.0f, mBorderWidth - 0.0f); &#125; if (mShapeType == SHAPE_CIRCLE) &#123; //边框半径 mBorderRadius = Math.min((mContentRect.width() - mBorderWidth) / 2.0f, (mContentRect.height() - mBorderWidth) / 2.0f); //内容半径 mContentRadius = Math.min(mContentRect.width() / 2.0f, mContentRect.height() / 2.0f); &#125; else if (mShapeType == SHAPE_ROUND) &#123; // TODO: 2017/8/21 &#125; updateMatrix(bitmapShader); &#125; private void updateMatrix(BitmapShader bitmapShader) &#123; float scale; float dx = 0, dy = 0; final int bHeight = mBitmap.getHeight(); final int bWidth = mBitmap.getWidth(); final float cWidth = mContentRect.width(); final float cHeight = mContentRect.height(); //计算缩放比例 平移距离 if (bWidth * cHeight &gt; cWidth * bHeight) &#123; //宽度比 &gt; 高度比 取高度比缩放 scale = cHeight / (float) bHeight; //计算横向移动距离 dx = (cWidth - bWidth * scale) * 0.5f; &#125; else &#123; scale = cWidth / (float) bWidth; dy = (cHeight - bHeight * scale) * 0.5f; &#125; Matrix mMatrix = new Matrix(); mMatrix.setScale(scale, scale); mMatrix.postTranslate(Math.round(dx) + mContentRect.left, Math.round(dy) + mContentRect.left); bitmapShader.setLocalMatrix(mMatrix); &#125; private RectF calculateRect() &#123; int width = mWidth - getPaddingLeft() - getPaddingRight(); int height = mHeight - getPaddingTop() - getPaddingBottom(); int left = getPaddingLeft(); int top = getPaddingTop(); return new RectF(left, top, left + width, top + height); &#125; private Bitmap getBitmapFormDrawable() &#123; Drawable drawable = getDrawable(); if (drawable == null) &#123; return null; &#125; if (drawable instanceof BitmapDrawable) &#123; return ((BitmapDrawable) drawable).getBitmap(); &#125; try &#123; int dWidth = drawable.getIntrinsicWidth() &lt;= 0 ? DEFAULT_DRAWABLE_DIMENSION : drawable.getIntrinsicWidth(); int dHeight = drawable.getIntrinsicHeight() &lt;= 0 ? DEFAULT_DRAWABLE_DIMENSION : drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(dWidth, dHeight, BITMAP_CONFIG); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight()); drawable.draw(canvas); return bitmap; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 到此…… 全剧终！！！]]></content>
      <categories>
        <category>Android</category>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 点击空白处 隐藏键盘]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-%E7%82%B9%E5%87%BB%E7%A9%BA%E7%99%BD%E5%A4%84-%E9%9A%90%E8%97%8F%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[这里给大家介绍3种方案，均可以封装在BaseActivity使用，可以根据自己实际需求酌情使用： 判断焦点（网上介绍最多的方案）原理：在事件分发的时候判断当前获取焦点的View是不是EditText，是EditText就判断MotionEvent 是否发生在这个View上，然后隐藏键盘，不足的是点击另一个EditText会看到键盘隐藏然后再显示。 12345678910111213141516171819202122232425262728293031323334353637/** * 获取点击事件 */@CallSuper@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.MotionEvent ) &#123; View view = getCurrentFocus(); if (isShouldHideKeyBord(view, ev)) &#123; hideSoftInput(view.getWindowToken()); &#125; &#125; return super.dispatchTouchEvent(ev);&#125;/** * 判定当前是否需要隐藏 */protected boolean isShouldHideKeyBord(View v, MotionEvent ev) &#123; if (v != null &amp;&amp; (v instanceof EditText)) &#123; int[] l = &#123;0, 0&#125;; v.getLocationInWindow(l); int left = l[0], top = l[1], bottom = top + v.getHeight(), right = left + v.getWidth(); return !(ev.getX() &gt; left &amp;&amp; ev.getX() &lt; right &amp;&amp; ev.getY() &gt; top &amp;&amp; ev.getY() &lt; bottom); &#125; return false;&#125;/** * 隐藏软键盘 */private void hideSoftInput(IBinder token) &#123; if (token != null) &#123; InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); manager.hideSoftInputFromWindow(token, InputMethodManager.HIDE_NOT_ALWAYS); &#125;&#125; 根布局设置点击事件原理：对根布局设置点击事件，点击根布局则隐藏键盘。不足的是点击到能获取焦点的控件上无效。 123456789101112131415161718192021@CallSuper@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //点击空白处隐藏键盘 ((ViewGroup) findViewById(android.R.id.content)).getChildAt(0).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; hideSoftInput(view.getWindowToken()); &#125; &#125;);&#125;/** * 隐藏软键盘 */private void hideSoftInput(IBinder token) &#123; if (token != null) &#123; InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); manager.hideSoftInputFromWindow(token, InputMethodManager.HIDE_NOT_ALWAYS); &#125; 过滤不需要隐藏键盘的View原理：在事件分发的时候判断ACTION_DOWN事件是不是在需要过滤的View上，不是就隐藏键盘，不足的是每发生一次ACTION_DOWN都要循环一次filterViews。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 获取点击事件 */@CallSuper@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; filterViews != null) &#123; View focusView = getCurrentFocus(); if (isShouldHideKeyBord(ev)) &#123; hideSoftInput(focusView.getWindowToken()); &#125; &#125; return super.dispatchTouchEvent(ev);&#125;/** *设置需要过滤掉的View */protected void setFilterView(View... view) &#123; this.filterViews = view;&#125;/** * 判定当前是否需要隐藏 */protected boolean isShouldHideKeyBord(MotionEvent ev) &#123; boolean hide = true; for (View v : filterViews) &#123; int[] l = &#123;0, 0&#125;; v.getLocationInWindow(l); int left = l[0], top = l[1], bottom = top + v.getHeight(), right = left + v.getWidth(); if (ev.getX() &gt; left &amp;&amp; ev.getX() &lt; right &amp;&amp; ev.getY() &gt; top &amp;&amp; ev.getY() &lt; bottom) &#123; hide = false; break; &#125; &#125; return hide;&#125;/** * 隐藏软键盘 */private void hideSoftInput(IBinder token) &#123; if (token != null) &#123; InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); manager.hideSoftInputFromWindow(token, InputMethodManager.HIDE_NOT_ALWAYS); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ButterKnife8.8 module与library配置使用记录]]></title>
    <url>%2F2018%2F01%2F02%2FButterKnife8-8-module%E4%B8%8Elibrary%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文使用前提是在Android Studio2.3.3 Stable版本使用记录，其他版本未测试。 一、module中配置 如果在module中配置，那就GitHub中配置一致三步曲操作，然后就可以正常使用了。 1 在module的build中添加依赖1234dependencies &#123; compile 'com.jakewharton:butterknife:8.8.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'&#125; 如果你是使用Kotlin, 将annotationProcessor替换为kapt. 2 project的build中添加12345678buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'com.jakewharton:butterknife-gradle-plugin:8.8.1' &#125;&#125; 3 在module中apply:12apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' 现在确定Butter Knife注解可以使用R2 替换 R。 12345class ExampleActivity extends Activity &#123; @BindView(R2.id.user) EditText username; @BindView(R2.id.pass) EditText password;...&#125; 二、library中配置一般我们会在BaseActivity中使用ButterKnife.bind(this)，但是我的base类都在library中。一开始我直接在library中配置，module依赖library，让module依赖library。但是直接报R2找不到，然后我就使用R替换，不过具体使用的地方会报空指针。看github的issue中有很多人也遇到这个问题，但是我是在没找到一个准确的解决办法，然后自己摸索了一个办法，还是可以使用的，如果有比较官方的办法，可以告诉我。 1 我们还是直接在中library按配置module方式进行配置 2 既然我们不能找到R2，说明我们module没有apply plugin。所以需要在对应的module的build添加如下代码，然后点击sync now并rebuild，R2已经不报错了。1234//不使用下面这句，因为我们的library项目已经有了//apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' 3 R2不报错了，我们运行后，依旧会有空指针。我觉得是这个module没有解析到R2，导致BindView失败，所以将注解解析器依赖到对应的module1annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' 最后点击sync now并rebuild运行完美通过。 三、配置小总结：1 需要使用ButterKnife的module一定要配置如下两句：123apply plugin: 'com.jakewharton.butterknife'annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1']]></content>
      <categories>
        <category>Android</category>
        <category>ButterKnife</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ButterKnife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TabLayout系列之进阶使用]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-TabLayout%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1 前言上篇 TabLayout系列之简单使用更新也有一段时间了，由于工作任务比较多且遇上国庆出去玩，就很久没做更新了。还有一点关于TabLayout的使用没有介绍完，公司的事忙得差不多了，今天来继续介绍这个系列。再啰嗦下，前两篇文章介绍了TabLayout的 属性 和 简单使用，需要的便宜可以先去熟悉熟悉。这篇文章主要是简单使用的一个补充，以及对自定义TabItem的一个说明。废话不多说，我们直奔主题。 2 TabLayout默认Style12TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TabLayout,defStyleAttr, R.style.Widget_Design_TabLayout); 12345678910&lt;style name="Base.Widget.Design.TabLayout" parent="android:Widget"&gt; &lt;item name="tabMaxWidth"&gt;@dimen/design_tab_max_width&lt;/item&gt; &lt;item name="tabIndicatorColor"&gt;?attr/colorAccent&lt;/item&gt; &lt;item name="tabIndicatorHeight"&gt;2dp&lt;/item&gt; &lt;item name="tabPaddingStart"&gt;12dp&lt;/item&gt; &lt;item name="tabPaddingEnd"&gt;12dp&lt;/item&gt; &lt;item name="tabBackground"&gt;?attr/selectableItemBackground&lt;/item&gt; &lt;item name="tabTextAppearance"&gt;@style/TextAppearance.Design.Tab&lt;/item&gt; &lt;item name="tabSelectedTextColor"&gt;?android:textColorPrimary&lt;/item&gt;&lt;/style&gt; 12345&lt;style name="TextAppearance.Design.Tab" parent="TextAppearance.AppCompat.Button"&gt; &lt;item name="android:textSize"&gt;@dimen/design_tab_text_size&lt;/item&gt; &lt;item name="android:textColor"&gt;?android:textColorSecondary&lt;/item&gt; &lt;item name="textAllCaps"&gt;true&lt;/item&gt;&lt;/style&gt; 上面三段代码片段，可以知道TabLayout默认使用Base.Widget.Design.TabLayout，里面有预设好的一些属性。其中tabTextAppearance在 Android TabLayout系列之简单使用中已经介绍到了，通过继承它来改变默认英文字母大写与字体大小问题，由此我们也可以自定义自己的style来实现自己的需求。 3 带图片的TabAndroid TabLayout系列之简单使用中，介绍到了TabLayout的使用，但基本上都是纯文本的TabItem，并没有实现带图片的TabItem。这次就闲来撸一个带图片的TabItem，还是老规矩先上代码(码注释) -&gt; 效果图 -&gt; 分析。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(R.id.tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; //这里tab可能为null 根据实际情况处理吧 mTabLayout.getTabAt(i).setText("Tab" + i); //设置图片icon mTabLayout.getTabAt(i).setIcon(R.mipmap.ic_launcher); &#125; &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 这里的demo代码和Android TabLayout系列之简单使用中的一致，只是增加了 mTabLayout.getTabAt(i).setIcon(R.mipmap.ic_launcher)来设置TabView中Tab的图片。这里显示效果是官方提供的默认实现，TabView继承至Linearlayout且被设置成了竖直方向。这点可以从TabView的构造器中看到：1234567public TabView(Context context) &#123; super(context); ...... setGravity(Gravity.CENTER); setOrientation(VERTICAL); //设置成竖直方向 ......&#125; 至于为什么显示在第一个，可以从TabView的update方法了解到：1234567891011121314151617181920212223242526272829303132333435final void update() &#123; final Tab tab = mTab; final View custom = tab != null ? tab.getCustomView() : null; ...... ...... if (mCustomView == null) &#123; // If there isn't a custom view, we'll us our own in-built layouts if (mIconView == null) &#123; ImageView iconView = (ImageView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_icon, this, false); addView(iconView, 0); //将ImageView放在了LinearLayout的0位 mIconView = iconView; &#125; if (mTextView == null) &#123; TextView textView = (TextView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_text, this, false); addView(textView); //添加TextView mTextView = textView; mDefaultMaxLines = TextViewCompat.getMaxLines(mTextView); &#125; TextViewCompat.setTextAppearance(mTextView, mTabTextAppearance); if (mTabTextColors != null) &#123; mTextView.setTextColor(mTabTextColors); &#125; updateTextAndIcon(mTextView, mIconView); //更新文本和icon &#125; else &#123; // Else, we'll see if there is a TextView or ImageView present and update them if (mCustomTextView != null || mCustomIconView != null) &#123; updateTextAndIcon(mCustomTextView, mCustomIconView); &#125; &#125; // Finally update our selected state setSelected(tab != null &amp;&amp; tab.isSelected());&#125; 这里面的TabView是没有get方法的，所以我们取不到，可以通过反射拿到做一些需要的操作，就不验证了，因为我们这里是需要自定义TabView。 4 自定义带图片的Tab看源码或API的话可以知道Tab有个setCustomView(@Nullable View view)方法，可用于添加自定义的TabItem。 首先得来个TabItem的Layout Resource文件： 12345678910111213141516171819202122&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/text_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:text="Tab1" android:textSize="14sp"/&gt; &lt;ImageView android:id="@+id/image_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginBottom="0dp" android:src="@mipmap/ic_indicator"/&gt;&lt;/LinearLayout&gt; 其次在我们的Activity实现我们的效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class MainActivity extends BaseActivity implements TabLayout.OnTabSelectedListener &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(R.id.tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; TabLayout.Tab tab = mTabLayout.getTabAt(i); if (tab == null) return; //设置自定义的View tab.setCustomView(mAdapter.getTabView(i)); &#125; //需要自己实现选中监听，来实现自己需要的效果 mTabLayout.addOnTabSelectedListener(this); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; @Override public void onTabSelected(TabLayout.Tab tab) &#123; //Toast.makeText(this, "onTabSelected", Toast.LENGTH_SHORT).show(); changeTabStatus(tab, true); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; //Toast.makeText(this, "onTabUnselected", Toast.LENGTH_SHORT).show(); changeTabStatus(tab, false); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; //Toast.makeText(this, "onTabReselected", Toast.LENGTH_SHORT).show(); new AlertDialog.Builder(this) .setMessage("再次选中，显示对话框！") .show(); &#125; private void changeTabStatus(TabLayout.Tab tab, boolean selected) &#123; View view = tab.getCustomView(); TextView txtTitle = (TextView) view.findViewById(R.id.text_title); if (selected) &#123; txtTitle.setTextColor(Color.parseColor("#03ce97")); &#125; else &#123; txtTitle.setTextColor(Color.parseColor("#333333")); &#125; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; //自定义获取Tab View的方法 public View getTabView(int position) &#123; View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.custom_tab_item, null); TextView tv = (TextView) view.findViewById(R.id.text_title); tv.setText("Tab " + position); return view; &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 从效果图上看，已经实现了自定义的TabItem，需要注意的是需要根据Tab的选中状态来，实现自己想要的效果，包括Tab字体颜色的改变，图标的旋转效果，选中Tab放大等等…… 我这里只实现了文字颜色的改变，和再次选中弹出对话框。如果我们只是需要图文显示，我们不自定义TabItem也可以实现类似这种效果，直接在getPageTitle中使用ImageSpan让文字和图片一起显示。12345678910//TabLayout会根据当前page的title自动绑定tab@Overridepublic CharSequence getPageTitle(int position) &#123; Drawable image = ContextCompat.getDrawable(MainActivity.this, R.mipmap.ic_indicator); image.setBounds(0, 0, image.getIntrinsicWidth(), image.getIntrinsicHeight()); ImageSpan imageSpan = new ImageSpan(image, ImageSpan.ALIGN_BOTTOM); SpannableString ss = new SpannableString("Tab" + position + " "); ss.setSpan(imageSpan, ss.length() - 1, ss.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); return ss;&#125; 5 源码分析实现上述效果不分析波源码都不够装13的，其实也不是我想分析，只是偶然看到，然后使用了一下感觉并不是很灵活，不太明白官方为什么要这样做。网上有很多分析TabLayout，关于这个自定义TabItem源码，但是没有看见分析这一段的。有兴趣的可以跟着看看，直接跟踪Tab的setCustomView，找到TabView的update方法，代码不长60来行：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final void update() &#123; final Tab tab = mTab; //获取Tab里面的CustomView final View custom = tab != null ? tab.getCustomView() : null; //根据获取出来的custom做相应操作，得到最终的CustomView if (custom != null) &#123; final ViewParent customParent = custom.getParent(); if (customParent != this) &#123; if (customParent != null) &#123; ((ViewGroup) customParent).removeView(custom); &#125; addView(custom); &#125; mCustomView = custom; //custom不为空，且判断和处理系统本身的mTextView、mIconView if (mTextView != null) &#123; mTextView.setVisibility(GONE); &#125; if (mIconView != null) &#123; mIconView.setVisibility(GONE); mIconView.setImageDrawable(null); &#125; //注意这里！！！从custom去获取ID为android.R.id.text1 //我猜想系统是想让我们自定义CustomView的时候使用这个id mCustomTextView = (TextView) custom.findViewById(android.R.id.text1); if (mCustomTextView != null) &#123; mDefaultMaxLines = TextViewCompat.getMaxLines(mCustomTextView); &#125; //注意这里！！！从custom去获取ID为android.R.id.icon //我猜想系统是想让我们自定义CustomView的时候使用这个id mCustomIconView = (ImageView) custom.findViewById(android.R.id.icon); &#125; else &#123; //这里注释很清楚了，就不多说了 // We do not have a custom view. Remove one if it already exists if (mCustomView != null) &#123; removeView(mCustomView); mCustomView = null; &#125; mCustomTextView = null; mCustomIconView = null; &#125; //接下来就是判断CustomView做一些操作了 if (mCustomView == null) &#123; //这里的意思是没有自定义的，就创建默认的 // If there isn't a custom view, we'll us our own in-built layouts if (mIconView == null) &#123; ImageView iconView = (ImageView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_icon, this, false); addView(iconView, 0); mIconView = iconView; &#125; if (mTextView == null) &#123; TextView textView = (TextView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_text, this, false); addView(textView); mTextView = textView; mDefaultMaxLines = TextViewCompat.getMaxLines(mTextView); &#125; TextViewCompat.setTextAppearance(mTextView, mTabTextAppearance); if (mTabTextColors != null) &#123; //设置文本颜色（选中和未选中） mTextView.setTextColor(mTabTextColors); &#125; //更新文本和图标 updateTextAndIcon(mTextView, mIconView); &#125; else &#123; // Else, we'll see if there is a TextView or ImageView present and update them if (mCustomTextView != null || mCustomIconView != null) &#123; //更新文本和图标 updateTextAndIcon(mCustomTextView, mCustomIconView); &#125; &#125; // Finally update our selected state setSelected(tab != null &amp;&amp; tab.isSelected());&#125; 关于源码的分析都注释在代码里，对应着代码看，更加清晰。通过源码分析，系统好像想让我们使用那两个id（如果只有TextView和ImageView的话），这样的话是不是我们就不用处理一些逻辑了，使用起来更加easy了呢？答案当然是否定的，我测试的效果是文本的颜色不会根据TabLayout里面设置的一样改变，而且图标距底部有一个8dp的margin值。为什么呢？文本颜色不变从上面那段代码可以看出来，当我们有CustomView时，并没有给我们调用相应的setTextColor。底边距就得继续看updateTextAndIcon方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void updateTextAndIcon(@Nullable final TextView textView, @Nullable final ImageView iconView) &#123; //下面一段没什么好说的，就是获取Drawable 和CharSequence并设置显示或隐藏 final Drawable icon = mTab != null ? mTab.getIcon() : null; final CharSequence text = mTab != null ? mTab.getText() : null; final CharSequence contentDesc = mTab != null ? mTab.getContentDescription() : null; if (iconView != null) &#123; if (icon != null) &#123; iconView.setImageDrawable(icon); iconView.setVisibility(VISIBLE); setVisibility(VISIBLE); &#125; else &#123; iconView.setVisibility(GONE); iconView.setImageDrawable(null); &#125; iconView.setContentDescription(contentDesc); &#125; final boolean hasText = !TextUtils.isEmpty(text); if (textView != null) &#123; if (hasText) &#123; textView.setText(text); textView.setVisibility(VISIBLE); setVisibility(VISIBLE); &#125; else &#123; textView.setVisibility(GONE); textView.setText(null); &#125; textView.setContentDescription(contentDesc); &#125; if (iconView != null) &#123; //获取出layout参数 MarginLayoutParams lp = ((MarginLayoutParams) iconView.getLayoutParams()); int bottomMargin = 0; if (hasText &amp;&amp; iconView.getVisibility() == VISIBLE) &#123; /这里说得很清楚，如果两者都显示，就给icon的bottom加一些底边距 // If we're showing both text and icon, add some margin bottom to the icon bottomMargin = dpToPx(DEFAULT_GAP_TEXT_ICON); //8dp &#125; //判断它加的一些底边距和布局设置的不一致，就使用它加的，并请求重绘 if (bottomMargin != lp.bottomMargin) &#123; lp.bottomMargin = bottomMargin; iconView.requestLayout(); &#125; &#125; if (!hasText &amp;&amp; !TextUtils.isEmpty(contentDesc)) &#123; setOnLongClickListener(this); &#125; else &#123; setOnLongClickListener(null); setLongClickable(false); &#125;&#125; 实际效果就不给出了，还是大家手动测测，关于布局将TextView和ImageView的id改为@android:id/text1和@android:id/icon就OK了。需要注意的是还得手动在代码里设置上文本的颜色和根据需求的MarginLayoutParams，下面直接给出代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MainActivity extends BaseActivity implements TabLayout.OnTabSelectedListener &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(R.id.tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; TabLayout.Tab tab = mTabLayout.getTabAt(i); if (tab == null) return; //设置自定义的View tab.setCustomView(R.layout.custom_tab_item); tab.setText("Tab" + i); tab.setIcon(R.mipmap.ic_indicator); View customView = tab.getCustomView(); if (customView == null) return; //注意设置了文本颜色和MarginLayoutParams ((TextView) customView.findViewById(android.R.id.text1)).setTextColor(mTabLayout.getTabTextColors()); View icon = customView.findViewById(android.R.id.icon); ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) icon.getLayoutParams(); layoutParams.bottomMargin = 0; icon.setLayoutParams(layoutParams); &#125; //需要自己实现选中监听，来实现自己需要的效果 mTabLayout.addOnTabSelectedListener(this); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; @Override public void onTabSelected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; new AlertDialog.Builder(this) .setMessage("再次选中，显示对话框！") .show(); &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 废话太多了，原生TabLayout使用就这么多，源码中真是变化万千。如果希望实现更多酷炫效果，可以自定义或者GitHub….. 附： Android TabLayout系列之属性 Android TabLayout系列之简单使用 Android TabLayout系列之进阶使用]]></content>
      <categories>
        <category>Android</category>
        <category>TabLayout</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TabLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TabLayout系列之简单使用]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-TabLayout%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1 前言在上一篇 Android TabLayout系列之属性 中我们介绍了TabLayout的属性，同时也给出了一些简单的效果图。但是没有具体到它的使用，今天就来看看TabLayout的简单使用。不知道大家留意到我们仿网易的效果布局中，我们明明是写的小写字母，字母就变成大写了，还有字体大小能改变否？我们一步一步来解决这些问题…… 2 使用介绍一种在实际开发中TabLayout较为常用的方式，那就是和ViewPager配合使用，实现联动。首先看看xml布局：1234567891011121314151617181920212223&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabBackground="@android:color/white" app:tabIndicatorColor="@android:color/holo_red_light" app:tabIndicatorHeight="2dp" app:tabMode="scrollable" app:tabSelectedTextColor="@android:color/holo_red_light" app:tabTextColor="@android:color/darker_gray"/&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 是不是很简单的布局，就只有一个TabLayout和ViewPager垂直排列，其实这个还不是官方的布局样式，官方的是这样的：12345678910111213141516171819202122232425&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabBackground="@android:color/white" app:tabIndicatorColor="@android:color/holo_red_light" app:tabIndicatorHeight="2dp" app:tabMode="scrollable" app:tabSelectedTextColor="@android:color/holo_red_light" app:tabTextColor="@android:color/darker_gray"/&gt; &lt;android.support.v4.view.ViewPager/&gt;&lt;/LinearLayout&gt; 第一种是我们常见到的，第二种是官方的，两种的区别是官方这种写法不用调用setupWithViewPager方法。接下来我们看看Activity的代码怎么实现的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(R.id.viewPager); for (int i = 0; i &lt; 11; i++) &#123; //为TabLayout添加10个tab并设置上文本 mTabLayout.addTab(mTabLayout.newTab().setText("Tab " + i)); &#125; mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 接下来是BlankFragment的实现：12345678910111213141516171819202122232425public class BlankFragment extends Fragment &#123; private int index; public BlankFragment() &#123; // Required empty public constructor &#125; public static Fragment newInstance(int position) &#123; BlankFragment fragment = new BlankFragment(); fragment.index = position; return fragment; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_blank, container, false); &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); ((TextView) view.findViewById(R.id.textView)).setText("this Tab " + index); &#125;&#125; 这里需要先解释newTab，这个newTab是使用TabLayout中默认的Tab实现。从它的实现可以看到它支持设置图标，标题和内容描述（图标描述）。1234567891011121314151617181920 public static final class Tab &#123; /** * An invalid position for a tab. * * @see #getPosition() */ public static final int INVALID_POSITION = -1; private Object mTag; private Drawable mIcon; private CharSequence mText; private CharSequence mContentDesc; private int mPosition = INVALID_POSITION; private View mCustomView; TabLayout mParent; TabView mView;..... &#125; Tab默认图标在标题的上方，还有xml里面设置TabItem的话，最终也是设置到Tab上。关于Tab就说明这些，具体的大家可以自行测试。可以看到关于TabLayout的实现也很简单，就是给布局里面的TextView设置了文本显示当前是第几个Tab。布局就更简单了，FrameLayout中嵌套了一个TextView，就不单独给出了。接下来我们就可以来瞅一瞅实际的使用效果了。 3 “填坑”与源码解析 源码解析看到上面的效果图是不是觉得很怪异？没错，我们所设置的Tab上的文字没了，只有下面的指示条。相信大家一通搜索后，相信大家都知道了，最常见的就是分析源码后得出结论，被remove了！！！接下来我们也来装下文化人，看看怎么回事？首先是TabLayout的setupWithViewPager方法，一顿单击后会到达如下源码位置：1234567891011121314151617181920212223242526272829303132private void setupWithViewPager(@Nullable final ViewPager viewPager, boolean autoRefresh, boolean implicitSetup) &#123; if (mViewPager != null) &#123; // If we've already been setup with a ViewPager, remove us from it if (mPageChangeListener != null) &#123; mViewPager.removeOnPageChangeListener(mPageChangeListener); &#125; if (mAdapterChangeListener != null) &#123; mViewPager.removeOnAdapterChangeListener(mAdapterChangeListener); &#125; &#125;............ if (adapter != null) &#123; // Now we'll populate ourselves from the pager adapter, adding an observer if // autoRefresh is enabled setPagerAdapter(adapter, autoRefresh); &#125;............ // Now update the scroll position to match the ViewPager's current item setScrollPosition(viewPager.getCurrentItem(), 0f, true); &#125; else &#123; // We've been given a null ViewPager so we need to clear out the internal state, // listeners and observers mViewPager = null; setPagerAdapter(null, false); &#125; mSetupViewPagerImplicitly = implicitSetup; &#125; 这里没什么说的就是设置判断移除、设置监听等操作，我们最主要去找到网上最多叙述问题所在的源码位置，接下来我们看setPagerAdapter：12345678910111213141516171819void setPagerAdapter(@Nullable final PagerAdapter adapter, final boolean addObserver) &#123; if (mPagerAdapter != null &amp;&amp; mPagerAdapterObserver != null) &#123; // If we already have a PagerAdapter, unregister our observer mPagerAdapter.unregisterDataSetObserver(mPagerAdapterObserver); &#125; mPagerAdapter = adapter; if (addObserver &amp;&amp; adapter != null) &#123; // Register our observer on the new adapter if (mPagerAdapterObserver == null) &#123; mPagerAdapterObserver = new PagerAdapterObserver(); &#125; adapter.registerDataSetObserver(mPagerAdapterObserver); &#125; // Finally make sure we reflect the new adapter populateFromPagerAdapter();&#125; 这段代码主要是判断之前的mPagerAdapter是否为空，不为空就移除DataSetObserver监听，将新的adapter设置进来并注册上DataSetObserver监听。这里我们捕获方法populateFromPagerAdapter一枚，我们再看看它的实现：12345678910111213void populateFromPagerAdapter() &#123; removeAllTabs(); if (mPagerAdapter != null) &#123; final int adapterCount = mPagerAdapter.getCount(); for (int i = 0; i &lt; adapterCount; i++) &#123; addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false); &#125; // Make sure we reflect the currently set ViewPager item ...... &#125;&#125; 哇塞！removeAllTabs，大家说得最多的一个方法，观看方法名就很吓人了，remove all tabs….看看它到底干了什么：123456789101112131415public void removeAllTabs() &#123; // Remove all the views for (int i = mTabStrip.getChildCount() - 1; i &gt;= 0; i--) &#123; removeTabViewAt(i); &#125; for (final Iterator&lt;Tab&gt; i = mTabs.iterator(); i.hasNext();) &#123; final Tab tab = i.next(); i.remove(); tab.reset(); sTabPool.release(tab); &#125; mSelectedTab = null;&#125; 它果真和它的命名一样，遍历remove了所有的tab，并且将当前选中也置为null。怎么办？难道Google故意留下这么个坑？我们继续看上面的populateFromPagerAdapter，会发现removeAllTabs后，它会判断adapter是否为空，不为空就调用了addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false)添加上了新的tab。 “填坑”思路 从上面的分析，我们发现如果要有tab还得去重写adapter的getPageTitle方法。再看一段官方文档中的说明： If you’re using a ViewPager together with this layout, you can call setupWithViewPager(ViewPager)to link the two together. This layout will be automatically populated from the PagerAdapter‘s page titles. 就是说官方推荐我们使用setupWithViewPager(ViewPager)来关联Tablayout和Viewpager，且TabLayout会自动填充PagerAdapter的Title。也就是说它会自动创建tab，并绑定为adapter的page title。这下我们来改造下Activity：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; //TabLayout会根据当前page的title自动绑定tab @Override public CharSequence getPageTitle(int position) &#123; return "Tab " + position; &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 这就是新的Activity实现，改动很小。我们首先删除了initView中关于tab的初始化操作，然后重写了FragmentPagerAdapter的getPageTitle方法。 我们既然知道他会自动为我们绑定tab，那么我们可以利用它自动帮我绑定tab，而不去重写getPageTitle方法，在绑定后去设置关于tab的显示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; //这里tab可能为null 根据实际情况处理吧 mTabLayout.getTabAt(i).setText("Tab" + i); &#125; &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 可以看到只是将initView中初始化Tab的位置调整到setupWithViewPager的后面，设置上我们需要的标题。这里效果和上面一样就不给出来占篇幅了。 上面我们依旧利用了setupWithViewPager自动为我们绑定tab的实现，在分析源码的时候发现它会调用ViewPager的addOnPageChangeListener和TabLayout的addOnTabSelectedListener，实现TabLayout与ViewPager的关联。那么我们就自己来实现关联，不去使用官方推荐的setupWithViewPager方法绑定。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //初始化tab for (int i = 0; i &lt; 10; i++) &#123; mTabLayout.addTab(mTabLayout.newTab().setText("item" + i)); &#125; //自己实现关联 mViewPager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(mTabLayout)); mTabLayout.addOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(mViewPager)); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 这段代码，在initView中移除了官方推荐的设置相关代码，自己初始化了tab并实现了关联。注意这里我们改变了Tab的标题作为区分。效果也和上面一样，只是改变了Tab的标题。 4 其他问题这样TabLayout的简单使用就介绍完了，这里还有两个问题一个是TabLayout的标题怎么就是大写了，还有它的文字大小怎么改呢？还记得我怎么在上一篇Android TabLayout系列之属性中介绍的tabTextAppearance属性么？我们就利用它来改变标题字母大小写和文字大小问题。先开看看TabLayout源码中的默认使用：123456789mTabTextAppearance = a.getResourceId(R.styleable.TabLayout_tabTextAppearance,R.style.TextAppearance_Design_Tab);&lt;style name="TextAppearance.Design.Tab" parent="TextAppearance.AppCompat.Button"&gt; &lt;item name="android:textSize"&gt;@dimen/design_tab_text_size&lt;/item&gt; &lt;item name="android:textColor"&gt;?android:textColorSecondary&lt;/item&gt; &lt;item name="textAllCaps"&gt;true&lt;/item&gt;&lt;/style&gt; 我们为Tablayout添加上tabTextAppearance属性：1app:tabTextAppearance="@style/TabLayoutStyle" 这里需要把具体的属性定义到stytle中，这里有两种方式：1234&lt;style name="TabLayoutStyle" parent="TextAppearance.Design.Tab"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; &lt;item name="textAllCaps"&gt;false&lt;/item&gt;&lt;/style&gt; 12345&lt;style name="TabLayoutStyle"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; //&lt;item name="textAllCaps"&gt;false&lt;/item&gt; &lt;item name="android:textAllCaps"&gt;false&lt;/item&gt;&lt;/style&gt; 需要注意 parent=”TextAppearance.Design.Tab”时，textAllCaps没有android，当不继承的时候有没有都可以。其实这里的字母大小写，不能算个坑。我们可以看material设计中所有tab的字母都是大写，估计歪果仁标题都习惯大写吧，或者是为了符合material设计，所以默认的Tab被设置成了大写。最后运行效果如下： 这里附上我的build.gradle，有可能不同版本会有不一样的效果，所以大家实际使用的时候需要注意一下：123456789101112131415161718192021android &#123; compileSdkVersion 25 buildToolsVersion "25.0.1" defaultConfig &#123; applicationId "com.joker.demo" minSdkVersion 19 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; TabLayou的简单使用就介绍这么多，其实真的是简单使用，主要是中间插入了一段源码分析，所以看起来多了点。附： Android TabLayout系列之属性 Android TabLayout系列之简单使用 Android TabLayout系列之进阶使用]]></content>
      <categories>
        <category>Android</category>
        <category>TabLayout</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TabLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TabLayout系列之属性]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-TabLayout%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1 前言以前没有写博客的习惯，需要什么东西都是直接搜索，然后再来看怎么使用，有什么需要注意的，时间久了也就忘了是怎么回事了，又得重复这个过程。比如这个今天要介绍的TabLyout，很久之前用过，最近又需要用到，但是已经忘了怎么使用了，这也是为什么最近开始在简书上开始记录的原因。废话不多说…其实Android在5.1（22.2.0）的时候给我们提供了一个水平布局来显示标签TabLayout，实际应用中也有很多需要横向标签的应用场景。直接先来看个效果图（偷的网易的）： 2 TabLayout简单使用今天这篇文章是奔着TabLayout的属性来的，就用最简单的使用方式来介绍它的属性。我们在xml文件中直接使用TabLayout：1234567891011121314151617181920&lt;android.support.design.widget.TabLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab1"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab2"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab3"/&gt;&lt;/android.support.design.widget.TabLayout&gt; 看上去还是有那么点标签的意思…接下来就正式介绍它的属性了。 3 属性介绍 背景颜色 1app:tabBackground="@android:color/white" 选中tab字体颜色 1app:tabSelectedTextColor="@android:color/holo_red_light" 未选中tab字体颜色 1app:tabTextColor="@android:color/holo_blue_dark" 指示器颜色 1app:tabIndicatorColor="@android:color/holo_green_dark" 设置完演的后的TabLayout: 指示器高度1app:tabIndicatorHeight="5dp" tabY轴偏移量（没看出效果） 1app:tabContentStart="100dp" tab显示方式 1app:tabGravity="center" //center：居中 fill：充满 tab最大最小宽度 12app:tabMaxWidth="100dp"app:tabMinWidth="100dp" tab布局模式 1app:tabMode="scrollable" //可取fixed 固定,scrollable 滚动，默认fixed：标签很多时候会被挤压，不能滑动。 Tab里内容的内边距 12345app:tabPadding="10dp"app:tabPaddingStart="10dp"app:tabPaddingEnd="10dp"app:tabPaddingTop="10dp"app:tabPaddingBottom="10dp" tab文字大小设置 1app:tabTextAppearance="@style/Base.TextAppearance.AppCompat.Large" 以上就是TabLayout的基本属性，接下来我们用这些基本属性实现一个类似文章开头的效果:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabBackground="@android:color/white" app:tabIndicatorColor="@android:color/holo_red_light" app:tabIndicatorHeight="2dp" app:tabMode="scrollable" app:tabSelectedTextColor="@android:color/holo_red_light" app:tabTextColor="@android:color/darker_gray"&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab1"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab2"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab3"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab4"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab5"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab6"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab7"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab8"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab9"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab10"/&gt; &lt;/android.support.design.widget.TabLayout&gt;&lt;/android.support.v4.view.ViewPager&gt; TabLayout属性就介绍到这里，接下来的文章会具体介绍它的使用。 附： Android TabLayout系列之属性 Android TabLayout系列之简单使用 Android TabLayout系列之进阶使用]]></content>
      <categories>
        <category>Android</category>
        <category>TabLayout</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TabLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的线程池与队列]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Android中的线程池来源于Java中的Executor接口，真正的线程池实现为ThreadPoolExecutor，它提供参数来配置线程池。既然提到线程池，首先得了解线程池有什么有点，线程池的优点主要有以下3点： 线程重用，通过重用线程池中线程避免反复创建和销毁县城带来的性能开销问题。 控制并发数，避免大量线程同时工作抢占系统资源造成阻塞。 简单的线程管理，实现定时执行等功能。 一 ThreadPoolExecutor1) ThreadPoolExecutor 构造器1234567891011//使用给定的参数和默认线程工厂、拒绝执行的Handler创建一个新的ThreadPoolExecutor ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) //使用给定的参数和拒绝执行的Handler创建一个新的ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)//使用给定的参数和默认线程工厂创建一个新的ThreadPoolExecutorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)//使用给定的参数创建一个新的ThreadPoolExecutorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 2) ThreadPoolExecutor 构造器参数说明 corePoolSize 核心线程数（常驻线程数）一直保持在线程池的线程数，空闲状态也不会退出，除非设置allowCoreThreadTimeOut为true maximumPoolSize 最大线程数线程池中允许存在的最大线程数 keepAliveTime 保持活跃时间当线程数大于核心线程数时，这是超出空闲线程在终止之前等待新任务的最大时间。当allowCoreThreadTimeOut为true时，也适用与核心线程 unit 单位keepAliveTime参数的时间单位 workQueue 任务队列在执行任务之前用于保存任务的队列。 该队列将仅保存由（Runnable的execute）方法提交的任务。 threadFactory 线程工厂executor创建新线程的时候使用 handler 拒绝执行的handler当线程池无法执行新任务，导致执行被阻止时使用的处理程序，可能因为线程达到线程限制和队列容量 3) ThreadPoolExecutor执行任务时大致规则 线程池中线程数小于核心线程数，会直接启动一个核心线程来执行新任务 线程池中线程数大于等于核心线程数， 将会将新任务存放到任务队列等待执行 线程池中线程数大于等于核心线程数，且任务队列已满，但线程池中线程数小于最大线程数，将会启动一个非核心线程来执行任务 线程池中线程数大于等于最大线程数，那么就会拒绝执行该任务，调用handler的rejectedException来通知调用者 4) ThreadPoolExecutor在AsyncTask中的使用123456789101112131415161718192021222324private static final String LOG_TAG = "AsyncTask";private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 通过源码，我们可以看到AsyncTask的THREAD_POOL_EXECUTOR属性配置如下： 核心线程数（CORE_POOL_SIZE）为CPU核心数+1 最大线程数（MAXIMUM_POOL_SIZE）为CPU核心数 * 2 + 1 非核心线程保持活跃时间为1，单位为秒 任务队列容量为128 以上对ThreadPoolExecutor和AsyncTask中的ThreadPoolExecutor配置进行了介绍。在Android中通过对ThreadPoolExecutor的配置实现了四类不同功能特性的线程池，接下来我们就对Android中的这四类线程池进行一个简单介绍 二 FixedThreadPool通过Executors.newFixedThreadPool创建一个线程池，它使用固定数量的线程操作了共享无界队列。在任何时候，大多数线程都是主动处理任务的。如果在所有线程处于活动状态时提交其他任务，则它们将在队列中等待，直到有线程空闲可用为止。如果任何线程在关闭前在执行过程中失败，如果需要执行后续任务，则新线程将取代它。线程池中线程会一致存在，直到线程池明确关闭（shutdown）。下面是它的实现，可以看到它只有不会被回收的核心线程，队列大小也没有限制。12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 三 CachedThreadPool通过Executors.newCachedThreadPool创建一个线程池，根据需要创建新线程，但在可用线程时将重用以前构建的线程。这些池通常会提高执行许多短期异步任务的程序的性能。如果先前创建线程可用的话，调用将重用先前构建的线程。如果没有现有的线程可用，一个新线程将被创建并添加到池。未使用六十秒的线程被终止并从缓存中移除。因此，空闲时间足够长的池不会消耗任何系统资源。下面是它的实现，可以看到与ThreadPoolExecutor不同的是它没有核心线程，最大线程数为Integer.MAX_VALUE，且CachedThreadPool的任务队列是一个SynchronousQueue的空集合，这将导致任务会被立即执行，所以这类线程比较适合执行大量耗时较少的任务。12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 四 ScheduledThreadPool通过Executors.newScheduledThreadPoo创建一个线程池，可以在给定延迟后调度命令运行，或定期执行命令。它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 五 newSingleThreadScheduledExecutor通过Executors.newSingleThreadScheduledExecutor创建一个单线程执行器，可以在给定延迟后调度命令运行，或定期执行命令。任务是按顺序执行的，在任何给定的时间内都不会有一个任务处于活动状态，让调用者可以忽略线程同步问题。123456789public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 六 线程池一般用法 shutDown()，关闭线程池，需要执行完已提交的任务 shutDownNow()，关闭线程池，并尝试结束已提交的任务 allowCoreThreadTimeOut(boolen)，允许核心线程闲置超时回收 execute()，提交任务无返回值 submit()，提交任务有返回值 除了上面4种线程池，还可以根据实际需求自定义线程池。 七 自定义线程池1ExecutorService mExecutor = Executors.newFixedThreadPool(5); execute()方法，接收一个Runnable对象作为参数，异步执行。1234567Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; Log.i("myRunnable", "run"); &#125;&#125;;mExecutor.execute(myRunnable); 八 队列简述Queue的成员函数 add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 remove、element、offer 、poll、peek 其实是属于Queue接口。 LinkedBlockingQueue是一个链表实现的阻塞队列，在链表一头加入元素，如果队列满，就会阻塞，另一头取出元素，如果队列为空，就会阻塞。 LinkedBlockingQueue内部使用ReentrantLock实现插入锁(putLock)和取出锁(takeLock)。putLock上的条件变量是notFull，即可以用notFull唤醒阻塞在putLock上的线程。takeLock上的条件变量是notEmtpy，即可用notEmpty唤醒阻塞在takeLock上的线程。 知道了LinkedBlockingQueue，再来理解ArrayBlockingQueue就比较好理解了。类似LinkList和ArrayList的区别。如果知道队列的大小，那么使用ArrayBlockIngQueue就比较合适了，因为它使用循环数组实现，但是如果不知道队列未来的大小，那么使用ArrayBlockingQueue就必然会导致数组的来回复制，降低效率。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 从入门到实战 学习笔记]]></title>
    <url>%2F2018%2F01%2F02%2FGradle-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Gradle是目前为止Android的主流构建工具，不管用命令行还是Android Studio来build项目，Gradle都不可或缺。Gradle不单单是一个配置脚本，更是Groovy Language、Gradle DSL、Android DSL 3门语言的组合( DSL的全称是Domain Specific Language，即领域特定语言 )。学习来源Gradle从入门到实战 - Groovy基础，学习主要内容如下： Groovy基础 全面理解Gradle 分析Android的build tools插件 从0到1完成一款Gradle插件 一 Groovy基础通过def关键字声明变量和方法：12345678def a = 1;def b = "hello";def int c = 2;def hello() &#123; println ("hello world!"); return 1;&#125; 在Groovy中语法中，很多地方可以省略： 语句后面的分号可以省略 变量类型可以省略 方法的参数类型和返回值可以省略 方法调用括号可以省略 方法中return关键字也可以省略 所以上面代码这样写也是正确的：1234567891011121314151617181920212223def a = 1 //省略分号def b = "hello"def c = 2def hello() &#123; println "hello world!" //省略调用时括号 1 //省略return&#125;def hello(String msg)&#123; println msg&#125;int hello(msg)&#123; //省略参数类型 println (msg) return 1&#125;int hello(msg)&#123; println msg return 1 // 这个return不能省略 println "done"&#125; 总结 在Groovy中，类型是弱化的，所有的类型都可以动态推断，但是Groovy仍然是强类型的语言，类型不匹配仍然会报错 在Groovy中很多东西都可以省略，所以寻找一种自己喜欢的写法 Groovy中的注释和Java中相同 二 Groovy的数据类型在Groovy中，数据类型有： Java中的基本数据类型 Java中的对象 Closure（闭包） 加强的List、Map等集合类型 加强的File、Stream等IO类型 类型可以显示声明，也可以用 def 来声明，用 def 声明的类型Groovy将会进行类型推断 String 12345def a = 1def b = "hello"def c = "a = $&#123;a&#125;, b = $&#123;b&#125;"println c outputs: a = 1, b = hello 闭包(Closure)闭包在很多语言都存在，类似于C语言的指针。闭包作为一种特殊的数据类型而存在，闭包可以作为方法的参数和返回值，也可以作为一个变量 声明闭包：1234&#123; parameters -&gt; code&#125; 闭包可以有返回和参数，也可以没有。看看以下例子：123456789101112131415161718192021def closure = &#123; int a, String b -&gt; println "a = $&#123;a&#125;, b = $&#123;b&#125;, This is a Closure!"&#125;def test = &#123; a, b -&gt; println "a = $&#123;a&#125;, b = $&#123;b&#125;, This is a Closure!"&#125;def sum = &#123; a, b -&gt; a + b&#125;// 这里省略了闭包的参数类型def testIt = &#123; println "find $&#123;it&#125;, This is a Closure!"&#125;closure(100, 200)test.call(100, "test")println sum(100, 200)testIt(100) 闭包不指定参数，那么会隐含一个参数it,闭包可以当做函数一样使用，上例将得到以下输出：1234a = 100, b = 200, This is a Closure!a = 100, b = test, This is a Closure!300find 100, This is a Closure! 闭包的一个难题是如何确定闭包的参数，尤其当我们调用Groovy的API时，这个时候没有其他办法，只有查询Groovy的文档：http://www.groovy-lang.org/api.htmlhttp://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html List和Map 123456789def emptyList = []def test = [100, "hello", true]test[1] = "world"test &lt;&lt; 200println test.sizeprintln test[0]println test[1]println test[2]println test[3] outputs: 100 world true 200 上例中操作符&lt;&lt;，表示向List中新增加元素123456def emptyMap = [:]def test = ["id":1, "name":"test", "isMale":true]test["id"] = 2test.id = 900println test.idprintln test.isMale outputs: 900 true 通过闭包对Map进行遍历，如果闭包传递2个参数就是遍历key，value；如果不传参就是遍历entry：12345678def emptyMap = [:]def test = ["id":1, "name":"test", "isMale":true]test.each&#123; key, value -&gt; println "two params, key = $&#123;key&#125;, value = $&#123;value&#125;"&#125;test.each&#123; println "one param, key = $&#123;it.key&#125;, value = $&#123;it.value&#125;"&#125; 文件I/OGroovy在使用I / O时提供了许多辅助方法，让文件操作比java中简单很多。下面举例，具体使用请查阅API： 1234567891011def file = new File("E:/Example.txt")println "-------------------------------"file.eachLine&#123; line -&gt; //一行一行读取文件 println "read line: $line"&#125;println "-------------------------------"file.eachLine&#123; line, lineNum -&gt; println "read line $&#123;lineNum&#125;: $line"&#125;println "-------------------------------"println file.text //将文本以字符串读取 outputs: ------------------------------- read line: hello read line: 你好 ------------------------------- read line 1: hello read line 2: 你好 ------------------------------- hello 你好 接下来看看xml文件访问，也是比Java中简单多了Groovy访问xml有两个类：XmlParser和XmlSlurper，二者几乎一样，在性能上有细微的差别，具体的也请查看具体API。接下来看看示例，首先假设我们有attrs.xml文件：1234567&lt;resources&gt;&lt;declare-styleable name="CircleView"&gt; &lt;attr name="circle_color" format="color"&gt;#98ff02&lt;/attr&gt; &lt;attr name="circle_size" format="integer"&gt;100&lt;/attr&gt; &lt;attr name="circle_title" format="string"&gt;xml&lt;/attr&gt;&lt;/declare-styleable&gt;&lt;/resources&gt; 对xml文件操作12345def xml = new XmlParser().parse(new File("attrs.xml"))// 访问declare-styleable节点的name属性println xml['declare-styleable'].@name[0]// 访问declare-styleable的第三个子节点的内容println xml['declare-styleable'].attr[2].text() 123outputs：CircleViewxml 三 Groovy的其他特性 在Groovy中，如在任何其他面向对象语言中一样，存在类和对象的概念以表示编程语言的对象定向性质。 123456789101112131415class Student &#123; int id String Name static void main(String[] args) &#123; Student st = new Student(); st.id= 1 st.Name= "Joe" fun(Student .class) //参数为class类型，可省略.class后缀 fun(Student) //省略.class后缀 &#125; def func(Class clazz) &#123; &#125;&#125; 在java中使用private关键字隐藏实例成员，而是提供getter和setter方法来相应地设置和获取实例变量的值。Groovy也是一样，不一样的是Groovy中只要有属性就有getter&amp;setter，有getter&amp;setter就有隐含的属性。所以以下两个类是一样的 123456789101112131415class Student &#123; private int id void setId(int id) &#123; this.id = id &#125; int getId() &#123; return this.id &#125;&#125;class Student &#123; private int id&#125; 在Groovy中，当对同一个对象进行操作时，可以使用with操作符，比如： 1234567891011121314class Student &#123; int id String name static void main(String[] args) &#123; Student st = new Student(); st.id= 1 st.name= "Joe" //以上操作可以简化为 st.with&#123; id = 1 name = "Joe" &#125; &#125; &#125; 在Groovy中，判断是否为真可以更简洁： 123if (name != null &amp;&amp; name.length &gt; 0) &#123;&#125;//Groovy中简写if (name) &#123;&#125; 在Groovy中，更加简洁的三目运算： 1234def name = "name"def result = name != null ? name : "test"//Groovy中简写def result = name ? : "test" 非空判断 12345678910if (order != null) &#123; if (order.getCustomer() != null) &#123; if (order.getCustomer().getAddress() != null) &#123; System.out.println(order.getCustomer().getAddress()); &#125; &#125;&#125;//Groovy中简写println order?.customer?.address equals和==，Groovy中==与Java中equals一致，如果需要判断是否为同一对象需要使用.is() 12345Object a = new Object()Object b = a.clone()assert a == b //判断相等assert !a.is(b) //判断是否是同一对象 断言关键字assert的使用 1234def check(String name) &#123; assert name assert name?.size() &gt; 3 //如果断言结果为false将抛出异常&#125; 在Groovy中，switch方法更加灵活，可以同时支持更多的参数类型 123456789101112131415161718192021在Groovy中，switch方法变得更加灵活，可以同时支持更多的参数类型：def x = 1.23def result = ""switch (x) &#123; case "foo": result = "found foo" // lets fall through case "bar": result += "bar" case [4, 5, 6, 'inList']: result = "list" break case 12..30: result = "range" break case Integer: result = "integer" break case Number: result = "number" break case &#123; it &gt; 3 &#125;: result = "number &gt; 3" break default: result = "default"&#125;assert result == "number" 四 编译并运行Groovy我们可以通过下载和安装Groovy sdk来编译和运行，但是我们是为了学习Gradle，所以这里不用搞得过于复杂。推荐如下操作来编译和运行Groovy： 首先在任意文件夹创建build.gradle 在build.gradle中创建一个task 使用gradle test命令编译和运行 拿上面的一个例子（可能需要配置环境变量，请自行百度，其实和Java环境变量配置方法一致），来做一个完整示例： 1234567891011121314151617task(test).doLast &#123; println "start execute test" doTest()&#125;def doTest() &#123; def emptyList = [] def test = [100, "hello", true] test[1] = "world" test &lt;&lt; 200 println "以下是输出内容" println test.size println test[0] println test[1] println test[2] println test[3] println "--------------"&#125; 直接附上cmd命令行编译运行结果截图： 再次感谢：任玉刚 - Gradle从入门到实战]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 7.0权限适配：FileUriExposedException异常]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-7-0%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%EF%BC%9AFileUriExposedException%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[今天来聊聊Android 7.0 FileUriExposedException异常，以及它的使用方法和使用场景 一 描述 问题对于面向 Android 7.0 的应用，Android 框架执行的 StrictModeAPI 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException异常 解决方案要在应用间共享文件，您应发送一项 content://URI，并授予 URI 临时访问权限。进行此授权的最简单方式除了将targetSdkVersion改成24以下，就是使用 FileProvider类 官网对FileProvider描述： FileProvider是ContentProvider的一个特殊子类，它通过创建内容来实现与应用程序相关联的文件的安全共享：// Uri用于文件，而不是文件：/// Uri。 内容URI允许您使用临时访问权限来授予读取和写入访问权限。当您创建包含内容URI的Intent时，为了将内容URI发送到客户端应用程序，还可以调用Intent.setFlags（）来添加权限。只要接收活动的堆栈处于活动状态，客户端应用程序就可以使用这些权限。对于要访问服务的意图，只要服务正在运行，权限就可用。 相比之下，为了控制对文件的访问：/// Uri你必须修改底层文件的文件系统权限。您提供的权限可用于任何应用程序，并在您更改之前保持有效。这种访问水平基本上是不安全的。 内容URI提供的增加文件访问安全级别使FileProvider成为Android安全基础架构的关键部分。 二 如何使用FileProvider我们先看如何使用FileProvider，官网也有详细说明：https://developer.android.com/reference/android/support/v4/content/FileProvider.html 1. 定义FileProvider由于FileProvider的默认功能，包括内容URI代的文件，你不需要在代码中定义一个子类。我们在manifest中声明provider12345678910111213141516&lt;manifest&gt; ... &lt;application&gt; ... &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="包名.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; android:name 【固定值】 FileProvider的包名+类名android:authorities 【自定义】 推荐以包名+”.fileprovider”方式命名，增加辨别性，系统唯一android:exproted 要求必须为false，为true则会报安全异常android:grantUriPermissions 是否允许为文件设置临时权限 “true”android:resource=”@xml/file_paths”就是我们的共享路径配置的xml文件 2 . 配置file_pathsFileProvider只能生成你事先指定的 content URI，file_paths配置如下：1234567891011&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="external" path=""/&gt; &lt;external-path name="my_images" path="Android/data/包名/files/Pictures/"/&gt; &lt;external-path name="images" path="Pictures/"/&gt;&lt;/paths&gt; 注意： 注： XML文件是你可以指定你要共享的目录的唯一途径，你不能以编程方式添加一个目录，至少配置一个external-path节点 在paths节点内部支持以下几个子节点，分别为： 代表设备的根目录new File(“/“) 代表该文件files/的应用程序的内部存储区的子目录，等同于context.getFilesDir() 代表应用程序的内部存储区域的缓存子目录的文件，等同于context.getCacheDir() 代表在外部存储区根目录的文件，等同于Environment.getExternalStorageDirectory() 代表应用程序的外部存储区根目录的文件，等同于Context.getExternalFilesDir(String) /Context.getExternalFilesDir(null) 代表应用程序的外部缓存区根目录的文件，等同于Context.getExternalCacheDir() file_paths用来指定Uri共享和真实路径的映射关系，name属性的值可以自定义，path属性的值表示共享的具体位置，设置为空，就表示共享整个SD卡，也可指定对应的SDcard下的文件目录，根据需求自行定义 3. 获得content uri使用getUriForFile()将file:// 转换成 content:// Uri fileUri = FileProvider.getUriForFile(this, “包名.fileprovider”, file); 4. 临时读写权限授权需要对接收应用设置读权限或写权限亦或读写均设置：FLAG_GRANT_READ_URI_PERMISSION：读权限FLAG_GRANT_WRITE_URI_PERMISSION：写权限授权方式： 使用Intent.addFlags或setFlags，该方式授权的有效期限，权限截止于该 App 所处的堆栈被销毁自动回收（APP销毁），主要用于针对intent.setData，setDataAndType以及setClipData相关方式传递uri 使用grantUriPermission(String toPackage, Uri uri, int modeFlags)来进行授权，该方式授权的有效期限，从授权一刻开始，手动调用 Context.revokeUriPermission() 方法或者设备重启才截止 三 使用场景a. 相机拍照Android 7.0之前我们这样拍照，没有什么问题（忽略6.0权限问题）：1234567891011121314151617181920212223242526272829303132private static final int REQUEST_TAKE_PHOTO = 0X11;private Uri imageUri ; private void takePhoto() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); //判断是否有相机应用 if (takePictureIntent.resolveActivity(getActivity().getPackageManager()) != null) &#123; //获取存储路径 没有则创建 File directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); if (!directory.exists()) &#123; if (!directory.mkdir()) &#123; return; &#125; &#125; File file = new File(directory.getAbsolutePath(), new SimpleDateFormat("yyyyMMdd-HHmmss", Locale.CHINA) .format(new Date()) + ".jpeg"); imageUri = Uri.fromFile(file); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(takePictureIntent, TAKE_PHOTO); &#125; else &#123; ToastUtil.showShort(getString(R.string.TakePhoto_Error)); &#125;&#125;@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_TAKE_PHOTO) &#123; // 通知图库更新 getActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, imageUri )); &#125;&#125; 如果我们使用Android 7.0或者以上的原生系统运行，发现应用直接停止运行，如文章开头所说抛出了android.os.FileUriExposedException：1234android.os.FileUriExposedException: file:///storage/emulated/0/Pictures/20170723-201847.jpeg exposed beyond app through ClipData.Item.getUri() at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799) at android.net.Uri.checkFileUriExposed(Uri.java:2346) 接下来根据官网的解决办法，如第二步所说配置好 FileProvider，更改拍照方法：123456789101112131415161718192021222324252627private void takePhoto() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); //判断是否有相机应用 if (takePictureIntent.resolveActivity(getActivity().getPackageManager()) != null) &#123; //获取存储路径 没有则创建 File directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); if (!directory.exists()) &#123; if (!directory.mkdir()) &#123; return; &#125; &#125; File file = new File(directory.getAbsolutePath(), new SimpleDateFormat("yyyyMMdd-HHmmss", Locale.CHINA) .format(new Date()) + ".jpeg"); Uri uri = imageUri = Uri.fromFile(file); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //兼容7.0 uri = FileProvider.getUriForFile(getApplication(), "包名.fileprovider", file); //添加权限 这一句表示对目标应用临时授权该Uri所代表的文件 takePictureIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(takePictureIntent, TAKE_PHOTO); &#125; else &#123; ToastUtil.showShort(getString(R.string.TakePhoto_Error)); &#125; &#125; 添加了版本判断，并使用 FileProvider.getUriForFile()获得content Uri，方法主要更改如下：1234567 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //兼容7.0 uri = FileProvider.getUriForFile(getApplication(), "包名.fileprovider", file); //添加权限 这一句表示对目标应用临时授权该Uri所代表的文件 takePictureIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);&#125; 当然也可以不用判断版本，直接使用FileProvider.getUriForFile(getApplication(), “包名.fileprovider”, file)获得Uri替换Uri.fromFile(file)，但是切记需要进行授权和取消授权，否则4.4以下会报Permission Denial b. 图片裁剪1234567891011121314151617181920212223242526272829/** * @param activity 当前activity * @param orgUri 剪裁原图的Uri * @param desUri 剪裁后的图片的Uri * @param aspectX X方向的比例 * @param aspectY Y方向的比例 * @param width 剪裁图片的宽度 * @param height 剪裁图片高度 * @param requestCode 剪裁图片的请求码 */public static void cropImageUri(Activity activity, Uri orgUri, Uri desUri, int aspectX, int aspectY, int width, int height, int requestCode) &#123; Intent intent = new Intent("com.android.camera.action.CROP"); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; intent.setDataAndType(orgUri, "image/*"); intent.putExtra("crop", "true"); intent.putExtra("aspectX", aspectX); intent.putExtra("aspectY", aspectY); intent.putExtra("outputX", width); intent.putExtra("outputY", height); intent.putExtra("scale", true); //将剪切的图片保存到目标Uri中 intent.putExtra(MediaStore.EXTRA_OUTPUT, desUri); intent.putExtra("return-data", false); intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString()); intent.putExtra("noFaceDetection", true); activity.startActivityForResult(intent, requestCode); &#125; c. 安装apk123456789101112// 安装Apkpublic void installApk(Context context) &#123; File file = new File(Environment.getExternalStorageDirectory(), "app.apk"); Intent intent = new Intent(Intent.ACTION_VIEW); Uri uri = Uri.fromFile(file); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; uri = FileProvider.getUriForFile(context, "包名.fileprovider", file); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; intent.setDataAndType(uri, "application/vnd.android.package-archive"); context.startActivity(intent);&#125; 大概使用就这么多，望多多指教。 另附上：官网学习使用FileProvider地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ListView ScrollView回弹效果]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-ListView-ScrollView%E5%9B%9E%E5%BC%B9%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[转自：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/0312/1590.html ios中对可以滚动的视图都在系统层面上实现了触碰到边缘的阻尼回弹效果，用户一看便知自己的操作已经到了边界。android中也有类似的方案，不过当到达边界的时候不是用阻尼的方式，而是逐渐显示一个渐变颜色。ios的那种体验无疑会友好很多，也许是当初ios吵着要把这个设计申请专利的缘故吧，android不得不放弃橡皮筋效果，至少在系统层面。但这不意味着安卓中无法实现和ios一样的效果，这里介绍两种实现的方法。 第一种简单，但是效果不如意，而且必须要在api level大于9的情况下使用： 比如我是要给listview加上阻尼回弹效果，那么只需如下重写listview：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.thinkfeed.bouncelistview;import android.content.Context;import android.util.AttributeSet;import android.util.DisplayMetrics;import android.widget.ListView;public class BounceListView extends ListView&#123; private static final int MAX_Y_OVERSCROLL_DISTANCE = 200; private static final float SCROLL_RATIO = 0.5f;// 阻尼系数 private Context mContext; private int mMaxYOverscrollDistance; public BounceListView(Context context)&#123; super(context); mContext = context; initBounceListView(); &#125; public BounceListView(Context context, AttributeSet attrs)&#123; super(context, attrs); mContext = context; initBounceListView(); &#125; public BounceListView(Context context, AttributeSet attrs, int defStyle)&#123; super(context, attrs, defStyle); mContext = context; initBounceListView(); &#125; private void initBounceListView()&#123; //get the density of the screen and do some maths with it on the max overscroll distance //variable so that you get similar behaviors no matter what the screen size final DisplayMetrics metrics = mContext.getResources().getDisplayMetrics(); final float density = metrics.density; mMaxYOverscrollDistance = (int) (density * MAX_Y_OVERSCROLL_DISTANCE); &#125; @Override protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent)&#123; //This is where the magic happens, we have replaced the incoming maxOverScrollY with our own custom variable mMaxYOverscrollDistance; int newDeltaY = deltaY; int delta = (int) (deltaY * SCROLL_RATIO); if (delta != 0) newDeltaY = delta; return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, mMaxYOverscrollDistance, isTouchEvent); &#125; &#125; 其中deltaX,deltaY为本次滑动偏移，scrollX，scrollY为当前总偏移，为了达到阻尼效果，我们增加了阻尼系数SCROLL_RATIO。但是这个方法受限于api 而且效果并不是很好。在github上看到有人完全重写了ScrollView将橡皮筋效果完美的移植在其中。项目地址：https://github.com/EverythingMe/OverScrollView (注： 此项目已不再维护 作者维护新项目地址：https://github.com/EverythingMe/overscroll-decor)用法和ScrollView一模一样，因为其实就是将系统的ScrollView修改而来。123456&lt;me.everything.android.widget.OverScrollView android:id="@+id/OverScroller" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;.../&gt;&lt;/me.everything.android.widget.OverScrollView&gt; 这个OverScrollView需要稍作修改才能用，不然在第一次加载的时候显示不出来。将原来的onLayout方法替换成下面的代码：123456789101112131415161718192021@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b)&#123; super.onLayout(changed, l, t, r, b); mIsLayoutDirty = false; // Give a child focus if it needs it if (mChildToScrollTo != null &amp;&amp; isViewDescendantOf(mChildToScrollTo, this)) &#123; scrollToChild(mChildToScrollTo); &#125; mChildToScrollTo = null; // Calling this with the present values causes it to re-clam them scrollTo(getScrollX(), getScrollY()); post(new Runnable() &#123; public void run() &#123; scrollTo(0, child.getPaddingTop()); &#125; &#125;); &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Fragment监听返回键]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-Fragment%E7%9B%91%E5%90%AC%E8%BF%94%E5%9B%9E%E9%94%AE%2F</url>
    <content type="text"><![CDATA[场景：在项目中做联系人界面时，需要按名字和按部门显示联系人，此处使用2个fragment切换显示，按部门显示需要体现部门层级关系，需要实现点击返回上级部门。因为Fragment并不能像在Actvity重写onBackPressed即可，此时就需要在Fragment监听处理返回，否则返回事件在Activity中，并不能返回上级部门。 Fragment中没有可以主动获取焦点的控件（如：edittext） 12345678910111213141516//主界面获取焦点@SuppressWarnings("ConstantConditions")private void getFocus() &#123; getView().setFocusableInTouchMode(true); getView().requestFocus(); getView().setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (event.getAction() == KeyEvent.ACTION_UP &amp;&amp; keyCode == KeyEvent.KEYCODE_BACK) &#123; //TODO: handle back button return true; &#125; return false; &#125; &#125;);&#125; Fragment中有可以主动获取焦点的控件,需要对它进行处理 12345678910111213editText.setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_UP) &#123; //关闭软键盘 InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(editText.getWindowToken(), 0); //TODO: handle back button return true; &#125; return false; &#125;&#125;); 参考来源：https://stackoverflow.com/questions/22552958/handling-back-press-when-using-fragments-in-android 以上方法测试有效，另附上其他方法（未测试） 两步搞定Fragment的返回键]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10 小箭头去除与恢复]]></title>
    <url>%2F2018%2F01%2F02%2Fwin10-%E5%B0%8F%E7%AE%AD%E5%A4%B4%E5%8E%BB%E9%99%A4%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[1.去掉小箭头123456reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons" /v 29 /d "%systemroot%\system32\imageres.dll,197" /t reg_sz /ftaskkill /f /im explorer.exeattrib -s -r -h "%userprofile%\AppData\Local\iconcache.db"del "%userprofile%\AppData\Local\iconcache.db" /f /qstart explorerpause 复制上面的代码，新建一个txt文件，粘贴后另存为.bat文件，然后以管理员身份打开。 2.恢复小箭头123456reg delete "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons" /v 29 /ftaskkill /f /im explorer.exeattrib -s -r -h "%userprofile%\AppData\Local\iconcache.db"del "%userprofile%\AppData\Local\iconcache.db" /f /qstart explorerpause 同理，复制上面的代码，新建一个txt文件，粘贴后另存为.bat文件，然后以管理员身份打开。]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 平台版本支持的 API 级别 设备指数查看]]></title>
    <url>%2F2017%2F12%2F28%2FAndroid-%E5%B9%B3%E5%8F%B0%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81%E7%9A%84-API-%E7%BA%A7%E5%88%AB-%E8%AE%BE%E5%A4%87%E6%8C%87%E6%95%B0%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[平台版本 API VERSION_CODE 备注 Android 7.0 24 N 平台亮点 Android 6.0 23 M 平台亮点 Android 5.1 22 LOLLIPOP_MR1 平台亮点 Android 5.0 21 LOLLIPOP Android 4.4W 20 KITKAT_WATCH 仅限 KitKat for Wearables Android 4.4 19 KITKAT 平台亮点 Android 4.3 18 JELLY_BEAN_MR2 平台亮点 Android 4.2、4.2.2 17 JELLY_BEAN_MR1 平台亮点 Android 4.1、4.1.1 16 JELLY_BEAN 平台亮点 Android 4.0.3、4.0.4 15 ICE_CREAM_SANDWICH_MR1 平台亮点 Android 4.0、4.0.1、4.0.2 14 ICE_CREAM_SANDWICH Android 3.2 13 HONEYCOMB_MR2 Android 3.1.x 12 HONEYCOMB_MR1 平台亮点 Android 3.0.x 11 HONEYCOMB 平台亮点 Android 2.3.4Android 2.3.3 10 GINGERBREAD_MR1 平台亮点 Android 2.3.2Android 2.3.1Android 2.3 9 GINGERBREAD Android 2.2.x 8 FROYO 平台亮点 Android 2.1.x 7 ECLAIR_MR1 平台亮点 Android 2.0.1 6 ECLAIR_0_1 Android 2.0 5 ECLAIR Android 1.6 4 DONUT 平台亮点 Android 1.5 3 CUPCAKE 平台亮点 Android 1.1 2 BASE_1_1 Android 1.0 1 BASE 附属: 官网最新对应关系查看 官方有关运行各版本的设备的相对数量的信息查看 友盟全域罗盘设备指数查看 腾讯移动分析查看]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment中使用setOnItemClickListener监听无效的解决办法]]></title>
    <url>%2F2017%2F12%2F27%2FFragment%E4%B8%AD%E4%BD%BF%E7%94%A8setOnItemClickListener%E7%9B%91%E5%90%AC%E6%97%A0%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Activity中用fragment 实现了一个ListView并对每一个Item设置监听，不是对Item里的组件设置监听。测试点击的时候发现点击不起作用，后来找到解决办法如下： 需要在listview的item选项中配置 Android:focusable=”false”12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="38dp" android:focusable="true" android:gravity="center_vertical" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/music_menu_image" android:layout_width="50dp" android:layout_height="match_parent" android:src="@drawable/img_icn_local"/&gt; &lt;TextView android:id="@+id/music_menu_text" android:layout_width="wrap_content" android:layout_height="match_parent" android:gravity="center_vertical" android:textColor="@android:color/black" android:textSize="16sp"/&gt; &lt;TextView android:id="@+id/music_menu_num" android:layout_width="wrap_content" android:layout_height="match_parent" android:gravity="center_vertical" android:paddingLeft="2dp" android:textSize="12sp"/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio更新 无法在线更新 使用增量更新]]></title>
    <url>%2F2017%2F12%2F27%2FAndroid-Studio%E6%9B%B4%E6%96%B0-%E6%97%A0%E6%B3%95%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0-%E4%BD%BF%E7%94%A8%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[最近Android Studio更新到了3.0版本，而我还是处于2.2版本，无法使用Android Studio Help下的check for updates…在线更新到最新版。由于本人比较懒，不想卸载后重装去配置环境等繁琐操作，记得偶然一次看视频时别人提到不能直接解决办法。只记得需要一步步升级，少量更新到最新版，具体操作在一顿Google下发现【增量更新】。很多博客都有写怎么操作，经过实践好多都不起作用，经过多次尝试最终成功。记录下操作，避免日后忘记…. 一 、检查当前Android Studio版本 1 Android Studio Help =&gt; about 查看版本号，我的是145.3276617 2 Android Studio 安装根目录下build.txt查看版本号，同样是145.3276617注：此处没有图截到旧版图参考，可依照第五步截图 二、获取最新的版本信息 历史版本以及最新的版本信息可以在 https://dl.google.com/android/studio/patches/updates.xml 三、增量更新包下载我们通过如下的方式拼接适合自己的增量包的URL： https://dl.google.com/android/studio/patches/AI-[当前安装版本号]-[要更新的目标版本]-patch-win.jar比如，如果按我们刚刚截图的版本号来获取离线包，则 URL 为： https://dl.google.com/android/studio/patches/AI-145.3276617-162.3508619-patch-win.jar 四、增量更新包安装 1 将更新包放在除Android Studio 安装根目录之外的任意目录，可以放在其他盘 2 首先关闭所有的 Android Studio任务，把得到的 jar 更新包放到除Android Studio安装目录的任意目录下。在Android Studio根目录按住Shift+右键打开命令窗口或者运行打开CMD切换到Android Studio根目录，输入如下命令： java -classpath D:\AI-145.3276617-162.3508619-patch-win.jar com.intellij.updater.Runner install . 注意最后的 .，意味着将更新包解压到 Android Studio 的安装目录。然后回车执行命令。这时候会弹出对话框，展示安装具体进度： 3 正常更新结束，重启Android Studio导入以前配置即完成更新 五、更新异常处理如果你遇到安装错误，一般是如下： Some conflicts were found in the installation area. Please select desired solutions from the Solution column and press Proceed….. 一般可能的原因有如下一些： 你还有Android Studio任务没有关闭，检查一下，如果有，请关闭 你把离线jar放到了Android Studio的安装目录了，导致文件占用或其他一些错误 如果是Linux或者Mac系统，有可能需要sudo权限来执行安装命令 如此一步步增量，即可更新到能直接使用check for updates…在线更新，或者直接增量到最新版…]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio的Beta Canary Dev Stableb版本介绍]]></title>
    <url>%2F2017%2F12%2F27%2FAndroid-Studio%E7%9A%84Beta-Canary-Dev-Stableb%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Android Studio发布总共分为Beta、Canary、Dev、Stableb四个版本 首先来段官网介绍： Android Studio’s built-in update mechanism can be set to receive updates through any one of these 4 channels. Canary: Bleeding edge, released about weekly. These are early previews released in order to obtain real-world feedback during development. The canary channel will always have the latest build, including updates to beta or stable releases. We recommend running canary builds side-by-side with a beta or stable installation. Dev: Canary builds after a full round of internal testing get promoted into the Dev Channel. Beta: Release candidates based on stable canary builds, released and updated to obtain feedback prior to the stable release. The beta channel will be updated with new stable builds until a new canary build goes to beta. Stable: The official stable release, as available from the Android Developer site. 大概意思：Android Studio内置的更新机制被设置成为如下四个可选的版本： Canary（金丝雀）：Bleeding Edge（一种最新的、因而也并非完美的技术）,大约周更。这是最早被发布的预览版本，为了能够在开发过程中获得真实世界的反馈。金丝雀版本会一直拥有最新的版本包括beta、stable发布版的更新。我们建议在安装金丝雀版本的同时再安装一个beta版本或者stable版本 Dev（开发版）：金丝雀版本在经过完整的测试之后会被提升到Dev版本 Beta（Beta版）：发布预选基于稳定的金丝雀版本。被发布并更新以获取反馈先于稳定版本。Beta版本将与一个新的稳定版本一起被更新，直到一个新的金丝雀版本被确定为Beta版本 Stable（稳定版）：从Android Developer网站上可获得的稳定版本 Android Studio 增量更新：Android Studio更新 无法在线更新 使用增量更新]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 实用插件收集]]></title>
    <url>%2F2017%2F12%2F26%2FAndroid-Studio-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[1 Material Theme UI EAP 、Material Theme UI ：Android Studio界面设计为Material Design风格 2 Android Wifi ADB：连接一次后 就可以使用WiFi连接手机 3 Gson Format：快速转换json 【强烈推荐】 4 Android Parcelable Code Generator： JavaBean序列化，快速实现Parcelable接口 【强烈推荐】 5 ButterKnife Zelezny：ButterKnife 注解生成器 6 ECTranslation：Android Studio 翻译插件 7 checkstyle-idea：检查代码风格 8 FindBugs-IDEA：帮你找到隐藏的bug及不好的做法 9 Android Material Design Icon Generator：生成Material Design Icon 10 SelectorChapek for Android：Selector文件生成 11 .ignore : git忽略文件插件 12 Lifecycle Sorter : Activity或者fragment的生命周期排序 13 CodeGlance：预览代码，实现快速定位 14 android-strings-search-plugin：通过输入文字找到strings.xml资源 15Alibaba Java Coding Guidelines: 阿里巴巴规约插件 【强烈推荐】]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份不错的安卓代码规范 - 转载]]></title>
    <url>%2F2017%2F12%2F25%2F%E4%B8%80%E4%BB%BD%E4%B8%8D%E9%94%99%E7%9A%84%E5%AE%89%E5%8D%93%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在实际开发中代码规范是很重要的，一团糟的的代码，谁看着都很头疼，维护起来相当痛苦。实际工作中，很多程序员都只顾自己痛快，而不遵从一定的规则，没有任何注释且自带混淆功能。最近看到这份规范，大部分和自己平时的习惯都很符合，便忍不住转( chao )载（xi）了过来，希望大家能够扩散起来。这份规范在GitHub上已经超过3k的star了，可见大家还是很认同的(原文是英语的，有兴趣可以直接看看，文末也会附上转( chao )载（xi）的译文地址)。 1. 项目指南1.1 项目结构新项目应该遵循安卓Gradle项目结构，定义在这里 ：安卓Gradle插件用户指南。项目ribot Boilerplate 是一个很好的参考。 1.2 文件命名1.2.1 类文件类名书写方式是 大写的驼峰命名.继承于安卓组件的类，名称应该以继承的组件命名，比如：SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog. 1.2.2 资源文件资源文件书写方式：小写_下划线。如：ic_launcher.png (实际上资源文件命名是不允许大小的) 1.2.2.1 Drawable 文件 drawable类型资源命名： 资源类别 前缀 例子 Action bar ab_ ab_stacked.9.png Button btn_ btn_send_pressed.9.png Dialog dialog_ dialog_top.9.png Divider divider_ divider_horizontal.9.png Icon ic_ ic_star.png Menu menu_ menu_submenu_bg.9.png Notification notification_ notification_bg.9.png Tabs tab_ tab_pressed.9.png 图标（icons）命名方式 (取自 安卓图标官方指南): 资源类别 前缀 例子 Icons ic_ ic_star.png Launcher icons ic_launcher ic_launcher_calendar.png Menu icons and Action Bar icons ic_menu ic_menu_archive.png Status bar icons ic_stat_notify ic_stat_notify_msg.png Tab icons ic_tab ic_tab_recent.png Dialog icons ic_dialog ic_dialog_info.png selector 状态命名方式: 状态 后缀 例子 Normal (正常) _normal btn_order_normal.9.png Pressed（按下） _pressed btn_order_pressed.9.png Focused （获得焦点） _focused btn_order_focused.9.png Disabled （不可用） _disabled btn_order_disabled.9.png Selected （选中） _selected btn_order_selected.9.png 1.2.2.2 布局文件布局文件应该跟对应的安卓组件名称匹配，但是把最顶级的组件名称放在前面。比如，当我们创建一个用于 SignInActivity的布局，那布局文件名称应该是activity_sign_in.xml. 组件 类名 布局文件名 Activity UserProfileActivity activity_user_profile.xml Fragment SignUpFragment fragment_sign_up.xml Dialog ChangePasswordDialog dialog_change_password.xml AdapterView item — item_person.xml Partial layout — partial_stats_bar.xml 一个稍微不同的地方是当我们创建用于Adapter渲染的布局,如填充一个 ListView， 在这种情况下，布局文件命名应该是用 item开始。注意有些地方这些规则没法应用，如，当我们创建一个布局文件，用于渲染另一个布局的一部分，这样的情况下，我们应该使用partial前缀。 1.2.2.3 菜单文件跟布局文件相似，按钮文件应该跟对应的组件匹配。比如：当我们定义一个菜单，用于 UserActivity，那么文件名应该是 activity_user.xml，文件名不含有menu是个良好的习惯做法，因为这些文件已经位于 menu 目录了。 1.2.2.4 取值文件(Values files)在values文件夹的资源文件应该是复数形式（plural），比如，strings.xml, styles.xml, colors.xml, dimens.xml, attrs.xml 2 代码指南2.1 Java语言规范2.1.1 不要忽略了异常你万不该这样做:12345void setServerPort(String value) &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; &#125;&#125; 虽然你可能觉得你的代码永远不会抛出这个异常或者这异常不重要，不需要处理它，像上面那样忽略异常会在你的代码中留下雷区，将来其他人会踩到。你必须在你的代码中以某种原则的方式处理每个异常。具体的处理视情况而定。 安卓官方代码指南 指南中关于不要忽略异常的说明在这里. 2.1.2 不要捕获一类异常。你不应该这样做:12345678try &#123; someComplicatedIOFunction(); // 可能抛出 IOException someComplicatedParsingFunction(); // 可能抛出 ParsingException someComplicatedSecurityFunction(); // 可能抛出 SecurityException //呵呵，统一处理掉&#125; catch (Exception e) &#123; //我将捕获所有的异常 handleError(); // 使用一个通用的处理手段!&#125; 查看不这样做的原因以及要怎么做的原因 2.1.3 不要用finalizer我们不使用finalizer。它什么时候被调用是没有保证的，甚至它不被调用。大部分情况下，你可以使用良好的异常处理来满足需要在finalizer中做的工作。如果你确实需要它，定义一个 close() 方法（或类似的）然后在文档中明确的指出什么时候这个方法需要被调用。可以查看 InputStream 做为例子.这种情况下，在finalizer中打印一个简短的log信息是恰当的但不是必须的，因为我们不希望log泛滥 猛戳安卓官方指南之不要用finalizer 2.1.4 完全的import语句12反例: import foo.*;正解: import foo.Bar; 点击这里查看更多说明 2.2 Java风格规范2.2.1 全局变量定义及命名全局变量应该定义在文件的头部,遵循下面的命名规则。 私有的非静态全局变量以m开头私有的静态全局变量以s开头其他的全局变量以小写单词开头常量使用全部大写，单词间用下划线间隔（ALL_CAPS_WITH_UNDERSCORES） 译者注：这个规则取自Android Open Source Project代码贡献规范。在程序员的圈子里对于要不要前缀这个问题已经吵翻天了。我在使用greendao的时候使用前缀的话，自动生成的getter/setter会是getMxxx/setMxxx这样难看的方法。很多人也觉得这个命名规则没有意义。stackOverFlow 还有 这里 ，以及一本教你怎么写出整洁代码的书中如是说：“我觉得如今这些前缀没有意义，尤其是在你的APP中!你的类和方法应该尽量的小，而且你应该使用代码高亮的编辑环境，使得成员变量易于分辨。再者，人们快速适应忽略了前缀或后缀来看名字的有意义部分。我们阅读代码越多，看到前后缀越少。渐渐地，前缀就变成了旧代码看不到的线索和标记。——代码整洁之道(Clean.Code).Robert.C.Martin” 例子:12345678public class MyClass &#123; public static final int SOME_CONSTANT = 42; public int publicField; private static MyClass sSingleton; int mPackagePrivate; private int mPrivate; protected int mProtected;&#125; 2.2.3把首字母缩写当做一个单词来看 好的 不好的 XmlHttpRequest XMLHTTPRequest getCustomerId getCustomerID String url String URL long id long ID 2.2.4 使用空格缩进使用四个空格做代码块缩进:123if (x == 1) &#123; x++;&#125; 换行时使用8个空格缩进:12Instrument i = someLongExpression(that, wouldNotFit, on, one, line); 2.2.5 使用标准的大括号风格大括号的开始跟代码同一行1234567891011class MyClass &#123; int func() &#123; if (something) &#123; // ... &#125; else if (somethingElse) &#123; // ... &#125; else &#123; // ... &#125; &#125;&#125; 条件语句使用大括号包住，除非条件体只有一行。如果条件及只有一行条件体，而且没被换行，大括号是不必的。1if (condition) body(); 这是不好的:12if (condition) body(); // 不好的，没有大括号包围! 译者注：这个个人感觉一行的也加上大括号比较好，因为后续可能就不止一行，这样加代码就不用再加括号，而且不加大括号可读性不好。比如下面的例子1234if(flag == 0) a++;else &#123; b--;&#125; 2.2.6 注解2.2.6.1 注解实践规范根据安卓代码风格指南，一些Java内置的注解标准的实践规范有： @Override: 无论一个方法是重载父类还是实现某个接口的都必须使用@Override 注解。比如，当你使用 @inheritdocs Javadoc 标签,然后 从一个类(不是一个接口)中导出，你也必须声明那个方法 @Overrides 父类的方法。 @SuppressWarnings: @SuppressWarnings 注解应该仅当不可能消除一个警告的时候才使用。如果一个警告 通过这个 “不可能消除” 的测试, @SuppressWarnings 注解必不可少, 以便保证所有的警告在代码中反映实际的问题。 关于注解的更多指南可以查看这里 2.2.6.2 注解风格 类，方法及构造器 当注解被应用到一个类，方法或者构造函数时候，注解在代码注释之后，一行一个注解1234/* 这是这个类的注解 */@AnnotationA@AnnotationBpublic class MyAnnotatedClass &#123; &#125; 属性属性的注解应该在同一行列出。除非这一行超过了最大字数了。 1@Nullable @Mock DataManager mDataManager; 2.2.7 限制变量范围变量的使用范围应该限制到最小(Effective Java 条目 29)。这样做，你可以为你的代码增加可读性和可维护性，减少可能的错误。每个变量应该在最内层的使用到的它代码块中定义 局部变量应该在第一次用到他们的时候定义。几乎每个局部变量都应该初始化。如果你没有足够的信息去初始化一个变量，你应该延迟声明这个变量，直到你有足够的初始化信息。安卓代码风格指南 2.2.8 排序import语句如果你使用IDE,如Android Studio，你不必担心这些规则，这些IDE已经遵循这些规则。如果你不用IDE，往下看这些规则: import 安卓框架的 import 来自第三方的(com, junit, net, org) java 以及 javax 同一个项目的 imports 为了保持跟IDE的设置一致，这些imports应该是这样的： 首字母分组排序，大写的字母在小写的字母前面（如Z在a前面）。 每个主要分组 (android, com, junit, net, org, java, javax)间应该有一行空行。更多信息查看这里2.2.9 日志(Loging)指南 使用 Log 类提供的日志方法来打印错误信息或对开发者分辨问题有用的其他信息： Log.v(String tag, String msg) (verbose) Log.d(String tag, String msg) (debug) Log.i(String tag, String msg) (information) Log.w(String tag, String msg) (warning) Log.e(String tag, String msg) (error) 通常来说，我们使用一个类的名称作为一个TAG，在文件的开头定义成一个 static final 变量，如：123456public class MyClass &#123; private static final String TAG = MyClass.class.getSimpleName(); public myMethod() &#123; Log.e(TAG, "My error message"); &#125;&#125; VERBOSE 和 DEBUG 日志 必须在release版本中禁用。同时也建议禁用INFORMATION, WARNING 和 ERROR 日志，但是你可能觉得它们在release版本中定位问题很有用而保持启用。如果你决定让他们保持启用，你要保证这些日志信息不会泄漏email地址，用户id之类的隐私信息。仅限debug版本显示Log的配置：1if (BuildConfig.DEBUG) Log.d(TAG, "The value of x is " + x); 2.2.10 类成员排序这虽然没有简单正确的方案，但是使用一个逻辑的及一致的顺序可以提高代码的可读性和可学习性。下面是推荐的顺序： 常量 全局变量 构造函数 重载的函数和回调 (public 或 private) Public 方法 Private 方法 内部类或内部接口 例子:12345678910111213141516public class MainActivity extends Activity &#123; private String mTitle; private TextView mTextViewTitle; public void setTitle(String title) &#123; mTitle = title; &#125; @Override public void onCreate() &#123; ... &#125; private void setUpView() &#123; ... &#125; static class AnInnerClass &#123; &#125;&#125; 如果你的类继承一个安卓组件如Activity或Fragment，对重载的方法进行排序以便跟组件的生命周期匹配是一个最佳实践。比如，当你的Activity实现onCreate(), onDestroy(), onPause() 和 onResume()，正确的顺序是：1234567891011public class MainActivity extends Activity &#123; //顺序跟Activity的生命周期匹配 @Override public void onCreate() &#123;&#125; @Override public void onResume() &#123;&#125; @Override public void onPause() &#123;&#125; @Override public void onDestroy() &#123;&#125;&#125; 2.2.11 方法的参数顺序在安卓编码时候，定义一个方法拥有一个Context参数是非常常见的，如果你写一个这样的方法，Context应该是第一个参数。 相反的例子是回调接口，它应该是最后一个参数例子:1234// Context 总是在第一个位public User loadUser(Context context, int userId);// 回调总是在最后一位public void loadUserAsync(Context context, int userId, UserCallback callback); 2.2.13 字符串常量，命名和取值很多安卓SDK的元素如SharedPreferences, Bundle, 或 Intent使用键值对实现，所以即使是一个小应用，使用一堆字符串常量也是很常见的。 当使用这些组件，你必须定义这些键是 static final 变量，并且它们应该像下面这样使用前缀 元素 变量名前缀 SharedPreferences PREF_ Bundle BUNDLE_ Fragment Arguments ARGUMENT_ Intent Extra EXTRA_ Intent Action ACTION_ 注意Fragment的参数——Fragment.getArguments()也是一个Bundle。然而，因为这是Bundle非常常见的用法，我们为它定义一个不同的前缀。 例子:12345678//注意这些变量的值应该和名称一致来避免问题static final String PREF_EMAIL = "PREF_EMAIL";static final String BUNDLE_AGE = "BUNDLE_AGE";static final String ARGUMENT_USER_ID = "ARGUMENT_USER_ID";//Intent相关的使用完全包名作为值static final String EXTRA_SURNAME = "com.myapp.extras.EXTRA_SURNAME";static final String ACTION_OPEN_USER = "com.myapp.action.ACTION_OPEN_USER"; 2.2.14 Fragment和Activity的参数当数据通过Intent 或Bundle传递到一个Activity或 Fragment，这些不同值的键必须 遵循上面描述的规则。当一个 Activity 或 Fragment 想要参数，它应该提供一个public static方法来简化对应的Intent 或 Fragment创建在Activity中这个方法通常叫 getStartIntent():12345public static Intent getStartIntent(Context context, User user) &#123; Intent intent = new Intent(context, ThisActivity.class); intent.putParcelableExtra(EXTRA_USER, user); return intent;&#125; 对于Fragment它的名称是newInstance()，处理使用合适的参数创建Fragment。1234567public static UserFragment newInstance(User user) &#123; UserFragment fragment = new UserFragment; Bundle args = new Bundle(); args.putParcelable(ARGUMENT_USER, user); fragment.setArguments(args) return fragment;&#125; 注意1: 这些方法应该在类的 onCreate()前面 注意2: 如果我们提供上面说的方法，这些extras对应的键和参数应该是private的，因为他们不需要暴露到类以外。 2.2.15 代码行长度限制代码行不应该超过100 个字符。如果代码行超过这个限制长度，通常有两种方式来降低长度： 提取一个局部变量或方法（推荐方式）. 把单行换行成多行 有两种例外可以让一行超过100字符： 这行不可分割，如长URL package 和 import 语句 2.2.15.1 换行策略没有精确的公式解释怎么换行，很多不同的方案是有效的。然而，这里有几个规则可以应用到常见情况。 在操作符前断开 当一行被操作符断开，断开处应该在操作符之前，例子如下：12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 赋值符号（=）例外 在操作符前断开有一个例外，那就是赋值符号 =，应该在赋值符号后面断开。12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 方法链的情况 当多个方法被链接在同一行的时候——如使用Builder时，每一个方法的调用应该在独立一行，在 .之前断开。1234Picasso.with(context).load("http://ribot.co.uk/images/sexyjoe.jpg").into(imageView);Picasso.with(context) .load("http://ribot.co.uk/images/sexyjoe.jpg") .into(imageView); 长参数的情况 当一个方法有很多参数或它的参数非常长，我们应该在每个逗号 ,后面断开123456loadPicture(context, "http://ribot.co.uk/images/sexyjoe.jpg", mImageViewProfilePicture, clickListener, "Title of the picture");loadPicture(context, "http://ribot.co.uk/images/sexyjoe.jpg", mImageViewProfilePicture, clickListener, "Title of the picture"); 2.2.16 RxJava 链式风格Rx链式操作符要求换行。每一个操作符必须在新的一行，断行应该在.之前123456789101112131415public Observable&lt;Location&gt; syncLocations() &#123; return mDatabaseHelper.getAllLocations() .concatMap(new Func1&lt;Location, Observable&lt;? extends Location&gt;&gt;() &#123; @Override public Observable&lt;? extends Location&gt; call(Location location) &#123; return mRetrofitService.getLocation(location.id); &#125; &#125;) .retry(new Func2&lt;Integer, Throwable, Boolean&gt;() &#123; @Override public Boolean call(Integer numRetries, Throwable throwable) &#123; return throwable instanceof RetrofitError; &#125; &#125;);&#125; 2.3 XML 风格规定2.3.1 使用自关闭的标签当一个XML元素没有任何内容时，你必须使用自关闭标签。这是好例子:1234&lt;TextView android:id="@+id/text_view_profile" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 这是不好的例子 :12345&lt;TextView android:id="@+id/text_view_profile" android:layout_width="wrap_content" android:layout_height="wrap_content" &gt;&lt;/TextView&gt; 2.3.2 资源命名资源 ID 和名称使用小写加下划线方式 lowercase_underscore. 2.3.2.1 ID 命名ID应该使用小写加下划线命名，加上元素名称为前缀，如： 元素 前缀 TextView text_ ImageView image_ Button button_ Menu menu_ ImageView例子:1234&lt;ImageView android:id="@+id/image_profile" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; Menu 例子:12345&lt;menu&gt; &lt;item android:id="@+id/menu_done" android:title="Done" /&gt;&lt;/menu&gt; 2.3.2.2 字符串字符串名称以它们所属的部分为前缀命名，比如registration_email_hint 或 registration_name_hint。如果一个字符串不属于任何部分，那么你应该遵循下面的规则： 前缀 描述 error_ An error message msg_ A regular information message title_ A title, i.e. a dialog title action_ An action such as “Save” or “Create” 2.3.2.3 Styles 和 Themes不像其他的资源，style命名方式是大写的驼峰是命名UpperCamelCase 2.3.3 属性顺序作为通用的规则，你应该把相似的属性放在一起分组，一个对常见属性良好的排序方式是 View Id Style 布局的宽和高 其他的布局属性，按字母排序 剩下的属性，按字母排序 2.4 测试风格规定2.4.1单元测试测试类应该跟需要测试的类名字对应，以Test做后缀。比如我们创建一个测试类包含对DatabaseHelper的测试，我们应该把它命名为 DatabaseHelperTest。 测试方法用@Test注解，通常以要测试的方法名为命名开始，以测试的前置条件及/或期望结果做后缀。 模板: @Test void methodNamePreconditionExpectedBehaviour() 例子: @Test void signInWithEmptyEmailFails() 如果没有它们测试也能够清楚的表达，前置条件和/或期望结果不总是必须的。 有时候一个类可能包含一大堆方法，同时每个方法要求多个测试，在这种情况，推荐把测试类分割成几个。比如，如果 DataManager包含一大堆方法，我们可能想把它分到 DataManagerSignInTest, DataManagerLoadUsersTest等等。通常你能够知道哪些测试应该在一起，因为它们有共同的test fixtures. 2.4.2 Espresso 测试每一个 Espresso 测试类目标通常是一个Activity，所以它的名称应该跟目标Activity的名称匹配，以Test结束，如 SignInActivityTest 当使用 Espresso API ，把链式方法调用放新行是一个最佳实践。123onView(withId(R.id.view)) .perform(scrollTo()) .check(matches(isDisplayed())) 转载地址：GitHub上star超过2k的安卓项目和代码风格指南（绝对干货）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 开发环境搭建]]></title>
    <url>%2F2017%2F12%2F25%2FPython3-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[一 Anaconda安装下载对应系统和Python版本的Anaconda，地址：https://www.anaconda.com/download/#windows 。 安装过程中切记： 安装完成后打开cmd，输入 python 回车，检查python安装成功与否： 简单测试python，输入 print (‘hello world! ’) 回车： 退出pyhton交互，输入exit() 回车: 二 PyCharm安装下载对应系统版本的PyCharm，地址：https://www.jetbrains.com/pycharm/download/#section=windows 。]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>pyhton</tag>
      </tags>
  </entry>
</search>
