<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 点击空白处 隐藏键盘]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-%E7%82%B9%E5%87%BB%E7%A9%BA%E7%99%BD%E5%A4%84-%E9%9A%90%E8%97%8F%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[这里给大家介绍3种方案，均可以封装在BaseActivity使用，可以根据自己实际需求酌情使用： 判断焦点（网上介绍最多的方案）原理：在事件分发的时候判断当前获取焦点的View是不是EditText，是EditText就判断MotionEvent 是否发生在这个View上，然后隐藏键盘，不足的是点击另一个EditText会看到键盘隐藏然后再显示。 12345678910111213141516171819202122232425262728293031323334353637/** * 获取点击事件 */@CallSuper@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.MotionEvent ) &#123; View view = getCurrentFocus(); if (isShouldHideKeyBord(view, ev)) &#123; hideSoftInput(view.getWindowToken()); &#125; &#125; return super.dispatchTouchEvent(ev);&#125;/** * 判定当前是否需要隐藏 */protected boolean isShouldHideKeyBord(View v, MotionEvent ev) &#123; if (v != null &amp;&amp; (v instanceof EditText)) &#123; int[] l = &#123;0, 0&#125;; v.getLocationInWindow(l); int left = l[0], top = l[1], bottom = top + v.getHeight(), right = left + v.getWidth(); return !(ev.getX() &gt; left &amp;&amp; ev.getX() &lt; right &amp;&amp; ev.getY() &gt; top &amp;&amp; ev.getY() &lt; bottom); &#125; return false;&#125;/** * 隐藏软键盘 */private void hideSoftInput(IBinder token) &#123; if (token != null) &#123; InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); manager.hideSoftInputFromWindow(token, InputMethodManager.HIDE_NOT_ALWAYS); &#125;&#125; 根布局设置点击事件原理：对根布局设置点击事件，点击根布局则隐藏键盘。不足的是点击到能获取焦点的控件上无效。 123456789101112131415161718192021@CallSuper@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //点击空白处隐藏键盘 ((ViewGroup) findViewById(android.R.id.content)).getChildAt(0).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; hideSoftInput(view.getWindowToken()); &#125; &#125;);&#125;/** * 隐藏软键盘 */private void hideSoftInput(IBinder token) &#123; if (token != null) &#123; InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); manager.hideSoftInputFromWindow(token, InputMethodManager.HIDE_NOT_ALWAYS); &#125; 过滤不需要隐藏键盘的View原理：在事件分发的时候判断ACTION_DOWN事件是不是在需要过滤的View上，不是就隐藏键盘，不足的是每发生一次ACTION_DOWN都要循环一次filterViews。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 获取点击事件 */@CallSuper@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; filterViews != null) &#123; View focusView = getCurrentFocus(); if (isShouldHideKeyBord(ev)) &#123; hideSoftInput(focusView.getWindowToken()); &#125; &#125; return super.dispatchTouchEvent(ev);&#125;/** *设置需要过滤掉的View */protected void setFilterView(View... view) &#123; this.filterViews = view;&#125;/** * 判定当前是否需要隐藏 */protected boolean isShouldHideKeyBord(MotionEvent ev) &#123; boolean hide = true; for (View v : filterViews) &#123; int[] l = &#123;0, 0&#125;; v.getLocationInWindow(l); int left = l[0], top = l[1], bottom = top + v.getHeight(), right = left + v.getWidth(); if (ev.getX() &gt; left &amp;&amp; ev.getX() &lt; right &amp;&amp; ev.getY() &gt; top &amp;&amp; ev.getY() &lt; bottom) &#123; hide = false; break; &#125; &#125; return hide;&#125;/** * 隐藏软键盘 */private void hideSoftInput(IBinder token) &#123; if (token != null) &#123; InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); manager.hideSoftInputFromWindow(token, InputMethodManager.HIDE_NOT_ALWAYS); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ButterKnife8.8 module与library配置使用记录]]></title>
    <url>%2F2018%2F01%2F02%2FButterKnife8-8-module%E4%B8%8Elibrary%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文使用前提是在Android Studio2.3.3 Stable版本使用记录，其他版本未测试。 一、module中配置 如果在module中配置，那就GitHub中配置一致三步曲操作，然后就可以正常使用了。 1 在module的build中添加依赖1234dependencies &#123; compile 'com.jakewharton:butterknife:8.8.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1'&#125; 如果你是使用Kotlin, 将annotationProcessor替换为kapt. 2 project的build中添加12345678buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'com.jakewharton:butterknife-gradle-plugin:8.8.1' &#125;&#125; 3 在module中apply:12apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' 现在确定Butter Knife注解可以使用R2 替换 R。 12345class ExampleActivity extends Activity &#123; @BindView(R2.id.user) EditText username; @BindView(R2.id.pass) EditText password;...&#125; 二、library中配置一般我们会在BaseActivity中使用ButterKnife.bind(this)，但是我的base类都在library中。一开始我直接在library中配置，module依赖library，让module依赖library。但是直接报R2找不到，然后我就使用R替换，不过具体使用的地方会报空指针。看github的issue中有很多人也遇到这个问题，但是我是在没找到一个准确的解决办法，然后自己摸索了一个办法，还是可以使用的，如果有比较官方的办法，可以告诉我。 1 我们还是直接在中library按配置module方式进行配置 2 既然我们不能找到R2，说明我们module没有apply plugin。所以需要在对应的module的build添加如下代码，然后点击sync now并rebuild，R2已经不报错了。1234//不使用下面这句，因为我们的library项目已经有了//apply plugin: 'com.android.library'apply plugin: 'com.jakewharton.butterknife' 3 R2不报错了，我们运行后，依旧会有空指针。我觉得是这个module没有解析到R2，导致BindView失败，所以将注解解析器依赖到对应的module1annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1' 最后点击sync now并rebuild运行完美通过。 三、配置小总结：1 需要使用ButterKnife的module一定要配置如下两句：123apply plugin: 'com.jakewharton.butterknife'annotationProcessor 'com.jakewharton:butterknife-compiler:8.8.1']]></content>
      <categories>
        <category>Android</category>
        <category>ButterKnife</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ButterKnife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TabLayout系列之进阶使用]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-TabLayout%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1 前言上篇 TabLayout系列之简单使用更新也有一段时间了，由于工作任务比较多且遇上国庆出去玩，就很久没做更新了。还有一点关于TabLayout的使用没有介绍完，公司的事忙得差不多了，今天来继续介绍这个系列。再啰嗦下，前两篇文章介绍了TabLayout的 属性 和 简单使用，需要的便宜可以先去熟悉熟悉。这篇文章主要是简单使用的一个补充，以及对自定义TabItem的一个说明。废话不多说，我们直奔主题。 2 TabLayout默认Style12TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TabLayout,defStyleAttr, R.style.Widget_Design_TabLayout); 12345678910&lt;style name="Base.Widget.Design.TabLayout" parent="android:Widget"&gt; &lt;item name="tabMaxWidth"&gt;@dimen/design_tab_max_width&lt;/item&gt; &lt;item name="tabIndicatorColor"&gt;?attr/colorAccent&lt;/item&gt; &lt;item name="tabIndicatorHeight"&gt;2dp&lt;/item&gt; &lt;item name="tabPaddingStart"&gt;12dp&lt;/item&gt; &lt;item name="tabPaddingEnd"&gt;12dp&lt;/item&gt; &lt;item name="tabBackground"&gt;?attr/selectableItemBackground&lt;/item&gt; &lt;item name="tabTextAppearance"&gt;@style/TextAppearance.Design.Tab&lt;/item&gt; &lt;item name="tabSelectedTextColor"&gt;?android:textColorPrimary&lt;/item&gt;&lt;/style&gt; 12345&lt;style name="TextAppearance.Design.Tab" parent="TextAppearance.AppCompat.Button"&gt; &lt;item name="android:textSize"&gt;@dimen/design_tab_text_size&lt;/item&gt; &lt;item name="android:textColor"&gt;?android:textColorSecondary&lt;/item&gt; &lt;item name="textAllCaps"&gt;true&lt;/item&gt;&lt;/style&gt; 上面三段代码片段，可以知道TabLayout默认使用Base.Widget.Design.TabLayout，里面有预设好的一些属性。其中tabTextAppearance在 Android TabLayout系列之简单使用中已经介绍到了，通过继承它来改变默认英文字母大写与字体大小问题，由此我们也可以自定义自己的style来实现自己的需求。 3 带图片的TabAndroid TabLayout系列之简单使用中，介绍到了TabLayout的使用，但基本上都是纯文本的TabItem，并没有实现带图片的TabItem。这次就闲来撸一个带图片的TabItem，还是老规矩先上代码(码注释) -&gt; 效果图 -&gt; 分析。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(R.id.tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; //这里tab可能为null 根据实际情况处理吧 mTabLayout.getTabAt(i).setText("Tab" + i); //设置图片icon mTabLayout.getTabAt(i).setIcon(R.mipmap.ic_launcher); &#125; &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 这里的demo代码和Android TabLayout系列之简单使用中的一致，只是增加了 mTabLayout.getTabAt(i).setIcon(R.mipmap.ic_launcher)来设置TabView中Tab的图片。这里显示效果是官方提供的默认实现，TabView继承至Linearlayout且被设置成了竖直方向。这点可以从TabView的构造器中看到：1234567public TabView(Context context) &#123; super(context); ...... setGravity(Gravity.CENTER); setOrientation(VERTICAL); //设置成竖直方向 ......&#125; 至于为什么显示在第一个，可以从TabView的update方法了解到：1234567891011121314151617181920212223242526272829303132333435final void update() &#123; final Tab tab = mTab; final View custom = tab != null ? tab.getCustomView() : null; ...... ...... if (mCustomView == null) &#123; // If there isn't a custom view, we'll us our own in-built layouts if (mIconView == null) &#123; ImageView iconView = (ImageView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_icon, this, false); addView(iconView, 0); //将ImageView放在了LinearLayout的0位 mIconView = iconView; &#125; if (mTextView == null) &#123; TextView textView = (TextView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_text, this, false); addView(textView); //添加TextView mTextView = textView; mDefaultMaxLines = TextViewCompat.getMaxLines(mTextView); &#125; TextViewCompat.setTextAppearance(mTextView, mTabTextAppearance); if (mTabTextColors != null) &#123; mTextView.setTextColor(mTabTextColors); &#125; updateTextAndIcon(mTextView, mIconView); //更新文本和icon &#125; else &#123; // Else, we'll see if there is a TextView or ImageView present and update them if (mCustomTextView != null || mCustomIconView != null) &#123; updateTextAndIcon(mCustomTextView, mCustomIconView); &#125; &#125; // Finally update our selected state setSelected(tab != null &amp;&amp; tab.isSelected());&#125; 这里面的TabView是没有get方法的，所以我们取不到，可以通过反射拿到做一些需要的操作，就不验证了，因为我们这里是需要自定义TabView。 4 自定义带图片的Tab看源码或API的话可以知道Tab有个setCustomView(@Nullable View view)方法，可用于添加自定义的TabItem。 首先得来个TabItem的Layout Resource文件： 12345678910111213141516171819202122&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/text_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:text="Tab1" android:textSize="14sp"/&gt; &lt;ImageView android:id="@+id/image_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginBottom="0dp" android:src="@mipmap/ic_indicator"/&gt;&lt;/LinearLayout&gt; 其次在我们的Activity实现我们的效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class MainActivity extends BaseActivity implements TabLayout.OnTabSelectedListener &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(R.id.tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; TabLayout.Tab tab = mTabLayout.getTabAt(i); if (tab == null) return; //设置自定义的View tab.setCustomView(mAdapter.getTabView(i)); &#125; //需要自己实现选中监听，来实现自己需要的效果 mTabLayout.addOnTabSelectedListener(this); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; @Override public void onTabSelected(TabLayout.Tab tab) &#123; //Toast.makeText(this, "onTabSelected", Toast.LENGTH_SHORT).show(); changeTabStatus(tab, true); &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; //Toast.makeText(this, "onTabUnselected", Toast.LENGTH_SHORT).show(); changeTabStatus(tab, false); &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; //Toast.makeText(this, "onTabReselected", Toast.LENGTH_SHORT).show(); new AlertDialog.Builder(this) .setMessage("再次选中，显示对话框！") .show(); &#125; private void changeTabStatus(TabLayout.Tab tab, boolean selected) &#123; View view = tab.getCustomView(); TextView txtTitle = (TextView) view.findViewById(R.id.text_title); if (selected) &#123; txtTitle.setTextColor(Color.parseColor("#03ce97")); &#125; else &#123; txtTitle.setTextColor(Color.parseColor("#333333")); &#125; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; //自定义获取Tab View的方法 public View getTabView(int position) &#123; View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.custom_tab_item, null); TextView tv = (TextView) view.findViewById(R.id.text_title); tv.setText("Tab " + position); return view; &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 从效果图上看，已经实现了自定义的TabItem，需要注意的是需要根据Tab的选中状态来，实现自己想要的效果，包括Tab字体颜色的改变，图标的旋转效果，选中Tab放大等等…… 我这里只实现了文字颜色的改变，和再次选中弹出对话框。如果我们只是需要图文显示，我们不自定义TabItem也可以实现类似这种效果，直接在getPageTitle中使用ImageSpan让文字和图片一起显示。12345678910//TabLayout会根据当前page的title自动绑定tab@Overridepublic CharSequence getPageTitle(int position) &#123; Drawable image = ContextCompat.getDrawable(MainActivity.this, R.mipmap.ic_indicator); image.setBounds(0, 0, image.getIntrinsicWidth(), image.getIntrinsicHeight()); ImageSpan imageSpan = new ImageSpan(image, ImageSpan.ALIGN_BOTTOM); SpannableString ss = new SpannableString("Tab" + position + " "); ss.setSpan(imageSpan, ss.length() - 1, ss.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); return ss;&#125; 5 源码分析实现上述效果不分析波源码都不够装13的，其实也不是我想分析，只是偶然看到，然后使用了一下感觉并不是很灵活，不太明白官方为什么要这样做。网上有很多分析TabLayout，关于这个自定义TabItem源码，但是没有看见分析这一段的。有兴趣的可以跟着看看，直接跟踪Tab的setCustomView，找到TabView的update方法，代码不长60来行：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final void update() &#123; final Tab tab = mTab; //获取Tab里面的CustomView final View custom = tab != null ? tab.getCustomView() : null; //根据获取出来的custom做相应操作，得到最终的CustomView if (custom != null) &#123; final ViewParent customParent = custom.getParent(); if (customParent != this) &#123; if (customParent != null) &#123; ((ViewGroup) customParent).removeView(custom); &#125; addView(custom); &#125; mCustomView = custom; //custom不为空，且判断和处理系统本身的mTextView、mIconView if (mTextView != null) &#123; mTextView.setVisibility(GONE); &#125; if (mIconView != null) &#123; mIconView.setVisibility(GONE); mIconView.setImageDrawable(null); &#125; //注意这里！！！从custom去获取ID为android.R.id.text1 //我猜想系统是想让我们自定义CustomView的时候使用这个id mCustomTextView = (TextView) custom.findViewById(android.R.id.text1); if (mCustomTextView != null) &#123; mDefaultMaxLines = TextViewCompat.getMaxLines(mCustomTextView); &#125; //注意这里！！！从custom去获取ID为android.R.id.icon //我猜想系统是想让我们自定义CustomView的时候使用这个id mCustomIconView = (ImageView) custom.findViewById(android.R.id.icon); &#125; else &#123; //这里注释很清楚了，就不多说了 // We do not have a custom view. Remove one if it already exists if (mCustomView != null) &#123; removeView(mCustomView); mCustomView = null; &#125; mCustomTextView = null; mCustomIconView = null; &#125; //接下来就是判断CustomView做一些操作了 if (mCustomView == null) &#123; //这里的意思是没有自定义的，就创建默认的 // If there isn't a custom view, we'll us our own in-built layouts if (mIconView == null) &#123; ImageView iconView = (ImageView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_icon, this, false); addView(iconView, 0); mIconView = iconView; &#125; if (mTextView == null) &#123; TextView textView = (TextView) LayoutInflater.from(getContext()) .inflate(R.layout.design_layout_tab_text, this, false); addView(textView); mTextView = textView; mDefaultMaxLines = TextViewCompat.getMaxLines(mTextView); &#125; TextViewCompat.setTextAppearance(mTextView, mTabTextAppearance); if (mTabTextColors != null) &#123; //设置文本颜色（选中和未选中） mTextView.setTextColor(mTabTextColors); &#125; //更新文本和图标 updateTextAndIcon(mTextView, mIconView); &#125; else &#123; // Else, we'll see if there is a TextView or ImageView present and update them if (mCustomTextView != null || mCustomIconView != null) &#123; //更新文本和图标 updateTextAndIcon(mCustomTextView, mCustomIconView); &#125; &#125; // Finally update our selected state setSelected(tab != null &amp;&amp; tab.isSelected());&#125; 关于源码的分析都注释在代码里，对应着代码看，更加清晰。通过源码分析，系统好像想让我们使用那两个id（如果只有TextView和ImageView的话），这样的话是不是我们就不用处理一些逻辑了，使用起来更加easy了呢？答案当然是否定的，我测试的效果是文本的颜色不会根据TabLayout里面设置的一样改变，而且图标距底部有一个8dp的margin值。为什么呢？文本颜色不变从上面那段代码可以看出来，当我们有CustomView时，并没有给我们调用相应的setTextColor。底边距就得继续看updateTextAndIcon方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void updateTextAndIcon(@Nullable final TextView textView, @Nullable final ImageView iconView) &#123; //下面一段没什么好说的，就是获取Drawable 和CharSequence并设置显示或隐藏 final Drawable icon = mTab != null ? mTab.getIcon() : null; final CharSequence text = mTab != null ? mTab.getText() : null; final CharSequence contentDesc = mTab != null ? mTab.getContentDescription() : null; if (iconView != null) &#123; if (icon != null) &#123; iconView.setImageDrawable(icon); iconView.setVisibility(VISIBLE); setVisibility(VISIBLE); &#125; else &#123; iconView.setVisibility(GONE); iconView.setImageDrawable(null); &#125; iconView.setContentDescription(contentDesc); &#125; final boolean hasText = !TextUtils.isEmpty(text); if (textView != null) &#123; if (hasText) &#123; textView.setText(text); textView.setVisibility(VISIBLE); setVisibility(VISIBLE); &#125; else &#123; textView.setVisibility(GONE); textView.setText(null); &#125; textView.setContentDescription(contentDesc); &#125; if (iconView != null) &#123; //获取出layout参数 MarginLayoutParams lp = ((MarginLayoutParams) iconView.getLayoutParams()); int bottomMargin = 0; if (hasText &amp;&amp; iconView.getVisibility() == VISIBLE) &#123; /这里说得很清楚，如果两者都显示，就给icon的bottom加一些底边距 // If we're showing both text and icon, add some margin bottom to the icon bottomMargin = dpToPx(DEFAULT_GAP_TEXT_ICON); //8dp &#125; //判断它加的一些底边距和布局设置的不一致，就使用它加的，并请求重绘 if (bottomMargin != lp.bottomMargin) &#123; lp.bottomMargin = bottomMargin; iconView.requestLayout(); &#125; &#125; if (!hasText &amp;&amp; !TextUtils.isEmpty(contentDesc)) &#123; setOnLongClickListener(this); &#125; else &#123; setOnLongClickListener(null); setLongClickable(false); &#125;&#125; 实际效果就不给出了，还是大家手动测测，关于布局将TextView和ImageView的id改为@android:id/text1和@android:id/icon就OK了。需要注意的是还得手动在代码里设置上文本的颜色和根据需求的MarginLayoutParams，下面直接给出代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MainActivity extends BaseActivity implements TabLayout.OnTabSelectedListener &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(R.id.tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; TabLayout.Tab tab = mTabLayout.getTabAt(i); if (tab == null) return; //设置自定义的View tab.setCustomView(R.layout.custom_tab_item); tab.setText("Tab" + i); tab.setIcon(R.mipmap.ic_indicator); View customView = tab.getCustomView(); if (customView == null) return; //注意设置了文本颜色和MarginLayoutParams ((TextView) customView.findViewById(android.R.id.text1)).setTextColor(mTabLayout.getTabTextColors()); View icon = customView.findViewById(android.R.id.icon); ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) icon.getLayoutParams(); layoutParams.bottomMargin = 0; icon.setLayoutParams(layoutParams); &#125; //需要自己实现选中监听，来实现自己需要的效果 mTabLayout.addOnTabSelectedListener(this); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; @Override public void onTabSelected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; new AlertDialog.Builder(this) .setMessage("再次选中，显示对话框！") .show(); &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 废话太多了，原生TabLayout使用就这么多，源码中真是变化万千。如果希望实现更多酷炫效果，可以自定义或者GitHub….. 附： Android TabLayout系列之属性 Android TabLayout系列之简单使用 Android TabLayout系列之进阶使用]]></content>
      <categories>
        <category>Android</category>
        <category>TabLayout</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TabLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TabLayout系列之简单使用]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-TabLayout%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1 前言在上一篇 Android TabLayout系列之属性 中我们介绍了TabLayout的属性，同时也给出了一些简单的效果图。但是没有具体到它的使用，今天就来看看TabLayout的简单使用。不知道大家留意到我们仿网易的效果布局中，我们明明是写的小写字母，字母就变成大写了，还有字体大小能改变否？我们一步一步来解决这些问题…… 2 使用介绍一种在实际开发中TabLayout较为常用的方式，那就是和ViewPager配合使用，实现联动。首先看看xml布局：1234567891011121314151617181920212223&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabBackground="@android:color/white" app:tabIndicatorColor="@android:color/holo_red_light" app:tabIndicatorHeight="2dp" app:tabMode="scrollable" app:tabSelectedTextColor="@android:color/holo_red_light" app:tabTextColor="@android:color/darker_gray"/&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 是不是很简单的布局，就只有一个TabLayout和ViewPager垂直排列，其实这个还不是官方的布局样式，官方的是这样的：12345678910111213141516171819202122232425&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabBackground="@android:color/white" app:tabIndicatorColor="@android:color/holo_red_light" app:tabIndicatorHeight="2dp" app:tabMode="scrollable" app:tabSelectedTextColor="@android:color/holo_red_light" app:tabTextColor="@android:color/darker_gray"/&gt; &lt;android.support.v4.view.ViewPager/&gt;&lt;/LinearLayout&gt; 第一种是我们常见到的，第二种是官方的，两种的区别是官方这种写法不用调用setupWithViewPager方法。接下来我们看看Activity的代码怎么实现的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(R.id.viewPager); for (int i = 0; i &lt; 11; i++) &#123; //为TabLayout添加10个tab并设置上文本 mTabLayout.addTab(mTabLayout.newTab().setText("Tab " + i)); &#125; mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 接下来是BlankFragment的实现：12345678910111213141516171819202122232425public class BlankFragment extends Fragment &#123; private int index; public BlankFragment() &#123; // Required empty public constructor &#125; public static Fragment newInstance(int position) &#123; BlankFragment fragment = new BlankFragment(); fragment.index = position; return fragment; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_blank, container, false); &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); ((TextView) view.findViewById(R.id.textView)).setText("this Tab " + index); &#125;&#125; 这里需要先解释newTab，这个newTab是使用TabLayout中默认的Tab实现。从它的实现可以看到它支持设置图标，标题和内容描述（图标描述）。1234567891011121314151617181920 public static final class Tab &#123; /** * An invalid position for a tab. * * @see #getPosition() */ public static final int INVALID_POSITION = -1; private Object mTag; private Drawable mIcon; private CharSequence mText; private CharSequence mContentDesc; private int mPosition = INVALID_POSITION; private View mCustomView; TabLayout mParent; TabView mView;..... &#125; Tab默认图标在标题的上方，还有xml里面设置TabItem的话，最终也是设置到Tab上。关于Tab就说明这些，具体的大家可以自行测试。可以看到关于TabLayout的实现也很简单，就是给布局里面的TextView设置了文本显示当前是第几个Tab。布局就更简单了，FrameLayout中嵌套了一个TextView，就不单独给出了。接下来我们就可以来瞅一瞅实际的使用效果了。 3 “填坑”与源码解析 源码解析看到上面的效果图是不是觉得很怪异？没错，我们所设置的Tab上的文字没了，只有下面的指示条。相信大家一通搜索后，相信大家都知道了，最常见的就是分析源码后得出结论，被remove了！！！接下来我们也来装下文化人，看看怎么回事？首先是TabLayout的setupWithViewPager方法，一顿单击后会到达如下源码位置：1234567891011121314151617181920212223242526272829303132private void setupWithViewPager(@Nullable final ViewPager viewPager, boolean autoRefresh, boolean implicitSetup) &#123; if (mViewPager != null) &#123; // If we've already been setup with a ViewPager, remove us from it if (mPageChangeListener != null) &#123; mViewPager.removeOnPageChangeListener(mPageChangeListener); &#125; if (mAdapterChangeListener != null) &#123; mViewPager.removeOnAdapterChangeListener(mAdapterChangeListener); &#125; &#125;............ if (adapter != null) &#123; // Now we'll populate ourselves from the pager adapter, adding an observer if // autoRefresh is enabled setPagerAdapter(adapter, autoRefresh); &#125;............ // Now update the scroll position to match the ViewPager's current item setScrollPosition(viewPager.getCurrentItem(), 0f, true); &#125; else &#123; // We've been given a null ViewPager so we need to clear out the internal state, // listeners and observers mViewPager = null; setPagerAdapter(null, false); &#125; mSetupViewPagerImplicitly = implicitSetup; &#125; 这里没什么说的就是设置判断移除、设置监听等操作，我们最主要去找到网上最多叙述问题所在的源码位置，接下来我们看setPagerAdapter：12345678910111213141516171819void setPagerAdapter(@Nullable final PagerAdapter adapter, final boolean addObserver) &#123; if (mPagerAdapter != null &amp;&amp; mPagerAdapterObserver != null) &#123; // If we already have a PagerAdapter, unregister our observer mPagerAdapter.unregisterDataSetObserver(mPagerAdapterObserver); &#125; mPagerAdapter = adapter; if (addObserver &amp;&amp; adapter != null) &#123; // Register our observer on the new adapter if (mPagerAdapterObserver == null) &#123; mPagerAdapterObserver = new PagerAdapterObserver(); &#125; adapter.registerDataSetObserver(mPagerAdapterObserver); &#125; // Finally make sure we reflect the new adapter populateFromPagerAdapter();&#125; 这段代码主要是判断之前的mPagerAdapter是否为空，不为空就移除DataSetObserver监听，将新的adapter设置进来并注册上DataSetObserver监听。这里我们捕获方法populateFromPagerAdapter一枚，我们再看看它的实现：12345678910111213void populateFromPagerAdapter() &#123; removeAllTabs(); if (mPagerAdapter != null) &#123; final int adapterCount = mPagerAdapter.getCount(); for (int i = 0; i &lt; adapterCount; i++) &#123; addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false); &#125; // Make sure we reflect the currently set ViewPager item ...... &#125;&#125; 哇塞！removeAllTabs，大家说得最多的一个方法，观看方法名就很吓人了，remove all tabs….看看它到底干了什么：123456789101112131415public void removeAllTabs() &#123; // Remove all the views for (int i = mTabStrip.getChildCount() - 1; i &gt;= 0; i--) &#123; removeTabViewAt(i); &#125; for (final Iterator&lt;Tab&gt; i = mTabs.iterator(); i.hasNext();) &#123; final Tab tab = i.next(); i.remove(); tab.reset(); sTabPool.release(tab); &#125; mSelectedTab = null;&#125; 它果真和它的命名一样，遍历remove了所有的tab，并且将当前选中也置为null。怎么办？难道Google故意留下这么个坑？我们继续看上面的populateFromPagerAdapter，会发现removeAllTabs后，它会判断adapter是否为空，不为空就调用了addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false)添加上了新的tab。 “填坑”思路 从上面的分析，我们发现如果要有tab还得去重写adapter的getPageTitle方法。再看一段官方文档中的说明： If you’re using a ViewPager together with this layout, you can call setupWithViewPager(ViewPager)to link the two together. This layout will be automatically populated from the PagerAdapter‘s page titles. 就是说官方推荐我们使用setupWithViewPager(ViewPager)来关联Tablayout和Viewpager，且TabLayout会自动填充PagerAdapter的Title。也就是说它会自动创建tab，并绑定为adapter的page title。这下我们来改造下Activity：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; //TabLayout会根据当前page的title自动绑定tab @Override public CharSequence getPageTitle(int position) &#123; return "Tab " + position; &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 这就是新的Activity实现，改动很小。我们首先删除了initView中关于tab的初始化操作，然后重写了FragmentPagerAdapter的getPageTitle方法。 我们既然知道他会自动为我们绑定tab，那么我们可以利用它自动帮我绑定tab，而不去重写getPageTitle方法，在绑定后去设置关于tab的显示。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(R.id.viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //官方推荐的绑定ViewPager方式 mTabLayout.setupWithViewPager(mViewPager); int tabCount = mTabLayout.getTabCount(); for (int i = 0; i &lt; tabCount; i++) &#123; //这里tab可能为null 根据实际情况处理吧 mTabLayout.getTabAt(i).setText("Tab" + i); &#125; &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 可以看到只是将initView中初始化Tab的位置调整到setupWithViewPager的后面，设置上我们需要的标题。这里效果和上面一样就不给出来占篇幅了。 上面我们依旧利用了setupWithViewPager自动为我们绑定tab的实现，在分析源码的时候发现它会调用ViewPager的addOnPageChangeListener和TabLayout的addOnTabSelectedListener，实现TabLayout与ViewPager的关联。那么我们就自己来实现关联，不去使用官方推荐的setupWithViewPager方法绑定。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MainActivity extends BaseActivity &#123; private TabLayout mTabLayout; private ViewPager mViewPager; private MainPagerAdapter mAdapter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; AppStatusTracker.init(getApplication()); super.onCreate(savedInstanceState); &#125; @Override protected void initContentView() &#123; setContentView(R.layout.activity_main); &#125; @Override protected void initView() &#123; mTabLayout = findView(tabLayout); mViewPager = findView(viewPager); mAdapter = new MainPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mAdapter); //初始化tab for (int i = 0; i &lt; 10; i++) &#123; mTabLayout.addTab(mTabLayout.newTab().setText("item" + i)); &#125; //自己实现关联 mViewPager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(mTabLayout)); mTabLayout.addOnTabSelectedListener(new TabLayout.ViewPagerOnTabSelectedListener(mViewPager)); &#125; @Override protected void initData(@Nullable Bundle savedInstanceState) &#123; &#125; //ViewPager适配器 10个Fragment private class MainPagerAdapter extends FragmentPagerAdapter &#123; public MainPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return BlankFragment.newInstance(position); &#125; @Override public int getCount() &#123; return 10; &#125; &#125;&#125; 这段代码，在initView中移除了官方推荐的设置相关代码，自己初始化了tab并实现了关联。注意这里我们改变了Tab的标题作为区分。效果也和上面一样，只是改变了Tab的标题。 4 其他问题这样TabLayout的简单使用就介绍完了，这里还有两个问题一个是TabLayout的标题怎么就是大写了，还有它的文字大小怎么改呢？还记得我怎么在上一篇Android TabLayout系列之属性中介绍的tabTextAppearance属性么？我们就利用它来改变标题字母大小写和文字大小问题。先开看看TabLayout源码中的默认使用：123456789mTabTextAppearance = a.getResourceId(R.styleable.TabLayout_tabTextAppearance,R.style.TextAppearance_Design_Tab);&lt;style name="TextAppearance.Design.Tab" parent="TextAppearance.AppCompat.Button"&gt; &lt;item name="android:textSize"&gt;@dimen/design_tab_text_size&lt;/item&gt; &lt;item name="android:textColor"&gt;?android:textColorSecondary&lt;/item&gt; &lt;item name="textAllCaps"&gt;true&lt;/item&gt;&lt;/style&gt; 我们为Tablayout添加上tabTextAppearance属性：1app:tabTextAppearance="@style/TabLayoutStyle" 这里需要把具体的属性定义到stytle中，这里有两种方式：1234&lt;style name="TabLayoutStyle" parent="TextAppearance.Design.Tab"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; &lt;item name="textAllCaps"&gt;false&lt;/item&gt;&lt;/style&gt; 12345&lt;style name="TabLayoutStyle"&gt; &lt;item name="android:textSize"&gt;16sp&lt;/item&gt; //&lt;item name="textAllCaps"&gt;false&lt;/item&gt; &lt;item name="android:textAllCaps"&gt;false&lt;/item&gt;&lt;/style&gt; 需要注意 parent=”TextAppearance.Design.Tab”时，textAllCaps没有android，当不继承的时候有没有都可以。其实这里的字母大小写，不能算个坑。我们可以看material设计中所有tab的字母都是大写，估计歪果仁标题都习惯大写吧，或者是为了符合material设计，所以默认的Tab被设置成了大写。最后运行效果如下： 这里附上我的build.gradle，有可能不同版本会有不一样的效果，所以大家实际使用的时候需要注意一下：123456789101112131415161718192021android &#123; compileSdkVersion 25 buildToolsVersion "25.0.1" defaultConfig &#123; applicationId "com.joker.demo" minSdkVersion 19 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; TabLayou的简单使用就介绍这么多，其实真的是简单使用，主要是中间插入了一段源码分析，所以看起来多了点。附： Android TabLayout系列之属性 Android TabLayout系列之简单使用 Android TabLayout系列之进阶使用]]></content>
      <categories>
        <category>Android</category>
        <category>TabLayout</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TabLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TabLayout系列之属性]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-TabLayout%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1 前言以前没有写博客的习惯，需要什么东西都是直接搜索，然后再来看怎么使用，有什么需要注意的，时间久了也就忘了是怎么回事了，又得重复这个过程。比如这个今天要介绍的TabLyout，很久之前用过，最近又需要用到，但是已经忘了怎么使用了，这也是为什么最近开始在简书上开始记录的原因。废话不多说…其实Android在5.1（22.2.0）的时候给我们提供了一个水平布局来显示标签TabLayout，实际应用中也有很多需要横向标签的应用场景。直接先来看个效果图（偷的网易的）： 2 TabLayout简单使用今天这篇文章是奔着TabLayout的属性来的，就用最简单的使用方式来介绍它的属性。我们在xml文件中直接使用TabLayout：1234567891011121314151617181920&lt;android.support.design.widget.TabLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab1"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab2"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab3"/&gt;&lt;/android.support.design.widget.TabLayout&gt; 看上去还是有那么点标签的意思…接下来就正式介绍它的属性了。 3 属性介绍 背景颜色 1app:tabBackground="@android:color/white" 选中tab字体颜色 1app:tabSelectedTextColor="@android:color/holo_red_light" 未选中tab字体颜色 1app:tabTextColor="@android:color/holo_blue_dark" 指示器颜色 1app:tabIndicatorColor="@android:color/holo_green_dark" 设置完演的后的TabLayout: 指示器高度1app:tabIndicatorHeight="5dp" tabY轴偏移量（没看出效果） 1app:tabContentStart="100dp" tab显示方式 1app:tabGravity="center" //center：居中 fill：充满 tab最大最小宽度 12app:tabMaxWidth="100dp"app:tabMinWidth="100dp" tab布局模式 1app:tabMode="scrollable" //可取fixed 固定,scrollable 滚动，默认fixed：标签很多时候会被挤压，不能滑动。 Tab里内容的内边距 12345app:tabPadding="10dp"app:tabPaddingStart="10dp"app:tabPaddingEnd="10dp"app:tabPaddingTop="10dp"app:tabPaddingBottom="10dp" tab文字大小设置 1app:tabTextAppearance="@style/Base.TextAppearance.AppCompat.Large" 以上就是TabLayout的基本属性，接下来我们用这些基本属性实现一个类似文章开头的效果:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;android.support.v4.view.ViewPager android:id="@+id/viewPager" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tabLayout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabBackground="@android:color/white" app:tabIndicatorColor="@android:color/holo_red_light" app:tabIndicatorHeight="2dp" app:tabMode="scrollable" app:tabSelectedTextColor="@android:color/holo_red_light" app:tabTextColor="@android:color/darker_gray"&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab1"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab2"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab3"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab4"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab5"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab6"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab7"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab8"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab9"/&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="tab10"/&gt; &lt;/android.support.design.widget.TabLayout&gt;&lt;/android.support.v4.view.ViewPager&gt; TabLayout属性就介绍到这里，接下来的文章会具体介绍它的使用。 附： Android TabLayout系列之属性 Android TabLayout系列之简单使用 Android TabLayout系列之进阶使用]]></content>
      <categories>
        <category>Android</category>
        <category>TabLayout</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TabLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的线程池与队列]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Android中的线程池来源于Java中的Executor接口，真正的线程池实现为ThreadPoolExecutor，它提供参数来配置线程池。既然提到线程池，首先得了解线程池有什么有点，线程池的优点主要有以下3点： 线程重用，通过重用线程池中线程避免反复创建和销毁县城带来的性能开销问题。 控制并发数，避免大量线程同时工作抢占系统资源造成阻塞。 简单的线程管理，实现定时执行等功能。 一 ThreadPoolExecutor1) ThreadPoolExecutor 构造器1234567891011//使用给定的参数和默认线程工厂、拒绝执行的Handler创建一个新的ThreadPoolExecutor ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) //使用给定的参数和拒绝执行的Handler创建一个新的ThreadPoolExecutor。ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)//使用给定的参数和默认线程工厂创建一个新的ThreadPoolExecutorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)//使用给定的参数创建一个新的ThreadPoolExecutorThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 2) ThreadPoolExecutor 构造器参数说明 corePoolSize 核心线程数（常驻线程数）一直保持在线程池的线程数，空闲状态也不会退出，除非设置allowCoreThreadTimeOut为true maximumPoolSize 最大线程数线程池中允许存在的最大线程数 keepAliveTime 保持活跃时间当线程数大于核心线程数时，这是超出空闲线程在终止之前等待新任务的最大时间。当allowCoreThreadTimeOut为true时，也适用与核心线程 unit 单位keepAliveTime参数的时间单位 workQueue 任务队列在执行任务之前用于保存任务的队列。 该队列将仅保存由（Runnable的execute）方法提交的任务。 threadFactory 线程工厂executor创建新线程的时候使用 handler 拒绝执行的handler当线程池无法执行新任务，导致执行被阻止时使用的处理程序，可能因为线程达到线程限制和队列容量 3) ThreadPoolExecutor执行任务时大致规则 线程池中线程数小于核心线程数，会直接启动一个核心线程来执行新任务 线程池中线程数大于等于核心线程数， 将会将新任务存放到任务队列等待执行 线程池中线程数大于等于核心线程数，且任务队列已满，但线程池中线程数小于最大线程数，将会启动一个非核心线程来执行任务 线程池中线程数大于等于最大线程数，那么就会拒绝执行该任务，调用handler的rejectedException来通知调用者 4) ThreadPoolExecutor在AsyncTask中的使用123456789101112131415161718192021222324private static final String LOG_TAG = "AsyncTask";private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 通过源码，我们可以看到AsyncTask的THREAD_POOL_EXECUTOR属性配置如下： 核心线程数（CORE_POOL_SIZE）为CPU核心数+1 最大线程数（MAXIMUM_POOL_SIZE）为CPU核心数 * 2 + 1 非核心线程保持活跃时间为1，单位为秒 任务队列容量为128 以上对ThreadPoolExecutor和AsyncTask中的ThreadPoolExecutor配置进行了介绍。在Android中通过对ThreadPoolExecutor的配置实现了四类不同功能特性的线程池，接下来我们就对Android中的这四类线程池进行一个简单介绍 二 FixedThreadPool通过Executors.newFixedThreadPool创建一个线程池，它使用固定数量的线程操作了共享无界队列。在任何时候，大多数线程都是主动处理任务的。如果在所有线程处于活动状态时提交其他任务，则它们将在队列中等待，直到有线程空闲可用为止。如果任何线程在关闭前在执行过程中失败，如果需要执行后续任务，则新线程将取代它。线程池中线程会一致存在，直到线程池明确关闭（shutdown）。下面是它的实现，可以看到它只有不会被回收的核心线程，队列大小也没有限制。12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 三 CachedThreadPool通过Executors.newCachedThreadPool创建一个线程池，根据需要创建新线程，但在可用线程时将重用以前构建的线程。这些池通常会提高执行许多短期异步任务的程序的性能。如果先前创建线程可用的话，调用将重用先前构建的线程。如果没有现有的线程可用，一个新线程将被创建并添加到池。未使用六十秒的线程被终止并从缓存中移除。因此，空闲时间足够长的池不会消耗任何系统资源。下面是它的实现，可以看到与ThreadPoolExecutor不同的是它没有核心线程，最大线程数为Integer.MAX_VALUE，且CachedThreadPool的任务队列是一个SynchronousQueue的空集合，这将导致任务会被立即执行，所以这类线程比较适合执行大量耗时较少的任务。12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 四 ScheduledThreadPool通过Executors.newScheduledThreadPoo创建一个线程池，可以在给定延迟后调度命令运行，或定期执行命令。它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 五 newSingleThreadScheduledExecutor通过Executors.newSingleThreadScheduledExecutor创建一个单线程执行器，可以在给定延迟后调度命令运行，或定期执行命令。任务是按顺序执行的，在任何给定的时间内都不会有一个任务处于活动状态，让调用者可以忽略线程同步问题。123456789public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; 六 线程池一般用法 shutDown()，关闭线程池，需要执行完已提交的任务 shutDownNow()，关闭线程池，并尝试结束已提交的任务 allowCoreThreadTimeOut(boolen)，允许核心线程闲置超时回收 execute()，提交任务无返回值 submit()，提交任务有返回值 除了上面4种线程池，还可以根据实际需求自定义线程池。 七 自定义线程池1ExecutorService mExecutor = Executors.newFixedThreadPool(5); execute()方法，接收一个Runnable对象作为参数，异步执行。1234567Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; Log.i("myRunnable", "run"); &#125;&#125;;mExecutor.execute(myRunnable); 八 队列简述Queue的成员函数 add 增加一个元索 如果队列已满，则抛出一个IIIegaISlabEepeplian异常 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 element 返回队列头部的元素 如果队列为空，则抛出一个NoSuchElementException异常 offer 添加一个元素并返回true 如果队列已满，则返回false poll 移除并返问队列头部的元素 如果队列为空，则返回null peek 返回队列头部的元素 如果队列为空，则返回null put 添加一个元素 如果队列满，则阻塞 take 移除并返回队列头部的元素 如果队列为空，则阻塞 remove、element、offer 、poll、peek 其实是属于Queue接口。 LinkedBlockingQueue是一个链表实现的阻塞队列，在链表一头加入元素，如果队列满，就会阻塞，另一头取出元素，如果队列为空，就会阻塞。 LinkedBlockingQueue内部使用ReentrantLock实现插入锁(putLock)和取出锁(takeLock)。putLock上的条件变量是notFull，即可以用notFull唤醒阻塞在putLock上的线程。takeLock上的条件变量是notEmtpy，即可用notEmpty唤醒阻塞在takeLock上的线程。 知道了LinkedBlockingQueue，再来理解ArrayBlockingQueue就比较好理解了。类似LinkList和ArrayList的区别。如果知道队列的大小，那么使用ArrayBlockIngQueue就比较合适了，因为它使用循环数组实现，但是如果不知道队列未来的大小，那么使用ArrayBlockingQueue就必然会导致数组的来回复制，降低效率。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 从入门到实战 学习笔记]]></title>
    <url>%2F2018%2F01%2F02%2FGradle-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Gradle是目前为止Android的主流构建工具，不管用命令行还是Android Studio来build项目，Gradle都不可或缺。Gradle不单单是一个配置脚本，更是Groovy Language、Gradle DSL、Android DSL 3门语言的组合( DSL的全称是Domain Specific Language，即领域特定语言 )。学习来源Gradle从入门到实战 - Groovy基础，学习主要内容如下： Groovy基础 全面理解Gradle 分析Android的build tools插件 从0到1完成一款Gradle插件 一 Groovy基础通过def关键字声明变量和方法：12345678def a = 1;def b = "hello";def int c = 2;def hello() &#123; println ("hello world!"); return 1;&#125; 在Groovy中语法中，很多地方可以省略： 语句后面的分号可以省略 变量类型可以省略 方法的参数类型和返回值可以省略 方法调用括号可以省略 方法中return关键字也可以省略 所以上面代码这样写也是正确的：1234567891011121314151617181920212223def a = 1 //省略分号def b = "hello"def c = 2def hello() &#123; println "hello world!" //省略调用时括号 1 //省略return&#125;def hello(String msg)&#123; println msg&#125;int hello(msg)&#123; //省略参数类型 println (msg) return 1&#125;int hello(msg)&#123; println msg return 1 // 这个return不能省略 println "done"&#125; 总结 在Groovy中，类型是弱化的，所有的类型都可以动态推断，但是Groovy仍然是强类型的语言，类型不匹配仍然会报错 在Groovy中很多东西都可以省略，所以寻找一种自己喜欢的写法 Groovy中的注释和Java中相同 二 Groovy的数据类型在Groovy中，数据类型有： Java中的基本数据类型 Java中的对象 Closure（闭包） 加强的List、Map等集合类型 加强的File、Stream等IO类型 类型可以显示声明，也可以用 def 来声明，用 def 声明的类型Groovy将会进行类型推断 String 12345def a = 1def b = "hello"def c = "a = $&#123;a&#125;, b = $&#123;b&#125;"println c outputs: a = 1, b = hello 闭包(Closure)闭包在很多语言都存在，类似于C语言的指针。闭包作为一种特殊的数据类型而存在，闭包可以作为方法的参数和返回值，也可以作为一个变量 声明闭包：1234&#123; parameters -&gt; code&#125; 闭包可以有返回和参数，也可以没有。看看以下例子：123456789101112131415161718192021def closure = &#123; int a, String b -&gt; println "a = $&#123;a&#125;, b = $&#123;b&#125;, This is a Closure!"&#125;def test = &#123; a, b -&gt; println "a = $&#123;a&#125;, b = $&#123;b&#125;, This is a Closure!"&#125;def sum = &#123; a, b -&gt; a + b&#125;// 这里省略了闭包的参数类型def testIt = &#123; println "find $&#123;it&#125;, This is a Closure!"&#125;closure(100, 200)test.call(100, "test")println sum(100, 200)testIt(100) 闭包不指定参数，那么会隐含一个参数it,闭包可以当做函数一样使用，上例将得到以下输出：1234a = 100, b = 200, This is a Closure!a = 100, b = test, This is a Closure!300find 100, This is a Closure! 闭包的一个难题是如何确定闭包的参数，尤其当我们调用Groovy的API时，这个时候没有其他办法，只有查询Groovy的文档：http://www.groovy-lang.org/api.htmlhttp://docs.groovy-lang.org/latest/html/groovy-jdk/index-all.html List和Map 123456789def emptyList = []def test = [100, "hello", true]test[1] = "world"test &lt;&lt; 200println test.sizeprintln test[0]println test[1]println test[2]println test[3] outputs: 100 world true 200 上例中操作符&lt;&lt;，表示向List中新增加元素123456def emptyMap = [:]def test = ["id":1, "name":"test", "isMale":true]test["id"] = 2test.id = 900println test.idprintln test.isMale outputs: 900 true 通过闭包对Map进行遍历，如果闭包传递2个参数就是遍历key，value；如果不传参就是遍历entry：12345678def emptyMap = [:]def test = ["id":1, "name":"test", "isMale":true]test.each&#123; key, value -&gt; println "two params, key = $&#123;key&#125;, value = $&#123;value&#125;"&#125;test.each&#123; println "one param, key = $&#123;it.key&#125;, value = $&#123;it.value&#125;"&#125; 文件I/OGroovy在使用I / O时提供了许多辅助方法，让文件操作比java中简单很多。下面举例，具体使用请查阅API： 1234567891011def file = new File("E:/Example.txt")println "-------------------------------"file.eachLine&#123; line -&gt; //一行一行读取文件 println "read line: $line"&#125;println "-------------------------------"file.eachLine&#123; line, lineNum -&gt; println "read line $&#123;lineNum&#125;: $line"&#125;println "-------------------------------"println file.text //将文本以字符串读取 outputs: ------------------------------- read line: hello read line: 你好 ------------------------------- read line 1: hello read line 2: 你好 ------------------------------- hello 你好 接下来看看xml文件访问，也是比Java中简单多了Groovy访问xml有两个类：XmlParser和XmlSlurper，二者几乎一样，在性能上有细微的差别，具体的也请查看具体API。接下来看看示例，首先假设我们有attrs.xml文件：1234567&lt;resources&gt;&lt;declare-styleable name="CircleView"&gt; &lt;attr name="circle_color" format="color"&gt;#98ff02&lt;/attr&gt; &lt;attr name="circle_size" format="integer"&gt;100&lt;/attr&gt; &lt;attr name="circle_title" format="string"&gt;xml&lt;/attr&gt;&lt;/declare-styleable&gt;&lt;/resources&gt; 对xml文件操作12345def xml = new XmlParser().parse(new File("attrs.xml"))// 访问declare-styleable节点的name属性println xml['declare-styleable'].@name[0]// 访问declare-styleable的第三个子节点的内容println xml['declare-styleable'].attr[2].text() 123outputs：CircleViewxml 三 Groovy的其他特性 在Groovy中，如在任何其他面向对象语言中一样，存在类和对象的概念以表示编程语言的对象定向性质。 123456789101112131415class Student &#123; int id String Name static void main(String[] args) &#123; Student st = new Student(); st.id= 1 st.Name= "Joe" fun(Student .class) //参数为class类型，可省略.class后缀 fun(Student) //省略.class后缀 &#125; def func(Class clazz) &#123; &#125;&#125; 在java中使用private关键字隐藏实例成员，而是提供getter和setter方法来相应地设置和获取实例变量的值。Groovy也是一样，不一样的是Groovy中只要有属性就有getter&amp;setter，有getter&amp;setter就有隐含的属性。所以以下两个类是一样的 123456789101112131415class Student &#123; private int id void setId(int id) &#123; this.id = id &#125; int getId() &#123; return this.id &#125;&#125;class Student &#123; private int id&#125; 在Groovy中，当对同一个对象进行操作时，可以使用with操作符，比如： 1234567891011121314class Student &#123; int id String name static void main(String[] args) &#123; Student st = new Student(); st.id= 1 st.name= "Joe" //以上操作可以简化为 st.with&#123; id = 1 name = "Joe" &#125; &#125; &#125; 在Groovy中，判断是否为真可以更简洁： 123if (name != null &amp;&amp; name.length &gt; 0) &#123;&#125;//Groovy中简写if (name) &#123;&#125; 在Groovy中，更加简洁的三目运算： 1234def name = "name"def result = name != null ? name : "test"//Groovy中简写def result = name ? : "test" 非空判断 12345678910if (order != null) &#123; if (order.getCustomer() != null) &#123; if (order.getCustomer().getAddress() != null) &#123; System.out.println(order.getCustomer().getAddress()); &#125; &#125;&#125;//Groovy中简写println order?.customer?.address equals和==，Groovy中==与Java中equals一致，如果需要判断是否为同一对象需要使用.is() 12345Object a = new Object()Object b = a.clone()assert a == b //判断相等assert !a.is(b) //判断是否是同一对象 断言关键字assert的使用 1234def check(String name) &#123; assert name assert name?.size() &gt; 3 //如果断言结果为false将抛出异常&#125; 在Groovy中，switch方法更加灵活，可以同时支持更多的参数类型 123456789101112131415161718192021在Groovy中，switch方法变得更加灵活，可以同时支持更多的参数类型：def x = 1.23def result = ""switch (x) &#123; case "foo": result = "found foo" // lets fall through case "bar": result += "bar" case [4, 5, 6, 'inList']: result = "list" break case 12..30: result = "range" break case Integer: result = "integer" break case Number: result = "number" break case &#123; it &gt; 3 &#125;: result = "number &gt; 3" break default: result = "default"&#125;assert result == "number" 四 编译并运行Groovy我们可以通过下载和安装Groovy sdk来编译和运行，但是我们是为了学习Gradle，所以这里不用搞得过于复杂。推荐如下操作来编译和运行Groovy： 首先在任意文件夹创建build.gradle 在build.gradle中创建一个task 使用gradle test命令编译和运行 拿上面的一个例子（可能需要配置环境变量，请自行百度，其实和Java环境变量配置方法一致），来做一个完整示例： 1234567891011121314151617task(test).doLast &#123; println "start execute test" doTest()&#125;def doTest() &#123; def emptyList = [] def test = [100, "hello", true] test[1] = "world" test &lt;&lt; 200 println "以下是输出内容" println test.size println test[0] println test[1] println test[2] println test[3] println "--------------"&#125; 直接附上cmd命令行编译运行结果截图： 再次感谢：任玉刚 - Gradle从入门到实战]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 7.0权限适配：FileUriExposedException异常]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-7-0%E6%9D%83%E9%99%90%E9%80%82%E9%85%8D%EF%BC%9AFileUriExposedException%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[今天来聊聊Android 7.0 FileUriExposedException异常，以及它的使用方法和使用场景 一 描述 问题对于面向 Android 7.0 的应用，Android 框架执行的 StrictModeAPI 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException异常 解决方案要在应用间共享文件，您应发送一项 content://URI，并授予 URI 临时访问权限。进行此授权的最简单方式除了将targetSdkVersion改成24以下，就是使用 FileProvider类 官网对FileProvider描述： FileProvider是ContentProvider的一个特殊子类，它通过创建内容来实现与应用程序相关联的文件的安全共享：// Uri用于文件，而不是文件：/// Uri。 内容URI允许您使用临时访问权限来授予读取和写入访问权限。当您创建包含内容URI的Intent时，为了将内容URI发送到客户端应用程序，还可以调用Intent.setFlags（）来添加权限。只要接收活动的堆栈处于活动状态，客户端应用程序就可以使用这些权限。对于要访问服务的意图，只要服务正在运行，权限就可用。 相比之下，为了控制对文件的访问：/// Uri你必须修改底层文件的文件系统权限。您提供的权限可用于任何应用程序，并在您更改之前保持有效。这种访问水平基本上是不安全的。 内容URI提供的增加文件访问安全级别使FileProvider成为Android安全基础架构的关键部分。 二 如何使用FileProvider我们先看如何使用FileProvider，官网也有详细说明：https://developer.android.com/reference/android/support/v4/content/FileProvider.html 1. 定义FileProvider由于FileProvider的默认功能，包括内容URI代的文件，你不需要在代码中定义一个子类。我们在manifest中声明provider12345678910111213141516&lt;manifest&gt; ... &lt;application&gt; ... &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="包名.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; android:name 【固定值】 FileProvider的包名+类名android:authorities 【自定义】 推荐以包名+”.fileprovider”方式命名，增加辨别性，系统唯一android:exproted 要求必须为false，为true则会报安全异常android:grantUriPermissions 是否允许为文件设置临时权限 “true”android:resource=”@xml/file_paths”就是我们的共享路径配置的xml文件 2 . 配置file_pathsFileProvider只能生成你事先指定的 content URI，file_paths配置如下：1234567891011&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="external" path=""/&gt; &lt;external-path name="my_images" path="Android/data/包名/files/Pictures/"/&gt; &lt;external-path name="images" path="Pictures/"/&gt;&lt;/paths&gt; 注意： 注： XML文件是你可以指定你要共享的目录的唯一途径，你不能以编程方式添加一个目录，至少配置一个external-path节点 在paths节点内部支持以下几个子节点，分别为： 代表设备的根目录new File(“/“) 代表该文件files/的应用程序的内部存储区的子目录，等同于context.getFilesDir() 代表应用程序的内部存储区域的缓存子目录的文件，等同于context.getCacheDir() 代表在外部存储区根目录的文件，等同于Environment.getExternalStorageDirectory() 代表应用程序的外部存储区根目录的文件，等同于Context.getExternalFilesDir(String) /Context.getExternalFilesDir(null) 代表应用程序的外部缓存区根目录的文件，等同于Context.getExternalCacheDir() file_paths用来指定Uri共享和真实路径的映射关系，name属性的值可以自定义，path属性的值表示共享的具体位置，设置为空，就表示共享整个SD卡，也可指定对应的SDcard下的文件目录，根据需求自行定义 3. 获得content uri使用getUriForFile()将file:// 转换成 content:// Uri fileUri = FileProvider.getUriForFile(this, “包名.fileprovider”, file); 4. 临时读写权限授权需要对接收应用设置读权限或写权限亦或读写均设置：FLAG_GRANT_READ_URI_PERMISSION：读权限FLAG_GRANT_WRITE_URI_PERMISSION：写权限授权方式： 使用Intent.addFlags或setFlags，该方式授权的有效期限，权限截止于该 App 所处的堆栈被销毁自动回收（APP销毁），主要用于针对intent.setData，setDataAndType以及setClipData相关方式传递uri 使用grantUriPermission(String toPackage, Uri uri, int modeFlags)来进行授权，该方式授权的有效期限，从授权一刻开始，手动调用 Context.revokeUriPermission() 方法或者设备重启才截止 三 使用场景a. 相机拍照Android 7.0之前我们这样拍照，没有什么问题（忽略6.0权限问题）：1234567891011121314151617181920212223242526272829303132private static final int REQUEST_TAKE_PHOTO = 0X11;private Uri imageUri ; private void takePhoto() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); //判断是否有相机应用 if (takePictureIntent.resolveActivity(getActivity().getPackageManager()) != null) &#123; //获取存储路径 没有则创建 File directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); if (!directory.exists()) &#123; if (!directory.mkdir()) &#123; return; &#125; &#125; File file = new File(directory.getAbsolutePath(), new SimpleDateFormat("yyyyMMdd-HHmmss", Locale.CHINA) .format(new Date()) + ".jpeg"); imageUri = Uri.fromFile(file); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri); startActivityForResult(takePictureIntent, TAKE_PHOTO); &#125; else &#123; ToastUtil.showShort(getString(R.string.TakePhoto_Error)); &#125;&#125;@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_TAKE_PHOTO) &#123; // 通知图库更新 getActivity().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, imageUri )); &#125;&#125; 如果我们使用Android 7.0或者以上的原生系统运行，发现应用直接停止运行，如文章开头所说抛出了android.os.FileUriExposedException：1234android.os.FileUriExposedException: file:///storage/emulated/0/Pictures/20170723-201847.jpeg exposed beyond app through ClipData.Item.getUri() at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799) at android.net.Uri.checkFileUriExposed(Uri.java:2346) 接下来根据官网的解决办法，如第二步所说配置好 FileProvider，更改拍照方法：123456789101112131415161718192021222324252627private void takePhoto() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); //判断是否有相机应用 if (takePictureIntent.resolveActivity(getActivity().getPackageManager()) != null) &#123; //获取存储路径 没有则创建 File directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); if (!directory.exists()) &#123; if (!directory.mkdir()) &#123; return; &#125; &#125; File file = new File(directory.getAbsolutePath(), new SimpleDateFormat("yyyyMMdd-HHmmss", Locale.CHINA) .format(new Date()) + ".jpeg"); Uri uri = imageUri = Uri.fromFile(file); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //兼容7.0 uri = FileProvider.getUriForFile(getApplication(), "包名.fileprovider", file); //添加权限 这一句表示对目标应用临时授权该Uri所代表的文件 takePictureIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(takePictureIntent, TAKE_PHOTO); &#125; else &#123; ToastUtil.showShort(getString(R.string.TakePhoto_Error)); &#125; &#125; 添加了版本判断，并使用 FileProvider.getUriForFile()获得content Uri，方法主要更改如下：1234567 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //兼容7.0 uri = FileProvider.getUriForFile(getApplication(), "包名.fileprovider", file); //添加权限 这一句表示对目标应用临时授权该Uri所代表的文件 takePictureIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);&#125; 当然也可以不用判断版本，直接使用FileProvider.getUriForFile(getApplication(), “包名.fileprovider”, file)获得Uri替换Uri.fromFile(file)，但是切记需要进行授权和取消授权，否则4.4以下会报Permission Denial b. 图片裁剪1234567891011121314151617181920212223242526272829/** * @param activity 当前activity * @param orgUri 剪裁原图的Uri * @param desUri 剪裁后的图片的Uri * @param aspectX X方向的比例 * @param aspectY Y方向的比例 * @param width 剪裁图片的宽度 * @param height 剪裁图片高度 * @param requestCode 剪裁图片的请求码 */public static void cropImageUri(Activity activity, Uri orgUri, Uri desUri, int aspectX, int aspectY, int width, int height, int requestCode) &#123; Intent intent = new Intent("com.android.camera.action.CROP"); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; intent.setDataAndType(orgUri, "image/*"); intent.putExtra("crop", "true"); intent.putExtra("aspectX", aspectX); intent.putExtra("aspectY", aspectY); intent.putExtra("outputX", width); intent.putExtra("outputY", height); intent.putExtra("scale", true); //将剪切的图片保存到目标Uri中 intent.putExtra(MediaStore.EXTRA_OUTPUT, desUri); intent.putExtra("return-data", false); intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString()); intent.putExtra("noFaceDetection", true); activity.startActivityForResult(intent, requestCode); &#125; c. 安装apk123456789101112// 安装Apkpublic void installApk(Context context) &#123; File file = new File(Environment.getExternalStorageDirectory(), "app.apk"); Intent intent = new Intent(Intent.ACTION_VIEW); Uri uri = Uri.fromFile(file); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; uri = FileProvider.getUriForFile(context, "包名.fileprovider", file); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; intent.setDataAndType(uri, "application/vnd.android.package-archive"); context.startActivity(intent);&#125; 大概使用就这么多，望多多指教。 另附上：官网学习使用FileProvider地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ListView ScrollView回弹效果]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-ListView-ScrollView%E5%9B%9E%E5%BC%B9%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[转自：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/0312/1590.html ios中对可以滚动的视图都在系统层面上实现了触碰到边缘的阻尼回弹效果，用户一看便知自己的操作已经到了边界。android中也有类似的方案，不过当到达边界的时候不是用阻尼的方式，而是逐渐显示一个渐变颜色。ios的那种体验无疑会友好很多，也许是当初ios吵着要把这个设计申请专利的缘故吧，android不得不放弃橡皮筋效果，至少在系统层面。但这不意味着安卓中无法实现和ios一样的效果，这里介绍两种实现的方法。 第一种简单，但是效果不如意，而且必须要在api level大于9的情况下使用： 比如我是要给listview加上阻尼回弹效果，那么只需如下重写listview：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.thinkfeed.bouncelistview;import android.content.Context;import android.util.AttributeSet;import android.util.DisplayMetrics;import android.widget.ListView;public class BounceListView extends ListView&#123; private static final int MAX_Y_OVERSCROLL_DISTANCE = 200; private static final float SCROLL_RATIO = 0.5f;// 阻尼系数 private Context mContext; private int mMaxYOverscrollDistance; public BounceListView(Context context)&#123; super(context); mContext = context; initBounceListView(); &#125; public BounceListView(Context context, AttributeSet attrs)&#123; super(context, attrs); mContext = context; initBounceListView(); &#125; public BounceListView(Context context, AttributeSet attrs, int defStyle)&#123; super(context, attrs, defStyle); mContext = context; initBounceListView(); &#125; private void initBounceListView()&#123; //get the density of the screen and do some maths with it on the max overscroll distance //variable so that you get similar behaviors no matter what the screen size final DisplayMetrics metrics = mContext.getResources().getDisplayMetrics(); final float density = metrics.density; mMaxYOverscrollDistance = (int) (density * MAX_Y_OVERSCROLL_DISTANCE); &#125; @Override protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent)&#123; //This is where the magic happens, we have replaced the incoming maxOverScrollY with our own custom variable mMaxYOverscrollDistance; int newDeltaY = deltaY; int delta = (int) (deltaY * SCROLL_RATIO); if (delta != 0) newDeltaY = delta; return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, mMaxYOverscrollDistance, isTouchEvent); &#125; &#125; 其中deltaX,deltaY为本次滑动偏移，scrollX，scrollY为当前总偏移，为了达到阻尼效果，我们增加了阻尼系数SCROLL_RATIO。但是这个方法受限于api 而且效果并不是很好。在github上看到有人完全重写了ScrollView将橡皮筋效果完美的移植在其中。项目地址：https://github.com/EverythingMe/OverScrollView (注： 此项目已不再维护 作者维护新项目地址：https://github.com/EverythingMe/overscroll-decor)用法和ScrollView一模一样，因为其实就是将系统的ScrollView修改而来。123456&lt;me.everything.android.widget.OverScrollView android:id="@+id/OverScroller" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;.../&gt;&lt;/me.everything.android.widget.OverScrollView&gt; 这个OverScrollView需要稍作修改才能用，不然在第一次加载的时候显示不出来。将原来的onLayout方法替换成下面的代码：123456789101112131415161718192021@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b)&#123; super.onLayout(changed, l, t, r, b); mIsLayoutDirty = false; // Give a child focus if it needs it if (mChildToScrollTo != null &amp;&amp; isViewDescendantOf(mChildToScrollTo, this)) &#123; scrollToChild(mChildToScrollTo); &#125; mChildToScrollTo = null; // Calling this with the present values causes it to re-clam them scrollTo(getScrollX(), getScrollY()); post(new Runnable() &#123; public void run() &#123; scrollTo(0, child.getPaddingTop()); &#125; &#125;); &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Fragment监听返回键]]></title>
    <url>%2F2018%2F01%2F02%2FAndroid-Fragment%E7%9B%91%E5%90%AC%E8%BF%94%E5%9B%9E%E9%94%AE%2F</url>
    <content type="text"><![CDATA[场景：在项目中做联系人界面时，需要按名字和按部门显示联系人，此处使用2个fragment切换显示，按部门显示需要体现部门层级关系，需要实现点击返回上级部门。因为Fragment并不能像在Actvity重写onBackPressed即可，此时就需要在Fragment监听处理返回，否则返回事件在Activity中，并不能返回上级部门。 Fragment中没有可以主动获取焦点的控件（如：edittext） 12345678910111213141516//主界面获取焦点@SuppressWarnings("ConstantConditions")private void getFocus() &#123; getView().setFocusableInTouchMode(true); getView().requestFocus(); getView().setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (event.getAction() == KeyEvent.ACTION_UP &amp;&amp; keyCode == KeyEvent.KEYCODE_BACK) &#123; //TODO: handle back button return true; &#125; return false; &#125; &#125;);&#125; Fragment中有可以主动获取焦点的控件,需要对它进行处理 12345678910111213editText.setOnKeyListener(new View.OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_UP) &#123; //关闭软键盘 InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(editText.getWindowToken(), 0); //TODO: handle back button return true; &#125; return false; &#125;&#125;); 参考来源：https://stackoverflow.com/questions/22552958/handling-back-press-when-using-fragments-in-android 以上方法测试有效，另附上其他方法（未测试） 两步搞定Fragment的返回键]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10 小箭头去除与恢复]]></title>
    <url>%2F2018%2F01%2F02%2Fwin10-%E5%B0%8F%E7%AE%AD%E5%A4%B4%E5%8E%BB%E9%99%A4%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[1.去掉小箭头123456reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons" /v 29 /d "%systemroot%\system32\imageres.dll,197" /t reg_sz /ftaskkill /f /im explorer.exeattrib -s -r -h "%userprofile%\AppData\Local\iconcache.db"del "%userprofile%\AppData\Local\iconcache.db" /f /qstart explorerpause 复制上面的代码，新建一个txt文件，粘贴后另存为.bat文件，然后以管理员身份打开。 2.恢复小箭头123456reg delete "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons" /v 29 /ftaskkill /f /im explorer.exeattrib -s -r -h "%userprofile%\AppData\Local\iconcache.db"del "%userprofile%\AppData\Local\iconcache.db" /f /qstart explorerpause 同理，复制上面的代码，新建一个txt文件，粘贴后另存为.bat文件，然后以管理员身份打开。]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 平台版本支持的 API 级别 设备指数查看]]></title>
    <url>%2F2017%2F12%2F28%2FAndroid-%E5%B9%B3%E5%8F%B0%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81%E7%9A%84-API-%E7%BA%A7%E5%88%AB-%E8%AE%BE%E5%A4%87%E6%8C%87%E6%95%B0%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[平台版本 API VERSION_CODE 备注 Android 7.0 24 N 平台亮点 Android 6.0 23 M 平台亮点 Android 5.1 22 LOLLIPOP_MR1 平台亮点 Android 5.0 21 LOLLIPOP Android 4.4W 20 KITKAT_WATCH 仅限 KitKat for Wearables Android 4.4 19 KITKAT 平台亮点 Android 4.3 18 JELLY_BEAN_MR2 平台亮点 Android 4.2、4.2.2 17 JELLY_BEAN_MR1 平台亮点 Android 4.1、4.1.1 16 JELLY_BEAN 平台亮点 Android 4.0.3、4.0.4 15 ICE_CREAM_SANDWICH_MR1 平台亮点 Android 4.0、4.0.1、4.0.2 14 ICE_CREAM_SANDWICH Android 3.2 13 HONEYCOMB_MR2 Android 3.1.x 12 HONEYCOMB_MR1 平台亮点 Android 3.0.x 11 HONEYCOMB 平台亮点 Android 2.3.4Android 2.3.3 10 GINGERBREAD_MR1 平台亮点 Android 2.3.2Android 2.3.1Android 2.3 9 GINGERBREAD Android 2.2.x 8 FROYO 平台亮点 Android 2.1.x 7 ECLAIR_MR1 平台亮点 Android 2.0.1 6 ECLAIR_0_1 Android 2.0 5 ECLAIR Android 1.6 4 DONUT 平台亮点 Android 1.5 3 CUPCAKE 平台亮点 Android 1.1 2 BASE_1_1 Android 1.0 1 BASE 附属: 官网最新对应关系查看 官方有关运行各版本的设备的相对数量的信息查看 友盟全域罗盘设备指数查看 腾讯移动分析查看]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment中使用setOnItemClickListener监听无效的解决办法]]></title>
    <url>%2F2017%2F12%2F27%2FFragment%E4%B8%AD%E4%BD%BF%E7%94%A8setOnItemClickListener%E7%9B%91%E5%90%AC%E6%97%A0%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Activity中用fragment 实现了一个ListView并对每一个Item设置监听，不是对Item里的组件设置监听。测试点击的时候发现点击不起作用，后来找到解决办法如下： 需要在listview的item选项中配置 Android:focusable=”false”12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="38dp" android:focusable="true" android:gravity="center_vertical" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/music_menu_image" android:layout_width="50dp" android:layout_height="match_parent" android:src="@drawable/img_icn_local"/&gt; &lt;TextView android:id="@+id/music_menu_text" android:layout_width="wrap_content" android:layout_height="match_parent" android:gravity="center_vertical" android:textColor="@android:color/black" android:textSize="16sp"/&gt; &lt;TextView android:id="@+id/music_menu_num" android:layout_width="wrap_content" android:layout_height="match_parent" android:gravity="center_vertical" android:paddingLeft="2dp" android:textSize="12sp"/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio更新 无法在线更新 使用增量更新]]></title>
    <url>%2F2017%2F12%2F27%2FAndroid-Studio%E6%9B%B4%E6%96%B0-%E6%97%A0%E6%B3%95%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0-%E4%BD%BF%E7%94%A8%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[最近Android Studio更新到了3.0版本，而我还是处于2.2版本，无法使用Android Studio Help下的check for updates…在线更新到最新版。由于本人比较懒，不想卸载后重装去配置环境等繁琐操作，记得偶然一次看视频时别人提到不能直接解决办法。只记得需要一步步升级，少量更新到最新版，具体操作在一顿Google下发现【增量更新】。很多博客都有写怎么操作，经过实践好多都不起作用，经过多次尝试最终成功。记录下操作，避免日后忘记…. 一 、检查当前Android Studio版本 1 Android Studio Help =&gt; about 查看版本号，我的是145.3276617 2 Android Studio 安装根目录下build.txt查看版本号，同样是145.3276617注：此处没有图截到旧版图参考，可依照第五步截图 二、获取最新的版本信息 历史版本以及最新的版本信息可以在 https://dl.google.com/android/studio/patches/updates.xml 三、增量更新包下载我们通过如下的方式拼接适合自己的增量包的URL： https://dl.google.com/android/studio/patches/AI-[当前安装版本号]-[要更新的目标版本]-patch-win.jar比如，如果按我们刚刚截图的版本号来获取离线包，则 URL 为： https://dl.google.com/android/studio/patches/AI-145.3276617-162.3508619-patch-win.jar 四、增量更新包安装 1 将更新包放在除Android Studio 安装根目录之外的任意目录，可以放在其他盘 2 首先关闭所有的 Android Studio任务，把得到的 jar 更新包放到除Android Studio安装目录的任意目录下。在Android Studio根目录按住Shift+右键打开命令窗口或者运行打开CMD切换到Android Studio根目录，输入如下命令： java -classpath D:\AI-145.3276617-162.3508619-patch-win.jar com.intellij.updater.Runner install . 注意最后的 .，意味着将更新包解压到 Android Studio 的安装目录。然后回车执行命令。这时候会弹出对话框，展示安装具体进度： 3 正常更新结束，重启Android Studio导入以前配置即完成更新 五、更新异常处理如果你遇到安装错误，一般是如下： Some conflicts were found in the installation area. Please select desired solutions from the Solution column and press Proceed….. 一般可能的原因有如下一些： 你还有Android Studio任务没有关闭，检查一下，如果有，请关闭 你把离线jar放到了Android Studio的安装目录了，导致文件占用或其他一些错误 如果是Linux或者Mac系统，有可能需要sudo权限来执行安装命令 如此一步步增量，即可更新到能直接使用check for updates…在线更新，或者直接增量到最新版…]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio的Beta Canary Dev Stableb版本介绍]]></title>
    <url>%2F2017%2F12%2F27%2FAndroid-Studio%E7%9A%84Beta-Canary-Dev-Stableb%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Android Studio发布总共分为Beta、Canary、Dev、Stableb四个版本 首先来段官网介绍： Android Studio’s built-in update mechanism can be set to receive updates through any one of these 4 channels. Canary: Bleeding edge, released about weekly. These are early previews released in order to obtain real-world feedback during development. The canary channel will always have the latest build, including updates to beta or stable releases. We recommend running canary builds side-by-side with a beta or stable installation. Dev: Canary builds after a full round of internal testing get promoted into the Dev Channel. Beta: Release candidates based on stable canary builds, released and updated to obtain feedback prior to the stable release. The beta channel will be updated with new stable builds until a new canary build goes to beta. Stable: The official stable release, as available from the Android Developer site. 大概意思：Android Studio内置的更新机制被设置成为如下四个可选的版本： Canary（金丝雀）：Bleeding Edge（一种最新的、因而也并非完美的技术）,大约周更。这是最早被发布的预览版本，为了能够在开发过程中获得真实世界的反馈。金丝雀版本会一直拥有最新的版本包括beta、stable发布版的更新。我们建议在安装金丝雀版本的同时再安装一个beta版本或者stable版本 Dev（开发版）：金丝雀版本在经过完整的测试之后会被提升到Dev版本 Beta（Beta版）：发布预选基于稳定的金丝雀版本。被发布并更新以获取反馈先于稳定版本。Beta版本将与一个新的稳定版本一起被更新，直到一个新的金丝雀版本被确定为Beta版本 Stable（稳定版）：从Android Developer网站上可获得的稳定版本 Android Studio 增量更新：Android Studio更新 无法在线更新 使用增量更新]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 实用插件收集]]></title>
    <url>%2F2017%2F12%2F26%2FAndroid-Studio-%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[1 Material Theme UI EAP 、Material Theme UI ：Android Studio界面设计为Material Design风格 2 Android Wifi ADB：连接一次后 就可以使用WiFi连接手机 3 Gson Format：快速转换json 【强烈推荐】 4 Android Parcelable Code Generator： JavaBean序列化，快速实现Parcelable接口 【强烈推荐】 5 ButterKnife Zelezny：ButterKnife 注解生成器 6 ECTranslation：Android Studio 翻译插件 7 checkstyle-idea：检查代码风格 8 FindBugs-IDEA：帮你找到隐藏的bug及不好的做法 9 Android Material Design Icon Generator：生成Material Design Icon 10 SelectorChapek for Android：Selector文件生成 11 .ignore : git忽略文件插件 12 Lifecycle Sorter : Activity或者fragment的生命周期排序 13 CodeGlance：预览代码，实现快速定位 14 android-strings-search-plugin：通过输入文字找到strings.xml资源 15Alibaba Java Coding Guidelines: 阿里巴巴规约插件 【强烈推荐】]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份不错的安卓代码规范 - 转载]]></title>
    <url>%2F2017%2F12%2F25%2F%E4%B8%80%E4%BB%BD%E4%B8%8D%E9%94%99%E7%9A%84%E5%AE%89%E5%8D%93%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在实际开发中代码规范是很重要的，一团糟的的代码，谁看着都很头疼，维护起来相当痛苦。实际工作中，很多程序员都只顾自己痛快，而不遵从一定的规则，没有任何注释且自带混淆功能。最近看到这份规范，大部分和自己平时的习惯都很符合，便忍不住转( chao )载（xi）了过来，希望大家能够扩散起来。这份规范在GitHub上已经超过3k的star了，可见大家还是很认同的(原文是英语的，有兴趣可以直接看看，文末也会附上转( chao )载（xi）的译文地址)。 1. 项目指南1.1 项目结构新项目应该遵循安卓Gradle项目结构，定义在这里 ：安卓Gradle插件用户指南。项目ribot Boilerplate 是一个很好的参考。 1.2 文件命名1.2.1 类文件类名书写方式是 大写的驼峰命名.继承于安卓组件的类，名称应该以继承的组件命名，比如：SignInActivity, SignInFragment, ImageUploaderService, ChangePasswordDialog. 1.2.2 资源文件资源文件书写方式：小写_下划线。如：ic_launcher.png (实际上资源文件命名是不允许大小的) 1.2.2.1 Drawable 文件 drawable类型资源命名： 资源类别 前缀 例子 Action bar ab_ ab_stacked.9.png Button btn_ btn_send_pressed.9.png Dialog dialog_ dialog_top.9.png Divider divider_ divider_horizontal.9.png Icon ic_ ic_star.png Menu menu_ menu_submenu_bg.9.png Notification notification_ notification_bg.9.png Tabs tab_ tab_pressed.9.png 图标（icons）命名方式 (取自 安卓图标官方指南): 资源类别 前缀 例子 Icons ic_ ic_star.png Launcher icons ic_launcher ic_launcher_calendar.png Menu icons and Action Bar icons ic_menu ic_menu_archive.png Status bar icons ic_stat_notify ic_stat_notify_msg.png Tab icons ic_tab ic_tab_recent.png Dialog icons ic_dialog ic_dialog_info.png selector 状态命名方式: 状态 后缀 例子 Normal (正常) _normal btn_order_normal.9.png Pressed（按下） _pressed btn_order_pressed.9.png Focused （获得焦点） _focused btn_order_focused.9.png Disabled （不可用） _disabled btn_order_disabled.9.png Selected （选中） _selected btn_order_selected.9.png 1.2.2.2 布局文件布局文件应该跟对应的安卓组件名称匹配，但是把最顶级的组件名称放在前面。比如，当我们创建一个用于 SignInActivity的布局，那布局文件名称应该是activity_sign_in.xml. 组件 类名 布局文件名 Activity UserProfileActivity activity_user_profile.xml Fragment SignUpFragment fragment_sign_up.xml Dialog ChangePasswordDialog dialog_change_password.xml AdapterView item — item_person.xml Partial layout — partial_stats_bar.xml 一个稍微不同的地方是当我们创建用于Adapter渲染的布局,如填充一个 ListView， 在这种情况下，布局文件命名应该是用 item开始。注意有些地方这些规则没法应用，如，当我们创建一个布局文件，用于渲染另一个布局的一部分，这样的情况下，我们应该使用partial前缀。 1.2.2.3 菜单文件跟布局文件相似，按钮文件应该跟对应的组件匹配。比如：当我们定义一个菜单，用于 UserActivity，那么文件名应该是 activity_user.xml，文件名不含有menu是个良好的习惯做法，因为这些文件已经位于 menu 目录了。 1.2.2.4 取值文件(Values files)在values文件夹的资源文件应该是复数形式（plural），比如，strings.xml, styles.xml, colors.xml, dimens.xml, attrs.xml 2 代码指南2.1 Java语言规范2.1.1 不要忽略了异常你万不该这样做:12345void setServerPort(String value) &#123; try &#123; serverPort = Integer.parseInt(value); &#125; catch (NumberFormatException e) &#123; &#125;&#125; 虽然你可能觉得你的代码永远不会抛出这个异常或者这异常不重要，不需要处理它，像上面那样忽略异常会在你的代码中留下雷区，将来其他人会踩到。你必须在你的代码中以某种原则的方式处理每个异常。具体的处理视情况而定。 安卓官方代码指南 指南中关于不要忽略异常的说明在这里. 2.1.2 不要捕获一类异常。你不应该这样做:12345678try &#123; someComplicatedIOFunction(); // 可能抛出 IOException someComplicatedParsingFunction(); // 可能抛出 ParsingException someComplicatedSecurityFunction(); // 可能抛出 SecurityException //呵呵，统一处理掉&#125; catch (Exception e) &#123; //我将捕获所有的异常 handleError(); // 使用一个通用的处理手段!&#125; 查看不这样做的原因以及要怎么做的原因 2.1.3 不要用finalizer我们不使用finalizer。它什么时候被调用是没有保证的，甚至它不被调用。大部分情况下，你可以使用良好的异常处理来满足需要在finalizer中做的工作。如果你确实需要它，定义一个 close() 方法（或类似的）然后在文档中明确的指出什么时候这个方法需要被调用。可以查看 InputStream 做为例子.这种情况下，在finalizer中打印一个简短的log信息是恰当的但不是必须的，因为我们不希望log泛滥 猛戳安卓官方指南之不要用finalizer 2.1.4 完全的import语句12反例: import foo.*;正解: import foo.Bar; 点击这里查看更多说明 2.2 Java风格规范2.2.1 全局变量定义及命名全局变量应该定义在文件的头部,遵循下面的命名规则。 私有的非静态全局变量以m开头私有的静态全局变量以s开头其他的全局变量以小写单词开头常量使用全部大写，单词间用下划线间隔（ALL_CAPS_WITH_UNDERSCORES） 译者注：这个规则取自Android Open Source Project代码贡献规范。在程序员的圈子里对于要不要前缀这个问题已经吵翻天了。我在使用greendao的时候使用前缀的话，自动生成的getter/setter会是getMxxx/setMxxx这样难看的方法。很多人也觉得这个命名规则没有意义。stackOverFlow 还有 这里 ，以及一本教你怎么写出整洁代码的书中如是说：“我觉得如今这些前缀没有意义，尤其是在你的APP中!你的类和方法应该尽量的小，而且你应该使用代码高亮的编辑环境，使得成员变量易于分辨。再者，人们快速适应忽略了前缀或后缀来看名字的有意义部分。我们阅读代码越多，看到前后缀越少。渐渐地，前缀就变成了旧代码看不到的线索和标记。——代码整洁之道(Clean.Code).Robert.C.Martin” 例子:12345678public class MyClass &#123; public static final int SOME_CONSTANT = 42; public int publicField; private static MyClass sSingleton; int mPackagePrivate; private int mPrivate; protected int mProtected;&#125; 2.2.3把首字母缩写当做一个单词来看 好的 不好的 XmlHttpRequest XMLHTTPRequest getCustomerId getCustomerID String url String URL long id long ID 2.2.4 使用空格缩进使用四个空格做代码块缩进:123if (x == 1) &#123; x++;&#125; 换行时使用8个空格缩进:12Instrument i = someLongExpression(that, wouldNotFit, on, one, line); 2.2.5 使用标准的大括号风格大括号的开始跟代码同一行1234567891011class MyClass &#123; int func() &#123; if (something) &#123; // ... &#125; else if (somethingElse) &#123; // ... &#125; else &#123; // ... &#125; &#125;&#125; 条件语句使用大括号包住，除非条件体只有一行。如果条件及只有一行条件体，而且没被换行，大括号是不必的。1if (condition) body(); 这是不好的:12if (condition) body(); // 不好的，没有大括号包围! 译者注：这个个人感觉一行的也加上大括号比较好，因为后续可能就不止一行，这样加代码就不用再加括号，而且不加大括号可读性不好。比如下面的例子1234if(flag == 0) a++;else &#123; b--;&#125; 2.2.6 注解2.2.6.1 注解实践规范根据安卓代码风格指南，一些Java内置的注解标准的实践规范有： @Override: 无论一个方法是重载父类还是实现某个接口的都必须使用@Override 注解。比如，当你使用 @inheritdocs Javadoc 标签,然后 从一个类(不是一个接口)中导出，你也必须声明那个方法 @Overrides 父类的方法。 @SuppressWarnings: @SuppressWarnings 注解应该仅当不可能消除一个警告的时候才使用。如果一个警告 通过这个 “不可能消除” 的测试, @SuppressWarnings 注解必不可少, 以便保证所有的警告在代码中反映实际的问题。 关于注解的更多指南可以查看这里 2.2.6.2 注解风格 类，方法及构造器 当注解被应用到一个类，方法或者构造函数时候，注解在代码注释之后，一行一个注解1234/* 这是这个类的注解 */@AnnotationA@AnnotationBpublic class MyAnnotatedClass &#123; &#125; 属性属性的注解应该在同一行列出。除非这一行超过了最大字数了。 1@Nullable @Mock DataManager mDataManager; 2.2.7 限制变量范围变量的使用范围应该限制到最小(Effective Java 条目 29)。这样做，你可以为你的代码增加可读性和可维护性，减少可能的错误。每个变量应该在最内层的使用到的它代码块中定义 局部变量应该在第一次用到他们的时候定义。几乎每个局部变量都应该初始化。如果你没有足够的信息去初始化一个变量，你应该延迟声明这个变量，直到你有足够的初始化信息。安卓代码风格指南 2.2.8 排序import语句如果你使用IDE,如Android Studio，你不必担心这些规则，这些IDE已经遵循这些规则。如果你不用IDE，往下看这些规则: import 安卓框架的 import 来自第三方的(com, junit, net, org) java 以及 javax 同一个项目的 imports 为了保持跟IDE的设置一致，这些imports应该是这样的： 首字母分组排序，大写的字母在小写的字母前面（如Z在a前面）。 每个主要分组 (android, com, junit, net, org, java, javax)间应该有一行空行。更多信息查看这里2.2.9 日志(Loging)指南 使用 Log 类提供的日志方法来打印错误信息或对开发者分辨问题有用的其他信息： Log.v(String tag, String msg) (verbose) Log.d(String tag, String msg) (debug) Log.i(String tag, String msg) (information) Log.w(String tag, String msg) (warning) Log.e(String tag, String msg) (error) 通常来说，我们使用一个类的名称作为一个TAG，在文件的开头定义成一个 static final 变量，如：123456public class MyClass &#123; private static final String TAG = MyClass.class.getSimpleName(); public myMethod() &#123; Log.e(TAG, "My error message"); &#125;&#125; VERBOSE 和 DEBUG 日志 必须在release版本中禁用。同时也建议禁用INFORMATION, WARNING 和 ERROR 日志，但是你可能觉得它们在release版本中定位问题很有用而保持启用。如果你决定让他们保持启用，你要保证这些日志信息不会泄漏email地址，用户id之类的隐私信息。仅限debug版本显示Log的配置：1if (BuildConfig.DEBUG) Log.d(TAG, "The value of x is " + x); 2.2.10 类成员排序这虽然没有简单正确的方案，但是使用一个逻辑的及一致的顺序可以提高代码的可读性和可学习性。下面是推荐的顺序： 常量 全局变量 构造函数 重载的函数和回调 (public 或 private) Public 方法 Private 方法 内部类或内部接口 例子:12345678910111213141516public class MainActivity extends Activity &#123; private String mTitle; private TextView mTextViewTitle; public void setTitle(String title) &#123; mTitle = title; &#125; @Override public void onCreate() &#123; ... &#125; private void setUpView() &#123; ... &#125; static class AnInnerClass &#123; &#125;&#125; 如果你的类继承一个安卓组件如Activity或Fragment，对重载的方法进行排序以便跟组件的生命周期匹配是一个最佳实践。比如，当你的Activity实现onCreate(), onDestroy(), onPause() 和 onResume()，正确的顺序是：1234567891011public class MainActivity extends Activity &#123; //顺序跟Activity的生命周期匹配 @Override public void onCreate() &#123;&#125; @Override public void onResume() &#123;&#125; @Override public void onPause() &#123;&#125; @Override public void onDestroy() &#123;&#125;&#125; 2.2.11 方法的参数顺序在安卓编码时候，定义一个方法拥有一个Context参数是非常常见的，如果你写一个这样的方法，Context应该是第一个参数。 相反的例子是回调接口，它应该是最后一个参数例子:1234// Context 总是在第一个位public User loadUser(Context context, int userId);// 回调总是在最后一位public void loadUserAsync(Context context, int userId, UserCallback callback); 2.2.13 字符串常量，命名和取值很多安卓SDK的元素如SharedPreferences, Bundle, 或 Intent使用键值对实现，所以即使是一个小应用，使用一堆字符串常量也是很常见的。 当使用这些组件，你必须定义这些键是 static final 变量，并且它们应该像下面这样使用前缀 元素 变量名前缀 SharedPreferences PREF_ Bundle BUNDLE_ Fragment Arguments ARGUMENT_ Intent Extra EXTRA_ Intent Action ACTION_ 注意Fragment的参数——Fragment.getArguments()也是一个Bundle。然而，因为这是Bundle非常常见的用法，我们为它定义一个不同的前缀。 例子:12345678//注意这些变量的值应该和名称一致来避免问题static final String PREF_EMAIL = "PREF_EMAIL";static final String BUNDLE_AGE = "BUNDLE_AGE";static final String ARGUMENT_USER_ID = "ARGUMENT_USER_ID";//Intent相关的使用完全包名作为值static final String EXTRA_SURNAME = "com.myapp.extras.EXTRA_SURNAME";static final String ACTION_OPEN_USER = "com.myapp.action.ACTION_OPEN_USER"; 2.2.14 Fragment和Activity的参数当数据通过Intent 或Bundle传递到一个Activity或 Fragment，这些不同值的键必须 遵循上面描述的规则。当一个 Activity 或 Fragment 想要参数，它应该提供一个public static方法来简化对应的Intent 或 Fragment创建在Activity中这个方法通常叫 getStartIntent():12345public static Intent getStartIntent(Context context, User user) &#123; Intent intent = new Intent(context, ThisActivity.class); intent.putParcelableExtra(EXTRA_USER, user); return intent;&#125; 对于Fragment它的名称是newInstance()，处理使用合适的参数创建Fragment。1234567public static UserFragment newInstance(User user) &#123; UserFragment fragment = new UserFragment; Bundle args = new Bundle(); args.putParcelable(ARGUMENT_USER, user); fragment.setArguments(args) return fragment;&#125; 注意1: 这些方法应该在类的 onCreate()前面 注意2: 如果我们提供上面说的方法，这些extras对应的键和参数应该是private的，因为他们不需要暴露到类以外。 2.2.15 代码行长度限制代码行不应该超过100 个字符。如果代码行超过这个限制长度，通常有两种方式来降低长度： 提取一个局部变量或方法（推荐方式）. 把单行换行成多行 有两种例外可以让一行超过100字符： 这行不可分割，如长URL package 和 import 语句 2.2.15.1 换行策略没有精确的公式解释怎么换行，很多不同的方案是有效的。然而，这里有几个规则可以应用到常见情况。 在操作符前断开 当一行被操作符断开，断开处应该在操作符之前，例子如下：12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 赋值符号（=）例外 在操作符前断开有一个例外，那就是赋值符号 =，应该在赋值符号后面断开。12int longName = anotherVeryLongVariable + anEvenLongerOne - thisRidiculousLongOne + theFinalOne; 方法链的情况 当多个方法被链接在同一行的时候——如使用Builder时，每一个方法的调用应该在独立一行，在 .之前断开。1234Picasso.with(context).load("http://ribot.co.uk/images/sexyjoe.jpg").into(imageView);Picasso.with(context) .load("http://ribot.co.uk/images/sexyjoe.jpg") .into(imageView); 长参数的情况 当一个方法有很多参数或它的参数非常长，我们应该在每个逗号 ,后面断开123456loadPicture(context, "http://ribot.co.uk/images/sexyjoe.jpg", mImageViewProfilePicture, clickListener, "Title of the picture");loadPicture(context, "http://ribot.co.uk/images/sexyjoe.jpg", mImageViewProfilePicture, clickListener, "Title of the picture"); 2.2.16 RxJava 链式风格Rx链式操作符要求换行。每一个操作符必须在新的一行，断行应该在.之前123456789101112131415public Observable&lt;Location&gt; syncLocations() &#123; return mDatabaseHelper.getAllLocations() .concatMap(new Func1&lt;Location, Observable&lt;? extends Location&gt;&gt;() &#123; @Override public Observable&lt;? extends Location&gt; call(Location location) &#123; return mRetrofitService.getLocation(location.id); &#125; &#125;) .retry(new Func2&lt;Integer, Throwable, Boolean&gt;() &#123; @Override public Boolean call(Integer numRetries, Throwable throwable) &#123; return throwable instanceof RetrofitError; &#125; &#125;);&#125; 2.3 XML 风格规定2.3.1 使用自关闭的标签当一个XML元素没有任何内容时，你必须使用自关闭标签。这是好例子:1234&lt;TextView android:id="@+id/text_view_profile" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 这是不好的例子 :12345&lt;TextView android:id="@+id/text_view_profile" android:layout_width="wrap_content" android:layout_height="wrap_content" &gt;&lt;/TextView&gt; 2.3.2 资源命名资源 ID 和名称使用小写加下划线方式 lowercase_underscore. 2.3.2.1 ID 命名ID应该使用小写加下划线命名，加上元素名称为前缀，如： 元素 前缀 TextView text_ ImageView image_ Button button_ Menu menu_ ImageView例子:1234&lt;ImageView android:id="@+id/image_profile" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; Menu 例子:12345&lt;menu&gt; &lt;item android:id="@+id/menu_done" android:title="Done" /&gt;&lt;/menu&gt; 2.3.2.2 字符串字符串名称以它们所属的部分为前缀命名，比如registration_email_hint 或 registration_name_hint。如果一个字符串不属于任何部分，那么你应该遵循下面的规则： 前缀 描述 error_ An error message msg_ A regular information message title_ A title, i.e. a dialog title action_ An action such as “Save” or “Create” 2.3.2.3 Styles 和 Themes不像其他的资源，style命名方式是大写的驼峰是命名UpperCamelCase 2.3.3 属性顺序作为通用的规则，你应该把相似的属性放在一起分组，一个对常见属性良好的排序方式是 View Id Style 布局的宽和高 其他的布局属性，按字母排序 剩下的属性，按字母排序 2.4 测试风格规定2.4.1单元测试测试类应该跟需要测试的类名字对应，以Test做后缀。比如我们创建一个测试类包含对DatabaseHelper的测试，我们应该把它命名为 DatabaseHelperTest。 测试方法用@Test注解，通常以要测试的方法名为命名开始，以测试的前置条件及/或期望结果做后缀。 模板: @Test void methodNamePreconditionExpectedBehaviour() 例子: @Test void signInWithEmptyEmailFails() 如果没有它们测试也能够清楚的表达，前置条件和/或期望结果不总是必须的。 有时候一个类可能包含一大堆方法，同时每个方法要求多个测试，在这种情况，推荐把测试类分割成几个。比如，如果 DataManager包含一大堆方法，我们可能想把它分到 DataManagerSignInTest, DataManagerLoadUsersTest等等。通常你能够知道哪些测试应该在一起，因为它们有共同的test fixtures. 2.4.2 Espresso 测试每一个 Espresso 测试类目标通常是一个Activity，所以它的名称应该跟目标Activity的名称匹配，以Test结束，如 SignInActivityTest 当使用 Espresso API ，把链式方法调用放新行是一个最佳实践。123onView(withId(R.id.view)) .perform(scrollTo()) .check(matches(isDisplayed())) 转载地址：GitHub上star超过2k的安卓项目和代码风格指南（绝对干货）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 开发环境搭建]]></title>
    <url>%2F2017%2F12%2F25%2FPython3-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[一 Anaconda安装下载对应系统和Python版本的Anaconda，地址：https://www.anaconda.com/download/#windows 。 安装过程中切记： 安装完成后打开cmd，输入 python 回车，检查python安装成功与否： 简单测试python，输入 print (‘hello world! ’) 回车： 退出pyhton交互，输入exit() 回车: 二 PyCharm安装下载对应系统版本的PyCharm，地址：https://www.jetbrains.com/pycharm/download/#section=windows 。]]></content>
      <categories>
        <category>python3</category>
      </categories>
      <tags>
        <tag>pyhton</tag>
      </tags>
  </entry>
</search>
